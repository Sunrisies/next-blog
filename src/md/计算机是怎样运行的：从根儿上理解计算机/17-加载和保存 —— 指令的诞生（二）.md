第18章、指令的诞生（二）
=============

标签： 计算机是怎样运行的

* * *

批量计算
----

狗哥觉得我们刚刚制作的这个机器还不错，于是干脆拿来了二十个表达式来让我们计算（可能是小学二年级的数学试卷上的题）。那我们就得按照下边的步骤计算了：

*   步骤一：先将`表达式1`对应的指令和数据分别填到`指令RAM`和`数据RAM`中，之后将RST\_N信号从逻辑0调整到逻辑1，就可以在`8位输出设备`中观察到`表达式1`的结果。
    
*   步骤二：先将`表达式2`对应的指令和数据分别填到`指令RAM`和`数据RAM`中（也就是覆盖原先的数据），之后将RST\_N信号从逻辑0调整到逻辑1，就可以在`8位输出设备`中观察到`表达式2`的结果。
    
*   ···
    
*   步骤二十：先将`表达式20`对应的指令和数据分别填到`指令RAM`和`数据RAM`中（也就是覆盖原先的数据），之后将RST\_N信号从逻辑0调整到逻辑1，就可以在`8位输出设备`中观察到`表达式20`的结果。
    

可见，要计算20个表达式的值，就得重复20次“向RAM中填入数据，接着等待计算结果”的步骤。这不是不可以，但有没有什么更好的方式呢？比方说我们一次性就将这20个表达式对应的指令和数据都分别输入到`指令RAM`和`数据RAM`中，然后将RST\_N信号从逻辑0调整到逻辑1，这20个表达式的结果就都计算出来了，这不就简单很多了吗！

可问题是我们目前只有一个`8位输出设备`，这个`8位输出设备`该表示哪个表达式的结果呢？难不成需要引入20个`8位输出设备`？其实没必要，RAM既有读出数据的功能，也有写入数据的功能，我们直接把这些表达式的计算结果再写入到`数据RAM`的指定地址处，之后我们想查看哪个表达式的计算结果，直接为`数据RAM`生成相应的地址，再将`数据RAM`的输出接到一个`8位输出设备`上就可以看到结果了嘛！

### store指令的提出

我们知道当RAM的写使能信号WE=0时，不允许向RAM中写入数据；当WE=1时才允许向RAM中写入数据。这个写使能信号WE其实本质上也是一个控制信号，我们可以在指令中扩展一个二进制位来表示这个WE信号，如图所示：

![image_1escjs0t01gfaogc1p7e1kta1t3k9.png-18.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9591c0dd890e4fd8aca79463e5f0f7da~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=564&h=309&s=19146&e=png&b=ffffff)

现在一条指令需要4个二进制位表示，其中编号为3的二进制位表示`数据RAM`的WE信号，编号为2的二进制位表示HALT信号，编号为`0`和`1`的二进制位表示ALU的控制信号。

我们可以单独设计一条`store`指令，在执行该指令时，让`数据RAM`的WE信号为逻辑1。执行其他指令时`数据RAM`的WE信号为逻辑0，那么现在指令所对应的4个二进制位的组合所代表的含义就如下所示：

指令的二进制形式

操作类型

简称

`0100`

加法

add

`0101`

减法

sub

`0110`

按位与

and

`0111`

按位或

or

`X0XX`

停止执行

halt

 

`11XX`

向数据RAM中写入数据

store

 

在执行store指令时，需要保证数据RAM的WE信号为逻辑1，以及HALT信号不为逻辑0，不过ALU的控制信号是什么倒无所谓，所以编号为0和1的二进制位用`XX`表示。

新增了这条`store`指令之后，我们可以这样改造电路图：

![image_1fk6c8r291f3oc8d1lbfosuf4sp.png-64.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9278a58f5fd461ea862fbbd3687ee0a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1326&h=824&s=66148&e=png&b=fefefe)

如图所示，我们做了4处修改：

1.  `数据RAM`的CLK信号不再保持逻辑0不变，而与程序计数器和累加器接收同样的CLK信号。
2.  `数据RAM`的WE信号不再保持逻辑0不变，而是把`指令RAM`的输出的编号为3的位与`数据RAM`的WE信号相连接。这样当`指令RAM`输出的指令为`store`（也就是11XX）时，`数据RAM`的WE信号就被设置为逻辑1。
3.  累加器的输出连接到`数据RAM`的数据输入Din。当`数据RAM`的WE信号为逻辑1时，那么在下一个CLK信号上升沿到达后，累加器的输出代表的数据便可以写入到`数据RAM`。
4.  我们移除了`8位输出设备`。因为现在表达式的运算结果将被写入`数据RAM`，我们之后可以通过查看`数据RAM`中数据的方式去查看运算结果，`8位输出设备`目前就没有存在的必要了。

接下来当然是要实操一下啦，虽然引入`store`指令的目的是为了支持一次计算多个表达式的值，不过我们还是从简单的开始，先看一下如何将一个表达式的计算结果存回到`数据RAM`中。比方说我们要计算`74 + 29 - 32 - 20`的值，并将结果保存到`数据RAM`中，那么`指令RAM`和`数据RAM`中的数据填充效果就应该是这样：

![image_1esclql4r1l9i101u13toum634u13.png-13.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c34ddf7fdf3440c3903f8191e84f80b3~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=369&h=265&s=13748&e=png&b=fefefe)

那么在电路运行的每个阶段，各个设备的输出情况如下所示：

阶段

PC输出（地址信号）

指令RAM输出

数据RAM输出

ACC输出

ALU的控制信号

ALU输出

HALT信号

数据RAM的WE信号

第0周期

0

add(0100)

74

0

00（代表加法）

74（0+74）

1

0

第1周期

1

add(0100)

29

74

00（代表加法）

103（74+29）

1

0

第2周期

2

sub(0101)

32

103

01（代表减法）

71（103-32）

1

0

第3周期

3

sub(0101)

20

71

01（代表减法）

51（71-20）

1

0

第4周期

4

store(11XX)

无所谓

51

XX（代表无所谓）

无所谓

1

1

第5周期

5

halt(X0XX)

无所谓

无所谓

XX（代表无所谓）

无所谓

0

X

从上表中可以看出，在第4周期时，`指令RAM`输出store指令，此时地址信号为4，`数据RAM`的WE信号为逻辑1，累加器的输出为51，在第5周期的时钟信号上升沿到达后，`51`将会被写入到`数据RAM`中地址为4的地方。在第5周期中，`指令RAM`输出halt指令，电路停止运行，此时的`数据RAM`中的数据填充情况就如下所示：

![image_1escmn9p81ko619v0172d1ati1ov91g.png-11.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bed3cfe11c4c47bf872f2a0c22c4fba9~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=259&h=363&s=12182&e=png&b=fdfdfd)

可见`数据RAM`中，地址为4时，对应的数据就是`51`。

> 小贴士：  
>   
> 这里需要强调的一点是，虽然在第4周期时，指令RAM输出store指令，但是在第5周期的时钟信号上升沿到来后，才真正将运算结果写入到数据RAM中。

如果大家认真观察在每个周期中各个设备的输出情况时就会发现一个较大的问题：在第5周期时钟信号上升沿到达后，累加器的输出变为“无所谓”，这是因为在第4周期执行store指令的时候，该指令对应的数据是无所谓，导致ALU的输出是无所谓，那么自然在第5周期时钟信号上升沿到来后，累加器原先的输出`51`被无效数据覆盖喽~

执行完store指令后，我们并不希望让无效数据将累加器中原先保存的数据覆盖，因为我们可能继续利用累加器中原先保存的数据继续参与运算。比方说在第5周期我们执行的不是halt指令，而是add指令，我们期望累加器中原先保存的数据`51`继续参与加法运算，可如果在第5周期的时候累加器的输出被无效数据覆盖，就做不到这一点了。如何解决这个问题呢？其实只要在第5周期时钟信号上升沿到来时，我们无法向累加器中写入数据即可，如何做到这一点呢？还记得我们之前唠叨过一种称为`带写使能信号的寄存器`吗？它长这样：

![image_1escoo051rbimgop3b1hpg65e1t.png-6.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a47893916cd45e8af3f23ebc429803b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=335&h=312&s=6688&e=png&b=fefefe)

当WE=0时，即使CLK信号上升沿到来后，输出Q也不会改变；当WE=1时，它就是一个普通的寄存器。

如果我们用这个`带写使能信号的寄存器`来作为累加器，在执行`store`指令的时候让累加器的WE=0，这样在下一个时钟上升沿到来时累加器中的数据就不会被覆盖，在执行其他的算术/逻辑运算时，可以让累加器的WE=1，这样运算结果就可以在下一个时钟上升沿保存到累加器中。这需要我们继续扩展指令占用的二进制位的个数，我们使用编号为4的二进制位来表示累加器的这个WE信号吧，如图所示：

![image_1escrld9n1c942js16g3i4qu4b2a.png-24.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2c5ff6e078a49e9bf9e26dfc51c70a9~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=635&h=312&s=25089&e=png&b=fefcfc)

这样的话，现有的指令的二进制形式就如下表所示：

指令的二进制形式

操作类型

简称

`10100`

加法

add

`10101`

减法

sub

`10110`

按位与

and

`10111`

按位或

or

`XX0XX`

停止执行

halt

 

`011XX`

向数据RAM中写入数据

store

 

将累加器换为`带写使能信号的寄存器`的示意图如下图所示：

![image_1fk6cc1tc1h8o1fqcc711eqe8r42m.png-69.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1959299e68c42469a756e7664aacb48~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1343&h=852&s=70899&e=png&b=fefefe)

emmm... 这回就好了，在执行完store指令后的下一个时钟上升沿也不会修改累加器中的数据了～

### load指令的提出

现在如果我们想同时计算`74 + 29 - 32 - 20`和`((74 | 29) - 32) & 20`这两个表达式的值，那我们可以向`指令RAM`和`数据RAM`中分别输入这样的数据：

![image_1esda8qtd4lkikrtdu1pkn1hdj34.png-31.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a28981488e2b42eeae779e286e8cc03f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=513&h=600&s=32214&e=png&b=fefefe)

我们上边分析过，在第4周期中，`指令RAM`输出store指令，累加器的输出为`51`，相当于得到了表达式`74 + 29 - 32 - 20`结果，此时`数据RAM`的WE信号为逻辑1，累加器的WE信号为逻辑0。在第5周期时钟信号上升沿到来后，`51`将被写入到`数据RAM`的地址为4处，而累加器的输出将保持为51不变（不被无效数据覆盖）。

从第5周期开始，我们期望开始计算表达式`((74 | 29) - 32) & 20`的值，而在第5周期中，`数据RAM`的输出为74，累加器的输出为51，而`指令RAM`输出add指令，这意味着ALU将计算`74 + 51`的值（累加器输出连接着ALU的输入A，RAM输出连着ALU的输入B）！这显然是不靠谱的，在第5周期我们本质上是在开启一个全新的表达式计算过程，在这个周期中我们应该将表达式的第一个数，也就是74作为累加器的输入，以等待第6周期的时钟信号上升沿到达后将74写入累加器中，而不是像现在这样在第6周期时钟信号上升沿到来后将`74+51`写入到累加器中。

我们可以把这个将`数据RAM`中的数据转移到累加器中的这个过程称为加载（英文名：load），接着专门设计一条load指令来完成这个加载操作。在执行load指令时，不论原先累加器的输入是什么（在本例中原先累加器的输入就是74 + 51= 125），只会把`数据RAM`中某个地址对应的数据作为累加器的输入（在当前场景下就是只会把74作为累加器的输入）！

怎么实现这个load指令呢？我们回想一下计算第一个表达式的时候为什么不需要这个load指令呢？这是因为在计算第一个表达式之前累加器中存储的数据是0！`0+74`的结果自然也是74！那我们可以：

*   在执行load指令的时候，让ALU的输入A始终为0。
    
*   在执行其他指令时，可以让累加器的输出仍然连接到ALU的输入A。
    

为实现在两组输入信号（0或者累加器的输出）中选择一组作为输出的功能呢，应该使用什么设备呢？废话，当然是`2-1选择器`，引入`2-1选择器`的电路图如下所示：

![image_1fk6cg84sac31a5j1g62l1jl7h9.png-70.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c67b9f8970bf47faa7e4f98fa80e497f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1374&h=848&s=71796&e=png&b=fdfdfd)

`2-1选择器`需要一个控制信号，而这个控制信号又得体现在指令中，所以我们的指令又得扩展一个二进制位了：

![image_1esdb01f115gt1ddqod612qj1ak63u.png-32.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27214fb9fd8645fba9147dbc8def3114~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=878&h=316&s=33717&e=png&b=fefcfc)

如图所示，我们让指令中编号为`5`的二进制位表示2-1选择器的控制信号，那么：

*   当该控制信号为逻辑0时，累加器的输出连接到ALU的输入A；
*   当该控制信号为逻辑1时，ALU的输入A始终为0。

这样的话，现有的指令以及其对应的二进制形式就如下表所示：

指令的二进制形式

操作类型

简称

`010100`

加法

add

`010101`

减法

sub

`010110`

按位与

and

`010111`

按位或

or

`XXX0XX`

停止执行

halt

 

`X011XX`

向数据RAM中写入数据

store

 

`110100`

将RAM中的数据加载到累加器中

load

 

引入了这个`load`指令后，我们就可以修改一下`指令RAM`和`数据RAM`中的数据了：

![image_1esdb4u2v2i5l006miju6sjk4b.png-30.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50bbdbef28a24ee9a75be80ff0770798~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=483&h=599&s=31021&e=png&b=fefefe)

如图所示，我们把`指令RAM`中地址为0和5的指令都改为了`load`。

在执行完这些指令之后，表达式`74 + 29 - 32 - 20`的结果将存储在`数据RAM`的地址为4处，表达式`((74 | 29) - 32) & 20`的结果将存储在`数据RAM`的地址为9处。

> 小贴士：  
>   
> 这里也需要大家注意一下，类似store指令，在执行load指令的时钟周期内并不会把数据真正写入到累加器中，而是在下一个时钟周期的时钟信号上升沿数据才会真正写到累加器中。比方说上边例子中在第0周期和第5周期执行load指令，那么会分别在第1周期和第6周期的时钟信号上升沿到达后将数据RAM中的数据写入到累加器中。