第10章、补数和减法
==========

标签： 计算机是怎样运行的

* * *

我们刚才使用已有的逻辑门设计了一个处理二进制数加法的电路，有同学自然想问减法是怎么处理的呢？在加法运算中，单个位相加时可能产生进位，而在减法运算中却可能产生借位。理论上我们也可以仿照设计`n位加法器`的过程逐步去设计一个`n位减法器`，不过我们并不打算这么做，而是去直接重复利用已经设计好的`n位加法器`来解决减法问题，这样省事儿～

二进制中的补数
-------

重新思考一下计算机中使用固定个数的二进制位来表示数字这个事儿，如果我们使用4个二进制位表示数字，那能表示的数字范围就是：`0000₂~1111₂`，共16（`24`）个数字。

`1111₂`是能表示的最大的数字，如果我们给`1111₂`再加1会发生什么？当然结果会变成`10000₂`，但是已经规定使用4个二进制位表示数字，那就需要忽略掉加数中最高有效位相加得到的进位，导致结果成为了`0000₂`，感觉人生陷入了一场新的轮回～

我们在现实生活中有这种走着走着就从头开始的感觉么？秒针走到了59秒的地方之后再走一秒又从0秒开始，分针走到了59分的地方之后再走一分又从0分开始，时针走到了11时的时候再走1个小时就又从0时开始（对于十二时针刻度的表盘来说）～ 这给了我们一个灵感，我们可以将使用4个二进制位表示的数字放在表盘上，然后画上16个刻度，每个刻度对应一个数字，就像这样：

![image_1eq9m5269u74oa21tst1d55859.png-38kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1265be61e46d4d928b26bcdf3774097e~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=486&h=428&s=38885&e=png&b=ffffff)

另外，我们顺便画了一个指针，现在指针指向`0000₂`，表明现在表盘表示的数字就是`0000₂`。

看着上图中的表盘，我们先将指针顺时针拨动`1111₂`（十进制的`15`）个刻度，然后再顺时针拨动`0001₂`（十进制的`1`）个刻度，那么指针就会指向原先的位置，相当于完成了一个轮回，我们就可以说`1111₂`和`0001₂`互为补数。我们先将指针顺时针拨动`0101₂`（十进制的`5`）个刻度，然后再顺时针拨动`1011₂`（十进制的`11`）个刻度，那么指针就会指向原先的位置，也相当于完成了一个轮回，我们就可以说`0101₂`和`1011₂`互为补数。类似的，`0110₂`（十进制的`6`）和`1010₂`（十进制的`10`）也算是互为补数，`0111₂`（十进制的`7`）和`1001₂`（十进制的`9`）也算是互为补数～

更一般的，在我们规定使用n个二进制位表示数字的时候，如果两个数之和为2n，那我们称这两个数互为补数。概念很简单哈，不过千万千万要注意：在讨论补数时一定要限定一下我们当前使用几个二进制位来表示数字。如果我们现在规定使用8个二进制位表示数字，因为`00000101₂`和`11111011₂`（251₁₀）满足下边的关系：

000001012+111110112\=1000000002\=2800000101₂ + 11111011₂ = 100000000₂ = 2^8000001012​+111110112​\=1000000002​\=28

我们就说`00000101₂`（5₁₀）和`11111011₂`（251₁₀）在规定使用8个二进制位表示数字时互为补数。从表盘的角度讲，在规定使用8个二进制位表示数字时，此时的表盘上就应该有28，也就是256个刻度，指针从某个位置沿着一个方向转`00000101₂`（5₁₀）个刻度后，继续沿着该方向转`11111011₂`（251₁₀）个刻度正好是一圈，从而回到出发时的位置。

上边提到的`0101₂`和`00000101₂`虽然都代表十进制中的`5`，但是由于规定表示数字的二进制位个数不同，它们对应的补数也是不同的。

如何求一个二进制数的补数
------------

在限定了使用n个二进制位来表示数字之后，怎么求一个二进制数的补数呢？最容易想到的方法就是使用2n减去这个数。比方说在我们限定了使用3个二进制位来表示数字之后，如果我们想求`101₂`的补数，那就使用`1000₂`（也就是23）来减去这个二进制数`101`。

      1000₂
    -  101₂
    -------- 
       011₂    
    

不过这个过程需要使用到借位，如果我们想用更简单的方式计算出结果的话，可以使用下边两个步骤来计算：

*   步骤一：使用`111₂`减去`101₂`：
    
           111₂
        -  101₂
        -------- 
           010₂
        
    
    这个过程不需要使用到借位，可以很轻松的算出`111₂ - 101₂`的结果是`010₂`
    
*   步骤二：然后再将步骤一中的结果加`1`：
    
           010₂
        +    1
        -------- 
           011₂   
        
    
    这个`011₂`就是`1000₂ - 101₂`的差。
    

通过使用这两个步骤，我们成功的避免了减法中的借位，很轻松的算出了101₂的补数011₂。其实这个过程本质上就是这样的：

    1000₂ - 101₂ = 111₂ + 1 - 101₂
               = (111₂ - 101₂) + 1
               = 010₂ + 1
               = 011₂
    

一般地，在我们限定了使用n个二进制位来表示数字之后，可以通过下边两个步骤来求一个二进制数的补数：

*   步骤一：先计算由n个`1`组成的二进制数字（其实也就是`2n - 1`）减去该数的值（此过程不涉及借位）。
    
*   步骤二：然后将上一步骤的结果加1。
    

当然，划分成这两个步骤不仅仅是为了让人类在计算时减少借位过程，我们的落脚点还是想让机器来替代我们进行计算。现在重新聚焦于步骤一，如果有一个使用n个二进制位表示的数字：xn−1xn−2⋅⋅⋅x2x1x0x\_{n-1}x\_{n-2}···x\_{2}x\_{1}x\_{0}xn−1​xn−2​⋅⋅⋅x2​x1​x0​，我们想求它的补数，那么首先要计算一下由n个`1`组成的二进制数字减去该数的差。其实这一步骤也相当于求xn−1xn−2⋅⋅⋅x2x1x0x\_{n-1}x\_{n-2}···x\_{2}x\_{1}x\_{0}xn−1​xn−2​⋅⋅⋅x2​x1​x0​加上哪个也使用n个二进制位表示的数字之和为由n个`1`组成的二进制数字，如图所示：

![image_1eq9m6s9gslu1jjtjdl6klfr7m.png-13.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32235cd916f34248a02ab44384ed4edf~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=750&h=348&s=13932&e=png&b=ffffff)

同时我们也知道一个规律：

*   1 + 0 = 1
*   0 + 1 = 1
*   0 + 0 ≠ 1
*   1 + 1 ≠ 1

也就是说如果我们想让两个二进制位相加的和为1，那么这两个二进制位的值肯定不同，要么是`0`和`1`，要么是`1`和`0`。所以如果x0x\_{0}x0​想和另一个二进制位相加得到的和是`1`，那么另一个二进制位的值肯定和x0x\_{0}x0​不同，也就是说如果x0x\_{0}x0​的值是1，那么另一个二进制位的值肯定是0，如果x0x\_{0}x0​的值是0，那么另一个二进制位的值肯定是1。

联想到我们之前唠叨的各种逻辑门，我们只需要让x0x\_{0}x0​作为一个输入信号通过一个反相器，那么就可以得到与它不同的信号xˉ0\\bar{x}\_{0}xˉ0​。这个规律也同样适用于xn−1xn−2⋅⋅⋅x2x1x0x\_{n-1}x\_{n-2}···x\_{2}x\_{1}x\_{0}xn−1​xn−2​⋅⋅⋅x2​x1​x0​中的其他的二进制位，所以我们对xn−1xn−2⋅⋅⋅x2x1x0x\_{n-1}x\_{n-2}···x\_{2}x\_{1}x\_{0}xn−1​xn−2​⋅⋅⋅x2​x1​x0​中的每个二进制位都做`取反`操作，就可以得到步骤一中的目标结果，画个图就像这样：

![image_1eq9m7et21lplsonfs41i6gemo13.png-11.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e29de24203a4c77a5da2a4d2775a906~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=560&h=377&s=11812&e=png&b=ffffff)

然后步骤二就是将步骤一中的结果加1就好了（这个加1的操作如何用机器实现我们稍后再唠叨）。所以总结一下计算某个二进制数的补数的过程就是：将该二进制数中的每一个二进制位都做取反操作，然后再加1，我们可以把这个过程简称为`取反加1`。

利用补数将减法转换为加法
------------

在使用n个二进制位表示数字时，假设yyy、y^\\hat{y}y^​是两个使用n个二进制位表示的数字，它们互为补数，那么我们有：

y+y^\=2ny + \\hat{y} = 2^ny+y^​\=2n

也就可以推出：

y\=2n−y^y = 2^n - \\hat{y}y\=2n−y^​

那么假设xxx也是使用n个二进制位表示的数字，那么我们有：

x−y\=x−(2n−y^)\=x+y^−2nx - y = x - (2^n - \\hat{y}) = x + \\hat{y} - 2^nx−y\=x−(2n−y^​)\=x+y^​−2n

也就是说：在做使用n个二进制位表示的数字之间的减法操作时，减去一个数等于加上这个数的补数然后再减去2n，减去2n的操作其实就相当于直接把两个加数的最高有效位相加（在进行最高有效位相加时，也需要考虑到前一位相加时的进位）时的进位忽略掉，得到的就是原减法的结果。这个事情在表盘上可以有更直观的体现，比方说现在规定使用4个二进制位表示数字，现在指针指向`1000₂`（8₁₀），如果我们想在`1000₂`（8₁₀）的基础上减去`0011`（3₁₀），那么可以采用两种方案：

*   将指针逆时针拨3（`0011₂`）个刻度
    
    ![image_1eq9m839lbqh1o78pp11mjr1pd61g.png-49.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9feedabe37c548e0ac5c3994c9f44d3b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=818&h=345&s=51140&e=png&b=ffffff)
    
*   将指针顺时针拨13（`1101₂`）个刻度
    
    ![image_1eq9m8ota1rcb13ik19uv12b71a6u1t.png-54.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4adb861607b74fd0aa78ee0a97ff7d63~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=825&h=343&s=56019&e=png&b=ffffff)
    

我们可以把逆时针拨动指针当作是在做减法，顺时针拨动指针当作做加法，很显然，逆时针拨动xxx个刻度，就相当于顺时针拨动24−x2^4 - x24−x个刻度。也就是说在使用固定个数的二进制位表示数字时，减去一个数和加上这个数的补数的效果是相同的。我们再多举几个例子：

*   假设x的值为`11010111₂`（215₁₀），y的值是`10010001₂`（145₁₀），我们想求`x - y`的差是多少，就像这样：
    
          11010111₂   //x的值是11010111₂
        - 10010001₂   //y的值是10010001₂
        ------------ 
                 ?
        
    
    首先通过`取反加1`的方式计算出`10010001₂`（145₁₀）的补数是`01101111₂`（111₁₀），然后将被减数`11010111₂`（215₁₀）和`01101111₂`（111₁₀）相加：
    
          11010111₂
        + 01101111₂
        ------------ 
         101000110₂
        
    
    然后减去`100000000₂`（也就是28），减去`100000000₂`的操作也可以相当于把两个加数的最高有效位相加的进位忽略，得到如下结果：
    
        01000110₂
        
    
    也就是说`x - y`的差就是`01000110₂`（70₁₀）。
    
*   假设x的值为`11010111₂`（215₁₀），y的值是`101101₂`（45₁₀），我们想求`x - y`的差是多少，就像这样：
    
          11010111₂   //x的值是11010111₂
        -   101101₂   //y的值是101101₂
        ------------ 
                 ?
        
    
    因为`101101₂`（45₁₀）是使用6个二进制位表示的，所以我们先把它扩展为使用8个二进制位表示的形式（其实就是在数字前加前缀`0`），所以减法看起来就是这样：
    
          11010111₂   //x的值是11010111₂
        - 00101101₂   //y的值是101101₂
        ------------ 
                 ?
        
    
    首先通过`取反加1`的方式计算出`00101101₂`（45₁₀）的补数是`11010011₂`（211₁₀），然后将被减数`11010111₂`（215₁₀）和`11010011₂`（211₁₀）相加：
    
          11010111₂
        + 11010011₂
        ------------ 
         110101010₂
        
    
    然后减去`100000000₂`（也就是28），减去`100000000₂`的操作也可以相当于直接把两个加数的最高有效位相加的进位忽略，得到如下结果：
    
        10101010₂
        
    
    也就是说`x - y`的差就是`10101010₂`（170₁₀）。
    

哇唔，是不是很简单，减法操作顺利的被转换成了加法操作。

使用电路解决二进制减法问题
-------------

通过上边的讨论，相信大家对“在做使用n个二进制位表示的数字之间的减法操作时，减去一个数等于加上这个数的补数然后再减去2n，减去2n的操作其实就相当于直接把两个加数的最高有效位相加时的进位忽略掉，得到的就是原减法的结果”这句话有了深刻的印象（也可能不是很深刻，不深刻的话需要返回去多看几遍哈）。

假设我们现在要计算两个8位二进制数的差，被减数是`A₇A₆A₅A₄A₃A₂A₁A₀`，减数是`B₇B₆B₅B₄B₃B₂B₁B₀`，其中`An`和`Bn`（n是`0~7`之间的整数）分别代表一个二进制位。那么将这个减法转换为加法的关键就是求得减数的补数之后再和被减数相加，求一个二进制数补数的过程我们上边都已经说过了，就是：`取反加1`。“取反”我们已经说过了，就是简单将每一个二进制位作为输入信号通过一个反相器罢了，但是该如何实现“加1”呢？哈哈，还记得我们前边介绍`n位加法器`的时候留了一个悬念么，就是在处理`A₀`和`B₀`这两个二进制位加法的时候采用的是全加器，而不是半加器（只不过该全加器的进位输入`Cin`的值为0）。此时我们只要让8位加法器的进位输入`Cin`的值设置为1，即可实现“加1”效果，如下图所示：

![image_1eq9m9i7q187u1oiuqor1r2egb92a.png-41.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d06b7897f60c4e898b0746dad585998a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1176&h=517&s=42278&e=png&b=ffffff)

这样得到的`S₇S₆S₅S₄S₃S₂S₁S₀`就是最后的差。

上图的电路还是不太方便，如果我们之后想计算`A₇A₆A₅A₄A₃A₂A₁A₀`与`B₇B₆B₅B₄B₃B₂B₁B₀`的和，那我们还需要手动地把对`B₇B₆B₅B₄B₃B₂B₁B₀`做取反操作的反相器再都去掉，然后把进位输入`Cin`的值调整为`0`。把反相器装上去再拆下来太费劲了，我们期望：

*   当进位输入`Cin`的值为`0`时，此时表示想对`A₇A₆A₅A₄A₃A₂A₁A₀`与`B₇B₆B₅B₄B₃B₂B₁B₀`做加法运算，并不打算对`B₇B₆B₅B₄B₃B₂B₁B₀`做取反操作。
    
*   当进位输入`Cin`的值为`1`时，此时表示想对`A₇A₆A₅A₄A₃A₂A₁A₀`与`B₇B₆B₅B₄B₃B₂B₁B₀`做减法运算，需要对`B₇B₆B₅B₄B₃B₂B₁B₀`做取反操作。
    

也就是说针对`B₇B₆B₅B₄B₃B₂B₁B₀`中的任意一个位`Bn`，我们都期望：

*   当进位输入`Cin`的值为`0`时，`Bn`的值保持不变。
    
*   当进位输入`Cin`的值为`1`时，对`Bn`的值做取反操作。
    

我们可以画出下边的表格来描述这个过程：

![image_1eq9ma6il1sm61lm61tib1ltu1qr52n.png-24.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c37cd2d0a9bd40979d3926cb6d345c77~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=373&h=218&s=25279&e=png&b=fefefe)

额，这不就是`异或门`的真值表嘛！也就是说只要我们将进位输入`Cin`和`Bn`作为异或门的两个输入信号，就可以得到期望的结果。说干就干，继续改进一下`n位加法器`，使它既支持加法也支持减法：

![image_1eq9mb4325enfod1ason581rr434.png-37.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/332054ec14c74e95897b9513edc72fea~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1138&h=515&s=37967&e=png&b=ffffff)

这个电路可就便捷多了，当我们想求`A₇A₆A₅A₄A₃A₂A₁A₀`与`B₇B₆B₅B₄B₃B₂B₁B₀`的和的时候，只需要将`Cin`设置为`0`，当我们想求`A₇A₆A₅A₄A₃A₂A₁A₀`与`B₇B₆B₅B₄B₃B₂B₁B₀`的差的时候，只需要将`Cin`设置为`1`，美滋滋～

使用无符号数运算时的注意事项
--------------

截止到目前为止我们介绍过的二进制数其实都是若干个0或者1这两个符号之间的任意组合，符号所在位置的不同，所代表的数值大小也不同，每个位置的符号表示的数值为该符号的字面量乘以该位置的权重（2的整数次幂），整个组合表示的数值为所有位置的符号代表的值加起来的总和。如果大家仔细琢磨的话，就会发现按照这样解释符号组合代表的数值的方式是无法表示负数的，所以我们也把通过这样的方式来解释数值的符号组合称为`无符号数`。

两个`无符号数`在运算之后得到的结果自然也将其理解为`无符号数`。这样就产生了一个问题，如果两个无符号数相减，在减数比被减数大的时候理论上应该产生负数，可是现在我们无法使用`无符号数`表示负数，这种情况就比较尴尬。比方说我们想计算`10010001₂`（145₁₀）和`11010111₂`（215₁₀）的差，如果直接将它们俩放到改进后的`8位加法器`上去运算，将进位输入`Cin`调节为`1`后得到的运算结果是`10111010`（186₁₀），这显然不是我们想要的结果。

结合前边关于溢出现象的叙述，我们需要注意：在使用n个二进制位表示无符号数时，多个无符号数参与算术运算时的运算结果不应该小于0，也不应该大于`2n-1`，否则得到的结果将不是我们想要的。