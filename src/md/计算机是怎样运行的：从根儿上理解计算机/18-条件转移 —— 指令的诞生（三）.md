第19章、指令的诞生（三）
=============

标签： 计算机是怎样运行的

* * *

跳转指令
----

我们原来只是想解答狗哥`74+29+32+20`的这个问题，可一顿操作猛如虎，把狗哥看的一愣一愣的。现在狗哥这个门外汉也知道了：只要我们在`指令RAM`和`数据RAM`中输入对应的指令和数据，我们设计的那个电路就可以自动地将结果算出来，并将结果写入`数据RAM`的指定地址处。狗哥对我们发明的这个设备很感兴趣，他在`指令RAM`和`数据RAM`中填充了如下图所示的数据：

![image_1et0u9th31u9o1c201hju1rl01he89.png-29.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77013c33feed4b06802022a7191684ea~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=499&h=613&s=30229&e=png&b=fefefe)

很显然，他想计算下边这个式子的结果：

    5 + 3 + 11 + 8 + 3 + 22 + 8 + 7 + 34
    

现在狗哥突发奇想说：我能不能只算`数据RAM`中地址为0、1、8对应数据的加和，而忽略其他地址对应的数据呢？

小孩子说：当然可以了，你重新把`指令RAM`和`数据RAM`中的数据填充一遍，填成下边这样子不就好了。

![image_1et1954i0o4ttvds3aqka18hom.png-16.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e4509d72d01442dbe391d9b63bb3224~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=488&h=316&s=17154&e=png&b=fefefe)

狗哥说：要重新填好多处的数据哦，有没有什么更简单的解决方案哦？

现在我们就继续替狗哥分析一下是不是有啥更简单的解决方案。在回顾一下狗哥的需求，他其实是想在执行完地址为1的指令之后，跳过地址为2、3、4、5、6、7的这几条指令，直接执行地址为8的指令。如下图所示。

![image_1et1akg6l1glai3f1bpv1obc1mob1t.png-46.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69b09b890b904e7c83baa5d796096c0a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=714&h=603&s=47542&e=png&b=fefefe)

我们先回顾一下当前设备是如何执行的：程序计数器的输出表示当前`指令RAM`和`数据RAM`的地址，每当时钟信号上升沿到达后，程序计数器的值就会递增1，所以在下一时钟周期去执行下一条指令。如果想直接执行某条指令的话，我们直接将程序计数器的值设置为该指令对应的地址不就好了么。我们可以这样改造电路图：

![image_1fk6chjsqdfn1q2u1oda1cnoeoj9.png-54kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5560e2f55b094c11b61fa3b500b7dc8f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1136&h=735&s=55305&e=png&b=fefefe)

如图所示，我们在程序计数器前放置了一个2-1选择器，我们把这个2-1选择器的控制信号称为`PC_SEL`，那么：

*   当PC\_SEL=0时，程序计数器的输入就等于当前程序计数器的输出加1，我们可以简称为`PC+1`。这也是之前我们一直在用的逻辑，即下一时钟周期执行的指令地址比当前正在执行的指令地址大1。
*   当PC\_SEL=1时，程序计数器的输入就是`数据RAM`的输出（当前数据RAM的输出共有8位，这里选取低6位作为程序计数器的输入）。

现在指令输出的8个二进制位中只使用了6个，我们可以再找一个二进制位，比方说编号为6的二进制位表示这个PC\_SEL信号，如下图所示：

![image_1et1c5iav10p5147p1irv16711d8n37.png-48.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/254ff28450734418afd6168d78828896~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=911&h=440&s=49243&e=png&b=fefcfc)

然后我们可以新引入一个指令`jmp`，当执行该指令时，让PC\_SEL=1，在执行其他指令时，让PC\_SEL=0。这样当执行到jmp指令时，就可以跳转到指定的地址去执行指令。

这样的话，现有的指令以及其对应的二进制形式就如下表所示：

指令的二进制形式

操作类型

简称

`0010100`

加法

add

`0010101`

减法

sub

`0010110`

按位与

and

`0010111`

按位或

or

`XXXX0XX`

停止执行

halt

 

`0X011XX`

向数据RAM中写入数据

store

 

`0110100`

将RAM中的数据加载到累加器中

load

 

`1X001XX`

跳转到指定地址执行指令

jmp

 

那么解决狗哥之前的需求就非常简单了，只需要将原先`指令RAM`地址为2处的指令修改为`jmp`，将原先`数据RAM`地址为2处的数据修改为`8`（也就是我们需要跳转到的地址），`指令RAM`和`数据RAM`的数据填充情况就如下所示：

![image_1et1dqlkn15nharruj19t4h3m.png-45.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e50d4fad9e40436bba414ad8b45c93f6~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=691&h=586&s=46808&e=png&b=fdfdfd)

那么，在第2周期时，`指令RAM`输出jmp指令，PC\_SEL信号变为逻辑1，程序计数器的输入为`数据RAM`的输出：8。那么在第3周期时钟信号上升沿到来后，程序计数器的输出就变为了8，也就意味着第3周期在执行地址为8处的指令！

条件跳转指令
------

jmp指令属于`无条件跳转指令`，也就是说只要执行到jmp指令，在下一时钟周期就会跳转到jmp指令指定的地址去执行，不需要任何条件。可更多时候我们需要的是`有条件跳转指令`，简称`条件跳转指令`。也就是在符合某个条件的时候才会跳转到指定的地址去执行，否则不跳转。当然，我们这里所说的“条件”是什么呢？我们先看几个现实世界中的两个根据不同条件做不同操作的场景：

*   如果你的某科成绩大于60分，那么这科成绩才算及格，否则不及格。
    
*   如果你的年均纯收入不小于4000，那你就脱贫了，否则你就是贫困人口。
    

很显然，生活中最常出现的“条件”就是比较两个数的大小，根据比较结果来做不同的操作。再回到我们这里，在执行指令跳转操作前也可以判断一下两个数的比较结果是否符合预期，如果符合再跳转，否则不跳转。假设我们有两个数a和b，那么可以有多种比较条件：

*   条件一： 如果a等于b，就跳转，否则不跳转。
*   条件二： 如果a不等于b，就跳转，否则不跳转。
*   条件三： 如果a小于b，就跳转，否则不跳转。
*   条件四： 如果a小于或等于b，就跳转，否则不跳转。
*   条件五： 如果a大于b，就跳转，否则不跳转。、
*   条件六： 如果a大于或等于b，就跳转，否则不跳转。

我们可以换一种思路去理解比较两个数大小的过程，比较a和b的大小其实可以相当于去计算a-b的差，那么：

*   如果差为0，意味着a和b相等
*   如果差为正数，意味着a大于b
*   如果差为负数，意味着a小于b

这就意味着如果我们想根据某两个数的比较结果去作为是否进行跳转的依据的话，只需要先将这两个数做减法运算，然后再判断差是0、正数或者负数就好了。不过出于简化的目的考虑，我们接下来只准备实现在两个数相等的时候才进行跳转的指令。那么在ALU做运算的时候，就需要知道运算结果是否为0，那么可以这样改造一下ALU：

![image_1et4dlbcosoniu11ue3n81v8cm.png-53.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b9ba25b90d747acadd3c86f9752a5b1~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=951&h=640&s=54581&e=png&b=ffffff)

如图所示，我们引入了一个比较器，比较器的一个输入恒为0，另一个输入为ALU的运算结果，我们就可以通过比较器的输出`ZF`(Zero Flag的缩写）来判断运算结果是否为0：

*   如果ZF=0，那意味着运算结果不为0。
*   如果ZF=1，那意味着运算结果为0。

赶紧把电路细节封装到黑盒子里：

![image_1et4e2bee1l85n9212pn1ta0jhq13.png-16kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c294d1893a7448ab4cd6729f128ae02~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=543&h=284&s=16410&e=png&b=ffffff)

接下来就可以根据ALU的ZF输出来判断到底是不是要执行跳转了。我们可以引入一个名为`je`（jump equal的简称）的指令，当执行这个指令时，如果上一次算术/逻辑运算的结果为0，那么就跳转到指定地址执行指令，否则就不跳转。

之前我们将指令编号为6的二进制位作为程序计数器前的2-1选择器的控制信号PC\_SEL，当执行jmp指令时，PC\_SEL信号为逻辑1，从而可以让程序计数器的输入变为指定的地址，那么在下一时钟周期的时钟信号上升沿到来后，程序计数器输出我们指定的地址，从而让机器执行指定地址处的指令。

现在引入了je指令，这个指令也可能会修改PC\_SEL信号，也就是说PC\_SEL信号由jmp指令和je指令共同决定，所以我们不能单纯的将指令编号为6的二进制位作为PC\_SEL信号了。那么我们可以新定义两个信号JMP\_NO\_COND和JMP\_COND信号，并且让：

*   指令中编号为6的二进制位代表JMP\_NO\_COND信号（COND是CONDITION的缩写）
*   指令中编号为7的二进制位代表JMP\_COND信号。

那么指令的各个二进制位表示的含义就变成了下边这样：

![image_1et454kqv1uefduf1mdb17q11dhu9.png-52.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6228c80a1d9f433d84eb240a953555f9~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1027&h=453&s=53878&e=png&b=fefcfc)

这样的话，现有的指令以及其对应的二进制形式就如下表所示：

指令的二进制形式

操作类型

简称

`00010100`

加法

add

`00010101`

减法

sub

`00010110`

按位与

and

`00010111`

按位或

or

`XXXXX0XX`

停止执行

halt

 

`00X011XX`

向数据RAM中写入数据

store

 

`00110100`

将RAM中的数据加载到累加器中

load

 

`01X001XX`

跳转到指定地址执行指令

jmp

 

`10X001XX`

跳转到指定地址执行指令

je

 

也就是说在执行jmp指令时，JMP\_NO\_COND=1、JMP\_COND=0。 在执行je指令时，JMP\_NO\_COND=0、JMP\_COND=1。

那么：

*   当执行jmp指令时，JMP\_NO\_COND=1，PC\_SEL信号肯定需要被设置为逻辑1
*   当执行je指令时，JMP\_COND=1，只有当ZF=1时，PC\_SEL才被设置为逻辑1

很显然下边的电路图满足上述关系：

![image_1etludhnp1jav1ej3o8918ci1ees9.png-15.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9afd1c5706b04759b2a19bacdd00eecd~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=740&h=187&s=16214&e=png&b=fefefe)

好了，准备工作都做完了，接下来是时候把上边这些东西应用到整体的电路图中：

![image_1fk6cik561ggu1jn7138m8mdrqlm.png-78.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa87bd5605f74360b2d51b2cf2bd0e8c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1254&h=776&s=80005&e=png&b=fefefe)

上图中有一点需要注意，我们先得在一个时钟周期内执行sub指令来计算两个数的差，在下一时钟周期才可以执行je指令来根据减法的结果来决定是不是要跳转到指定地址。那么在执行sub指令的时钟周期中，ALU输出的ZF信号需要在下一个时钟周期中才有用，所以我们引入了一个称为ZF寄存器的器件来存储执行sub指令时产生的ZF信号。

现在如果我们向`指令RAM`和`数据RAM`中填入如下图所示的数据：

![image_1et4i74af1amq9941v3o171k1ohq9.png-45.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a14962c09094674ab552736a3d6282a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=686&h=589&s=46988&e=png&b=fefefe)

由于3-5≠0（地址为1处的指令就是计算3-5的值），所以地址为2的je指令执行完后，并不会跳转到地址为8的指令，而是继续执行地址为3的指令。如果我们把`数据RAM`中地址为1处的数据换成5，如下图所示：

![image_1et4hkr0010n6130h1uagram1gsa2n.png-46.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a686167329e6420d8a931ba4f329874d~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=693&h=612&s=47294&e=png&b=fdfdfd)

由于5-5=0，所以地址为2的je指令执行完后，会跳转到地址为8的指令。

> 小贴士：  
>   
> 在我们目前的设计中，在执行je指令时，只是看上一次ALU的运算结果是不是0，而不管ALU上一次做的什么运算，所以目前发生跳转的“条件”就不局限于比较两个数是否相等了，不管是加法运算、减法运算、按位与运算还是按位或运算，只要它们的运算结果为0，那么接着执行je指令时都会发生跳转。