第11章、负数的表示
==========

标签： 计算机是怎样运行的

* * *

有符号数
----

其实由若干个0和1组成的符号组合仅仅是个符号组合，只不过我们可以人为地赋予它代表某个数值的含义罢了。如果我们规定使用4个二进制位表示数字，那么就一共可以形成16种符号组合，如果我们把这些符号组合当作`无符号数`来理解，我们就可以把符号组合`0000₂`映射到数值`0`，`0001₂`映射到数值`1`，`0010₂`映射到数值`2`，`0011₂`映射到数值`3`，以此类推，`1110₂`映射到数值`14`，`1111₂`映射到数值`15`，我们把这些符号组合映射到的数值也画到表盘上：

![image_1dp2lc1bsd3i47k3q61e5umen9.png-55.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51b669a3bb334830a6ddb2539d8d2240~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=547&h=514&s=57095&e=png&b=ffffff)

不过`无符号数`中不能表示负数，那负数在计算机中该怎么表示呢？最自然的想法当然是在`无符号数`前边加个负号。比方现在规定使用4个二进制位表示数字，`0101₂`表示的数值是`5`，如果我们想表示`-5`的话直接在`0101₂`前边加个负号不就好了，就像这样：`-0101₂`。很遗憾，这是人类的想法，这样子表示的话会引入除0、1之外的新的符号：`-`，我们已经用高低电压信号来表示1和0，难不成还要引入第三种信号来表示负号？不好不好，继续想别的辙～

视角回到补数上来，我们说在使用n个二进制位表示数字时，假设yyy、y^\\hat{y}y^​是两个使用n个二进制位表示的数字，它们互为补数，那么我们有：

y+y^\=2ny + \\hat{y} = 2^ny+y^​\=2n

2n2^n2n用二进制数表示的话其实就是`1`后边跟上`n`个`0`，也就是需要`n+1`个二进制位来表示这个数字，而我们规定了只使用n个二进制位来表示数字，所以相当于需要把最左边的1舍弃掉，结果和`0`相同。也就是说下边的式子在使用n个二进制位来表示数字时是成立的：

y+y^\=0y + \\hat{y} = 0y+y^​\=0

两个数互为相反数的时候加和结果为0，这也就意味着我们其实可以直接使用一个数的补数来表示与它对应的相反数。比如我们现在使用4个二进制位的符号组合来表示数字，如果说我们给某个数加上`0001₂`，相当于在表盘上顺时针转1个刻度，其实也相当于逆时针转15个刻度。我们前边说顺时针转相当于做加法，逆时针转相当于做减法，也就是说`0001₂`其实可以表示正数`1`，也可以表示负数`-15`。同理，我们也可以让`0010₂`表示`-14`、`0011₂`表示`-13`、`0010₂`表示`-12`...`1110₂`表示`-2`、`1111₂`表示`-1`，现在我们就可以改进一下符号组合和数值之间的映射关系了，如图所示：

![image_1dp498lub1uhamin9l2h75go79.png-46.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfe89e4310eb49c2acb6c80afe0deedf~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=526&h=421&s=47186&e=png&b=fefefe)

如果我们采用这样子的映射关系来解释符号组合的数值，那么对于下边的这个式子：

    0101₂ + 1110₂ = 0011₂（省略掉了进位）
    

就可以解释成：先将指针从`0000₂`的位置逆时针转动11个刻度，再逆时针转动2个刻度，就到达了`0011₂`刻度（`0011₂`表示负数`-13`）。

采用这样映射关系当然可以，不过这样的话4个二进制位能表示的数值范围就成了十进制的`-15～0`，在做运算的时候得保证结果的数值也在这个范围之内。这样子有个问题，就是不能表示正数啦！我们还是希望能这些符号组合能表示一部分正数，也能表示一部分负数，这样子才最符合日常所需。此时我们可以把这些符号组合分为两组：

*   `0000₂～0111₂`这8个符号组合为一组，它们代表非负数，它们代表的数值大小与对应的无符号数相同。这一组的首个二进制位都是`0`。
    
*   `1000₂～1111₂`这8个符号组合为一组，它们代表负数，它们的绝对值和它们对应的补数相同。这一组的首个二进制位都是`1`。
    

这样描述不太直观，我们把它们画在表盘里看一下：

![image_1dp4t9o871nv31a0i19u1jspdv51j.png-54.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c04e764ee94fbebf15c65b6b83cc66~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=514&h=500&s=56147&e=png&b=fefefe)

如果我们采用这样子的映射关系来解释符号组合的数值，那么对于下边的这个式子：

    0101₂ + 1110₂ = 0011₂（省略掉了进位）
    

就可以解释成：先将指针从`0000₂`的位置顺时针转动5个刻度，再逆时针转动2个刻度，就到达了`0011₂`刻度（`0011₂`表示正数数`3`）。

这样当首个二进制位为0的话，我们就把该数当作非负数对待；首个二进制位为1的话，我们就把该数当作负数对待。因为首个二进制位可以区分这个数是正数还是负数，所以该二进制位也可以被称为`符号位`。以这样的方式解释某个符号组合的数值时有了正负数之分，所以我们也把以这样方式解释数值的符号组合称之为`有符号数`。采用上边映射方案的情况下，使用4个二进制位表示的`有符号数`表示的数值大小就成了`-8～7`（-2³～2³-1）。

当然，对于同一个符号组合，比方说`1111₂`，你说它到底是表示无符号数中的`15`呢，还是表示有符号数中的`-1`呢？这个取决于我们人类怎么看它，我们说`1111₂`代表无符号数，它代表的数值就是`15`，我们说`1111₂`代表有符号数，它代表的数值就是`-1`（人类就是这么霸气，保留最终解释权）。

> 小贴士：  
>   
> 大家也看出来了，对于同样的一个表盘上使用4个二进制位表示的的16个符号组合，我们可以把它们映射为人们常见的无符号数，也可以映射为一个绝对值与它补数相同的负数。不论怎么映射，之前改进过的加、减通用的n位加法器都是适用的。

更一般地，对于使用n个二进制位表示的有符号数，它代表的数值大小需要按照下边的规则去判断：

*   如果符号位的字面量为`0`，那么我们就把它当作是一个非负数。
    
*   如果符号位的字面量为`1`，那么我们就把它当作是一个负数，它的绝对值和它对应的补数相同。
    

特别要注意在使用这些有符号数进行算术运算的时候，得到的结果千万不可以超出取值范围，比方说我们在使用4个二进制位表示数字时，想以有符号数的形式计算数值`3`和`5`的和，数值`3`和`5`在有符号数中的形式分别是`0011₂`和`0101₂`，那么我们可以这样计算：

    0011₂ + 0101₂ = 1000₂
    

得到的结果`1000₂`代表的有符号数数值就是`-8`，两个正数的和竟然是一个负数，这显然是不对的。原因就是使用4个二进制位表示数字时，能表示的有符号数的取值范围是`-8～7`，无法表示正数`8`，这一点大家要格外注意，很容易犯错滴～

扩展数字位数
------

现在若干个二进制位既能表示无符号数，也能表示有符号数。当表示数字时使用的二进制位个数不同时，能表示的数值范围也是不同的，比方说：

二进制位个数

十进制形式的无符号数取值范围

十进制形式的有符号数取值范围

1

0～1 (0～2¹-1)

\-1～0 (-2⁰～2⁰-1)

\-1～0

2

0～3 (0～2²-1)

\-2～1 (-2¹～2¹-1)

3

0～7 (0～2³-1)

\-4～3 (-2²～2²-1)

4

0～15 (0～2⁴-1)

\-8～7 (-2³～2³-1)

8

0～255 (0～2⁸-1)

\-128～127 (-2⁷～2⁷-1)

16

0～65535 (0～2¹⁶-1)

\-32768～32767 (-2¹⁵～2¹⁵-1)

32

0～4294967295 (0～2³²-1)

\-2147483648～2147483647 (-2³¹～2³¹-1)

64

0～18446744073709551615 (0～264\-1)

\-9223372036854775808～9223372036854775807 (-263～263\-1)

一般地，对于使用n个二进制位表示的数字来说，无符号数的取值范围就是：`0～2n-1`，有符号数的取值范围就是：`-2n-1～2n-1-1`。

很显然，使用越少的二进制位来表示数字时，能表示的数值范围就越小；使用越多的二进制位来表示数字时，能表示的数值范围就越大。在我们使用较多的二进制位来表示某个数值时，可能无法使用更少的二进制位来表示这个数值；相反的话，在我们使用较少的二进制位来表示某个数值时，那么一定能使用更多的二进制位来表示这个数值。

如果我们想将使用较少的二进制位表示的无符号数扩展成使用更多二进制位表示的无符号数，只需要在开头补更多的0，比方说使用4个二进制位表示的无符号数`1101₂`（13₁₀），如果我们想：

*   把它扩展成使用5个二进制位表示的无符号数，简单地在开头补1个0就好，变成这样：`01101₂`。
    
*   把它扩展成使用6个二进制位表示的无符号数，简单地在开头补2个0就好，变成这样：`001101₂`。
    
*   把它扩展成使用7个二进制位表示的无符号数，简单地在开头补3个0就好，变成这样：`0001101₂`。
    
*   ...
    
*   把它扩展成使用n(n>4)个二进制位表示的无符号数，简单地在开头补`n-4`个0就好。
    

我们可以把这种扩展方式称之为`零扩展`，在原无符号数开头简单地补0，并不会改变它代表数值的大小。

如果某个有符号数表示的数值是一个非负数，比方说使用4个二进制位表示的有符号数`0010₂`，它的符号位为`0`，肯定表示一个非负数，那么在我们扩展使用的二进制位个数时，只需要简单的在该数前边补0就好。比方说现在将其扩展为使用8个二进制位表示的有符号数，直接在原数前边补4个`0`变为`00000010₂`就好～

如果某个有符号数表示的数值是一个负数，那就不能简单的在原数前边补0了。比如我们使用4个二进制位表示有符号数`1010₂`，它的符号位为`1`，说明它代表的是一个负数，`1010₂`的补数是`0110₂`，而`0110₂`代表十进制的`6`，所以`1010₂`就代表十进制中的`-6`。如果我们想使用5个二进制位表示有符号数`1010₂`（-6₁₀），要是直接在开头补0的话就变成了：`01010₂`，因为对于使用5个二进制位表示的这个有符号数来说，它的符号位是`0`，所以`01010₂`实际代表正数`10₁₀`，这可不是我们期望的。

下边就正式推导一下如何扩展表示负数的有符号数使用的二进制位个数。假设现在有一个包含4个二进制位的有符号数：`1XXX₂`（其中`X`代表0或1均可），很显然`1XXX₂`的符号位为1，那么`1XXX₂`表示的就是一个负数。我们假设它的补数为`0YYY₂`（其中Y也可以代表0或1），那么我们就有：

    1XXX₂ + 0YYY₂ = 10000₂
    

如果我们想将`1XXX₂`扩展为使用5个二进制位表示的有符号数，那就相当于求`0YYY₂`在使用5个二进制位表示的时候，对应的补数是什么。`0YYY₂`是一个非负数，把它扩展为5个二进制位便很容易，直接在开头补0即可：`00YYY₂`，那么现在的问题就是在求`00YYY₂`对应的补数是什么。

我们现在有：

    01XXX₂ + 00YYY₂ = 10000₂
    

在上边的等式两边都加上`10000₂`，就变成了：

    01XXX₂ + 00YYY₂ + 10000₂ = 10000₂ + 10000₂ =  100000₂
    

也就是：

    01XXX₂ + 00YYY₂ + 10000₂ = 100000₂
    

先计算`01XXX₂`与`10000₂`的和：

    (01XXX₂ + 10000₂) + 00YYY₂ = 100000₂
    

也就是：

    11XXX₂ + 00YYY₂ = 100000₂
    

很显然，在使用5个二进制位表示数字时，`00YYY₂`的补数就是`11XXX₂`，而`11XXX₂`正是在原有符号数`1XXX₂`前边补一个1得到的。

类似的，如果我们想把使用4个二进制位表示的数字`1XXX₂`扩展到使用8个二进制位来表示，那意思就是在求，`00000YYY₂`的补数是什么，因为已经有：

    00001XXX₂ + 00000YYY₂ = 00010000₂
    

在上边的等式两边都加上`11110000₂`，就变成了：

    00001XXX₂ + 00000YYY₂ + 11110000₂ = 00010000₂ + 11110000₂ = 100000000₂
    

也就是：

    00001XXX₂ + 00000YYY₂ + 11110000₂  = 100000000₂
    

先计算`00001XXX₂`与`11110000₂`的和：

    (00001XXX₂ + 11110000₂) + 00000YYY₂ = 100000000₂
    

也就是：

    11111XXX₂ + 00000YYY₂ = 100000000₂
    

也就是说我们直接在原有符号数`1XXX₂`前边添加4个1得到的结果`11111XXX₂`，`11111XXX₂`就是有符号数`1XXX₂`扩展为使用8个二进制位表示的形式。总而言之，当原有符号数的符号位为1时，如果要扩展表示该数的二进制位数，直接在原数开头补相应数量个`1`就好（扩展多少位，就补多少个1）。

也就是说，扩展表示有符号数的二进制位个数的时候，需要根据原有符号数的符号位来做不同的操作：

*   在原有符号数的符号位为0的时候，可以采用直接在原数前边补0的方式扩展；
*   在原有符号数的符号位为1的时候，可以采用直接在原数前边补1的方式扩展。

我们把这种扩展时依赖符号位的值的扩展方式称之为`符号扩展`。

最后再总结一下：无符号数扩展时采用零扩展，有符号数扩展时采用符号扩展。（虽然过程比较曲折，但是结论还是很美好的嘛~）