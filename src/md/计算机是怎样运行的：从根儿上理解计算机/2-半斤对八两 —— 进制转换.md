第3章、进制转换
========

标签： 计算机是怎样运行的

* * *

进制之间的转换
-------

我们在上一章介绍了如何将八进制、十六进制和二进制转为十进制的数字，但是将十进制的数字转为其他进制的数字就不是非常直观了。

### 十进制转二进制

比方说对于十进制数字`213`，如何将它转换为二进制呢，我们其实可以将`213`换一种形式表达出来：

    213 = 128 + 64 + 16 + 4 + 1
        = 1 × 2⁷ + 1 × 2⁶ + 1 × 2⁴ + 1 × 2² + 1 × 2⁰
        = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
    

二进制数字的每个位代表的数量其实是该位置符号的字面量乘以2的某个整数次幂，我们现在把十进制数字写成了使用`0`或`1`与一些2的整数次幂相乘之后再求和的形式，就可以直接把每个与2的整数次幂相乘的符号拿下来，组合到一起就可以得到十进制数字`213`转换为二进制数字的形式，如下图所示：

![image_1ep5lvacsl6eg906c31mhkhua1g.png-49.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8727ccb1f68a4e6eafc302f9a2a28565~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1279&h=299&s=50656&e=png&b=ffffff)

也就是说十进制数字`213`对应的二进制数就是`11010101`，下边详细解释一下该二进制数中每个二进制位代表的数值大小：

![image_1ep5lvqd31ddd12so1fab1vl018q01t.png-33.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b37f65eb84284903b13b3a889e51ec19~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=660&h=667&s=34338&e=png&b=ffffff)

不过有的小伙伴心中肯定会说：我们又不是机器，怎么能一下子将一个十进制数字转换成使用`0`或`1`与一些2的整数次幂相乘之后再求和的形式呢？哈哈，下边我们介绍几种完成这种转换的方式：

*   方式一：投机取巧法：
    
    首先我们需要死记硬背一些2的整数次幂对应的二进制和十进制形式：
    
    2的整数次幂
    
    对应的二进制
    
    对应的十进制
    
    2⁰
    
    1
    
    1
    
    2¹
    
    10
    
    2
    
    2²
    
    100
    
    4
    
    2³
    
    1000
    
    8
    
    2⁴
    
    10000
    
    16
    
    2⁵
    
    100000
    
    32
    
    2⁶
    
    1000000
    
    64
    
    2⁷
    
    10000000
    
    128
    
    2⁸
    
    100000000
    
    256
    
    2⁹
    
    1000000000
    
    512
    
    2¹⁰
    
    10000000000
    
    1024
    
    2¹¹
    
    100000000000
    
    2048
    
    2¹²
    
    1000000000000
    
    4096
    
    ...
    
    ...
    
    ...
    
    现在我们来看十进制数字`213`，该十进制数字是介于`128`（也就是`2⁷`，`2⁷`需要使用8个二进制位来表示）和`256`（也就是`2⁸`，`2⁸`需要使用9个二进制位来表示）之间的，然后：
    
    *   首先运算`213 ÷ 128`，得到的商是`1`，余数是`85`，也就是说`213`可以写成这样的形式：
        
            213 = 1 × 128 + 85
                = 1 × 2⁷ + 85
            
        
    *   继续运算`85 ÷ 64`，得到的商是`1`，余数是`21`，也就是说`213`可以写成这样的形式：
        
            213 = 1 × 2⁷ + 1 × 64 + 21
                = 1 × 2⁷ + 1 × 2⁶ + 21
            
        
    *   继续运算`21 ÷ 32`，得到的商是`0`，余数是`21`，也就是说`213`可以写成这样的形式：
        
            213 = 1 × 2⁷ + 1 × 2⁶ + 0 × 32 + 21
                = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 21
            
        
    *   继续运算`21 ÷ 16`，得到的商是`1`，余数是`5`，也就是说`213`可以写成这样的形式：
        
            213 = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 16 + 5
                = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 5
            
        
    *   继续运算`5 ÷ 8`，得到的商是`0`，余数是`5`，也就是说`213`可以写成这样的形式：
        
            213 = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 8 + 5
                = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 5
            
        
    *   继续运算`5 ÷ 4`，得到的商是`1`，余数是`1`，也就是说`213`可以写成这样的形式：
        
            213 = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 4 + 1
                = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 1
            
        
    *   继续运算`1 ÷ 2`，得到的商是`0`，余数是`1`，也就是说`213`可以写成这样的形式：
        
            213 = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2 + 1
                = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1
            
        
    *   继续运算`1 ÷ 1`，得到的商是`1`，余数是`0`，也就是说`213`可以写成这样的形式：
        
            213 = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 1
                = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
            
        
    
    这样我们就把十进制数字`213`写成了使用`0`或`1`与一些2的整数次幂相乘之后再求和的形式，下边不就可以直接将其转为`11010101`的二进制形式了么。是不是贼简单？
    
*   方式二：“除2取余，逆序排列”法：
    
    有的时候某个十进制数字特别大，我们也无法估算出与它最接近的2的整数次幂是哪个，这时候该怎么将十进制数字转换为二进制数字呢？有一个现成的称之为“除2取余，逆序排列”的算法可以让我们很机械的完成这个转换，完整的算法表述如下：
    
    > 用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的权重低的位，后得到的余数作为二进制数的权重高的位，依次排列起来。
    
    我们还以十进制数字`213`为例来看看这个过程：
    
    ![image_1ep5m0e2q6ff1a7p1e0v31s1n3f2a.png-42.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a60620746acc47f6b3966f7341e814ea~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=618&h=503&s=43213&e=png&b=ffffff)
    
    将上述过程中得到的余数按照逆序排列起来，就得到了十进制数字`213`对应的二进制数字：`11010101`。
    
    有同学看完一脸懵逼，这个过程是很好懂，可是为啥呢？为啥将得到的余数逆序排列起来就得到了十进制数字对应的二进制数字了呢？我们一步一步分析一下：
    
    *   将十进制数字`213`除以2，得到商为`106`，余数为`1`，也就是说：
        
            213 = 106 × 2 + 1
                = 106 × 2¹ + 1 × 2⁰
            
        
    *   继续运算`106`除以2，得到商为`53`，余数为`0`，也就是说：
        
            213 = (53 × 2 + 0) × 2¹ + 1 × 2⁰
                = 53 × 2² + 0 × 2¹ + 1 × 2⁰
            
        
    *   继续运算`53`除以2，得到商为`26`，余数为`1`，也就是说：
        
            213 = (26 × 2 + 1) × 2² + 0 × 2¹ + 1 × 2⁰
                = 26 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
            
        
    *   继续运算`26`除以2，得到商为`13`，余数为`0`，也就是说：
        
            213 = (13 × 2 + 0) × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
                = 13 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
            
        
    *   继续运算`13`除以2，得到商为`6`，余数为`1`，也就是说：
        
            213 = (6 × 2 + 1) × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
                = 6 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
            
        
    *   继续运算`6`除以2，得到商为`3`，余数为`0`，也就是说：
        
            213 = (3 × 2 + 0) × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
                = 3 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
            
        
    *   继续运算`3`除以2，得到商为`1`，余数为`1`，也就是说：
        
            213 = (1 × 2 + 1) × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
                = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
            
        
    *   继续运算`1`除以2，得到商为`0`，余数为`1`，也就是说：
        
            213 = (0 × 2 + 1) × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
                = 1 × 2⁷ + 1 × 2⁶ + 0 × 2⁵ + 1 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 1 × 2⁰
            
        
    
    从这个过程中我们可以看出来，之所以我们想要“除2取余”，其实本质上还是想把一个十进制整数写成使用`0`或`1`与一些2的整数次幂相乘之后再求和的形式，在这个过程中，先得到的余数其实是权重比较低的位，后得到的余数是权重比较高的位。
    
*   方式三：上网找一个进制转换程序，然后输入十进制数字，让程序为我们计算对应的二进制是啥就好了～
    
    > 小贴士：虽然方式三很白痴，但是这却是我最经常用的方式哈哈哈～
    

### 十进制转八进制或者十六进制

了解了十进制数字转换为二进制数字的原理，十进制数字转换为八进制数字或者十六进制数字的方式也都是依葫芦画瓢：

*   方式一：投机取巧法：
    
    记住一些八进制或者十六进制数字的整数次幂对应的十进制值，当我们想把十进制数字转换为八进制时，就把该十进制数字写成由`0~7`这八个符号与一些8的整数次幂相乘之后再求和的形式，当我们想把十进制数字转换为十六进制时，就把该十进制数字写成由`0~f`这十六个符号与一些16的整数次幂相乘之后再求和的形式。
    
    我们以将十进制数字`213`转换为八进制数字为例来看一下这个过程。十进制数字`213`介于512（也就是`8³`，需要使用4个八进制位来表示）和64（也就是`8²`，需要使用3个八进制位来表示）之间，然后：
    
    *   首先运算`213 ÷ 64`，得到的商是`3`，余数是`21`，也就是说`213`可以写成这样的形式：
        
            213 = 3 × 64 + 21
                = 3 × 8² + 21
            
        
    *   继续运算`21 ÷ 8`，得到的商是`2`，余数是`5`，也就是说`213`可以写成这样的形式：
        
            213 = 3 × 8² + 2 × 8 + 5
                = 3 × 8² + 2 × 8¹ + 5
            
        
    *   继续运算`5 ÷ 1`，得到的商是`5`，余数是`0`，也就是说`213`可以写成这样的形式：
        
            213 = 3 × 8² + 2 × 8¹ + 5 × 1
                = 3 × 8² + 2 × 8¹ + 5 × 8⁰
            
        
    
    所以十进制数字`213`转换为的八进制数字就是：`325`。同理，在计算十进制数字`213`的十六进制形式时，将上边的除数换为16就好，很容易得到转换为十六进制后的数字就是：`d5`。
    
*   方式二：“除8取余，逆序排列”法（计算十进制数字转换八进制数字时），“除16取余，逆序排列”法（计算十进制数字转换十六进制数字时）。
    
    依葫芦画瓢，就不赘述了，我已经知道有很多同学嫌我烦了～
    
*   方式三：上网找一个进制转换程序。
    

### 二进制和八进制与十六进制之间的转换

十进制以外的进制那么多，我为啥单单详细唠叨了`二进制`、`八进制`和`十六进制`呢？其实这几种进制都和计算机紧密相关的。`二进制`是整个计算机的基础，但是由于二进制只使用2个符号来表示数字，导致表示一个数字通常都需要很长的一串`0`、`1`符号，对人类特别不友好，但是十进制和二进制之间的转换对人类来说也不是特别容易，所以我们之后会经常用八进制和十六进制来表示各种数据（尤其是十六进制）。八进制和十六进制与二进制之间的转换很简单么？是的，非常简单，这得益于8和16都是2的整数次幂。假设我们有一个二进制数字，它由n个二进制位组成：

xn−1...x7x6x5x4x3x2x1x0x\_{n-1}...x\_7x\_6x\_5x\_4x\_3x\_2x\_1x\_0xn−1​...x7​x6​x5​x4​x3​x2​x1​x0​

其中，x0x\_0x0​、x1x\_1x1​、...、xn−1x\_{n-1}xn−1​这些符号代表`0`或者`1`。当n是3的倍数时，它其实可以写成下边的形式：

(xn−1×22+xn−2×21+xn−3×20)×2n−3(x\_{n-1} × 2^2 + x\_{n-2} × 2^1 + x\_{n-3} × 2^0) × 2^{n-3}(xn−1​×22+xn−2​×21+xn−3​×20)×2n−3

\+ ...

\+ (x5×22+x4×21+x3×20)×23(x\_5 × 2^2 + x\_4 × 2^1 + x\_3 × 2^0) × 2^3(x5​×22+x4​×21+x3​×20)×23

\+ (x2×22+x1×21+x0×20)×20(x\_2 × 2^2 + x\_1 × 2^1 + x\_0 × 2^0) × 2^0(x2​×22+x1​×21+x0​×20)×20

我们把其中的202^020用808^080替换掉，把232^323用818^181替换掉，...，把2n−32^{n-3}2n−3用8(n−3)/38^{(n-3)/3}8(n−3)/3替换掉，就得到了下边的结果：

(xn−1×22+xn−2×21+xn−3×20)×8(n−3)/3(x\_{n-1} × 2^2 + x\_{n-2} × 2^1 + x\_{n-3} × 2^0) × 8^{(n-3)/3}(xn−1​×22+xn−2​×21+xn−3​×20)×8(n−3)/3

\+ ...

\+ (x5×22+x4×21+x3×20)×81(x\_5 × 2^2 + x\_4 × 2^1 + x\_3 × 2^0) × 8^1(x5​×22+x4​×21+x3​×20)×81

\+ (x2×22+x1×21+x0×20)×80(x\_2 × 2^2 + x\_1 × 2^1 + x\_0 × 2^0) × 8^0(x2​×22+x1​×21+x0​×20)×80

神奇的事情发生了，我们只要把括号里的式子计算出来后依次排列组成的数字就是一个八进制的数字。其实也就是说：我们只需要将二进制数字按照从右往左的顺序每三个二进制位为一组，将其转换为一个八进制位，最后将这些八进制位连接成为八进制数字就好了（最左边那组可以不足3个二进制位）。

> 小贴士：大家做一个小思考，当n不是3的倍数时，比方说n+1或者n+2才是3的倍数时上边的式子应该改成啥样子呢？

我们举个例子，比方说二进制数字：`11010101`，我们首先将其写成下边的形式：

    11 010 101
    

然后：

*   二进制数字`11`对应着八进制位`3`
*   二进制数字`010`对应着八进制位`2`
*   二进制数字`101`对应着八进制位`5`

将这些八进制位依次连接起来就得到了二进制数字`11010101`转换为八进制后的样子：`325`，so easy！当然，如果我们已知了一个八进制数字，想将它转换为二进制形式的话，也是非常简单的。比方说有八进制数字`325`，将每个八进制位转换为3个二进制位就好了：

*   八进制位`3`对应着二进制数字`011`
*   八进制位`2`对应着二进制数字`010`
*   八进制位`5`对应着二进制数字`101`

所以八进制数字`325`转换为二进制数字的结果就是：`011010101`，首位的`0`没有意义，将它去掉就好了，所以最终结果就是：`11010101`。

对于二进制数字转为十六进制的推导过程也是类似的，只要我们只需要将二进制数字从右往左每四个比特转换为一个十六进制位，将这些十六进制位连接成为十六进制数字就好了（最左边那组可以不足4个二进制位）。

比方说二进制数字：`11010101`，我们首先将其写成下边的形式：

    1101 0101
    

然后：

*   二进制数字`1101`对应着十六进制位`d`
*   二进制数字`0101`对应着十六进制位`5`

将这些十六进制字依次连接起来就得到了二进制数字`11010101`转换为十六进制后的样子：`d5`，so easy！十六进制数字转换为二进制数字的过程也是很简单的，就是将每个十六进制字转换为4个二进制位就好了，我们就不举例子了。

另外，在很多的编程语言中会在十六进制数字前边加上`0x`或者`0X`前缀，表示接下来的数字是一个十六进制数字，比方说`0xd5`表示十六进制数字`d5`，这一点我们之后就不再反复强调了～