第24章、总线
=======

标签： 计算机是怎样运行的

* * *

多种多样的存储设备
---------

通过前面的章节我们知道，RAM负责存储指令和数据，而软件开发程序员只需要将指令和数据事先保存到RAM中，然后CPU就可以逐条执行指令了，并且还可以把程序执行结果再写回到RAM中。

RAM的全称是Random Access Memory，也就是`随机访问存储器`，其中的`随机`指的是访问任意地址对应的数据所需时间是相同的。RAM其实可以分为两种：

*   读/写存储器（Read/Write Memory，简称RWM）
    
    既支持读、也支持写的存储器。
    
*   只读存储器（Read-Only Memory，简称ROM）
    
    只支持读、不支持写的存储器。
    

出于历史的原因，导致涉及存储器的诸多概念出现了多种含义，在现实生活中，RAM和ROM的含义并不像它们的名字那样单纯。我们平时谈到`RAM`时，通常是指数据会在断电后就丢失、并支持随机访问的读/写存储器。而在谈到`ROM`时，通常是指断电后数据并不丢失、并支持随机访问的存储器。实际上随着技术的进步，后续出现的诸多ROM其实是支持写入数据的。

可以看到，其实RAM和ROM的最大区别其实是断电后数据是否丢失，所以把它们称作易失性（volatile）存储器和非易失性（nonvolatile）存储器感觉更恰当一些。

在之前的章节中我们已经介绍了一些制作RAM的方式：最开始我们使用寄存器来制作RAM，后来又介绍了使用6个晶体管存储一位数据的SRAM，还有一个晶体管加一个电容存储一位数据的DRAM。下边介绍一些ROM，但是我们并不准备唠叨它们的实现原理（因为讲清楚它们的工作原理需要很多数字电路甚至是模拟电路的知识），大家只需要大致了解一下就好了：

*   掩模ROM
    
    掩模ROM在制作完成后，该ROM中保存的数据就不会再变了，属于名副其实的只读存储器。
    
    > 小贴士：  
    >   
    > 在制作晶体管时，会首先在原材料上涂抹一层感光材料。然后制作一个板子，像剪纸一样在板子上扣出各式各样的形状（其实就是电路图对应的形状），再把刻好的板子放到原材料上，之后用光照射。这样光只能照射到板子上被扣出去的那部分，那么原材料上对应部位的感光材料就被光给照掉了，这一部分工艺称作光刻。其中的那个板子也可以被称作掩模板，而掩模ROM中的数据其实是在制作掩模板的时候就决定了，所以就被称作掩模ROM。
    
*   PROM（Programmable Read-Only Memory）
    
    可编程只读存储器。掩模ROM在出厂后数据就无法更改，但实际工作中有很多同学想自定义ROM中的内容，让厂家去定制掩模板的成本又太高，所以后续就推出了PROM。对于PROM来说，它内部包含了一些称为`熔丝`或者`反熔丝`的东西。在第一次也是最后一次修改PROM中存储的数据时，会采用破坏掉`熔丝`或者`反熔丝`来达到改变它内部数据的目的。这种破坏是不可修复的，所以我们只有一次修改它保存的数据的机会。
    
*   EPROM（Erasable Programmable Read-Only Memory）
    
    可擦除的可编程只读存储器。这是一种可用紫外线照射进行数据擦除的ROM，它可以进行多次写入，但每次重新写入数据时需要照很长时间的紫外线。
    
*   EEPROM （Electrically Erasable Programmable Read-Only Memory）
    
    电信号擦除的可编程只读存储器。向EPROM中写入数据十分不便，需要单独的紫外线光照才能清除它的数据，而EEPROM是使用提高输入电压的方式完成数据的写入，而且写入数据的时间也大大降低。
    
*   快闪存储器（Flush Memory）
    
    快闪存储器是对EPROM、EEPROM的进一步改进，使它的集成度更高，也就是在单位面积上可以存储更多的数据，而且相较于EEPROM，写入数据时可以使用更低一点儿的电压。
    

上边介绍了很多种类型的ROM，大家看过后稍微有个印象就好了。

我们所讨论的这些ROM和RAM，它们内部都是用晶体管制作的，可以被统称为`半导体存储器`。除了半导体存储器，人们使用了别的材料制作了一些存储设备，比方说：

*   磁性材料
    
    比方说生活中常见的磁带、磁盘。
    
*   光学材料
    
    比方说生活中常见的光盘。
    

不论是什么样的存储设备，它的功能就是用来存储数据的，它们所存储的数据可以以一个或多个比特位为一组来进行编址，也就是每一组数据都对一个唯一的一个地址，外界可以通过地址来访问该地址对应的数据。但是不同的存储设备的运行机制是不一样的，比方说DRAM就要求外界给它提供周期性刷新、预充电等信号，CPU如果直接和这些存储设备打交道的话成本会非常高（也就是CPU的设计会非常复杂），所以针对不同的存储设备，我们都可以制作一个相应的控制器，CPU发送给不同控制器的请求是相同的，然后再由控制器去处理和实际存储设备之间的复杂交互。

CPU和存储设备的交互
-----------

CPU和RAM进行交互，可以通过`RAM控制器`作为中介，我们忽略时钟信号和复位信号后，CPU和RAM的通信示意图可以画成这样：

![image_1fan1438qk7k1880h25nvhcim37.png-21.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b5cb4350e394e8883c4c6f7a806c3b1~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=927&h=304&s=21673&e=png&b=ffffff)

如果我们把指令和数据不放在RAM中，而是放在快闪存储器中，然后再制作一个`Flush控制器`（Flush Controller，简称FC）作为CPU与快闪存储器之间的`中介`，那么CPU和快闪存储器的通信示意图就可以画成这样：

![image_1fan14him11641of719hlrap1hj53k.png-22.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3851dfa368294ecd9cc175b98c7e5dce~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=926&h=297&s=23041&e=png&b=ffffff)

我们也可以把指令和数据放在磁盘里，然后再制作一个`磁盘控制器`（Disk Controller，简称DC）作为CPU与磁盘之间的`中介`，那么CPU和磁盘的通信示意图就可以画成这样：

![image_1fan14rf37qv138b1qu9r9a1qqn41.png-21.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff5148e1df44bacb303b0c644597e78~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=926&h=289&s=21894&e=png&b=ffffff)

CPU也可以通过`ROM控制器`（可以简称为ROMC）来访问掩模ROM，如下图所示：

![image_1fan7s6nqvh21lob1keria31k658.png-22.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afd05a772dd14ba49d2a68c9e585a395~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=904&h=291&s=23395&e=png&b=ffffff)

可以看到，不论我们把指令和数据存储到啥类型的存储器中，CPU和外界联系的信号线都不需要改变！这也就意味着我们的CPU做好了就不用再变了，CPU并不关心它所需要的指令和数据到底是来自哪里，如果之后有更换存储器的需求，那换一下和CPU交互的控制器就好了。

但是这里边有一个巨大的不方便的地方，那就是CPU一次只能和一种存储设备进行交互，如果CPU想和多个存储设备进行交互，那就得不停的换和CPU连接的控制器，这也太麻烦了！能不能将CPU和这些存储设备一次性都连起来，然后给不同的存储设备分配不同的地址范围，然后我们在编写软件指令的时候，只要指定不同的地址就可以访问不同存储器中的数据呢？比方说现在CPU想和掩模ROM、RAM、快闪存储器和磁盘这4个存储设备进行通信，而CPU的地址线一共有6根，对应6个二进制位，能表示的地址范围就是`000000₂～111111₂`，也就是十进制的0~63，共64个地址。CPU输出的地址共有6个二进制位，那它的地址信号线就可以被写成CPU\_ADDR\_O\[5:0\]，我们可以人为的将这6个二进制位分成两个部分：

![image_1fap5l53i15jj188tkeq1svu1a0m79.png-19kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e391b7737344974aa410088b8582028~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=917&h=223&s=19422&e=png&b=ffffff)

如图所示：

*   第1部分：前2个二进制位，也就是CPU\_ADDR\_O\[5:4\]， 用于标记要访问哪个存储设备。
    
    我们可以这样规定：
    
    *   当CPU\_ADDR\_O\[5:4\]=00₂时，CPU要访问掩模ROM。
    *   当CPU\_ADDR\_O\[5:4\]=01₂时，CPU要访问RAM。
    *   当CPU\_ADDR\_O\[5:4\]=10₂时，CPU要访问快闪存储器。
    *   当CPU\_ADDR\_O\[5:4\]=11₂时，CPU要访问磁盘。
*   第2部分：后4个二进制位，也就是CPU\_ADDR\_O\[3:0\]， 是存储设备真正接收到的地址。
    

这样的话，CPU的地址就可以被划分成如下4个部分：

*   `000000₂～001111₂`，也就是十进制的0～15：划分到掩模ROM中，掩模ROM实际接收到的地址是`0000₂～1111₂`，也就是十进制的0～15。
    
*   `010000₂～011111₂`，也就是十进制的16～31：划分到RAM中，RAM实际接收到的地址是`0000₂～1111₂`，也就是十进制的0～15。
    
*   `100000₂～101111₂`，也就是十进制的32～47：划分到快闪存储器中，快闪存储器实际接收到的地址是`0000₂～1111₂`，也就是十进制的0～15。
    
*   `110000₂～111111₂`，也就是十进制的48～63：划分到磁盘中，磁盘实际接收到的地址是`0000₂～1111₂`，也就是十进制的0～15。
    

综上所述，CPU的这64个地址的划分就如下图所示：

![image_1fan39e68fbkfa4gkeveu8h14r.png-17.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ccb6e544c90484396e5b264a753747f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=284&h=679&s=17912&e=png&b=ffffff)

那么：

*   如果CPU执行`load_m 0`指令，那就是要读取掩模ROM中地址为0的数据。
*   如果CPU执行`load_m 16`指令，那就是要读取RAM中地址为0的数据
*   如果CPU执行`load_m 32`指令，那就是要读取快闪存储器中地址为0的数据
*   如果CPU执行`load_m 48`指令，那就是要读取磁盘中地址为0的数据

针不戳！这样子简直棒呆了，我们只需要通过修改软件指令的方式就可以让CPU访问不同的存储器，而不用费劲的用替换控制器的这种改硬件的方式让CPU访问不同的存储器。接下来面临的问题就是如何实现这个看起来十分棒呆的功能呢？制作这个设备需要解决下边这几个问题：

*   问题一：各个控制器接收到的HELLO\_I信号如何生成？
    
    CPU一次只能访问一个存储设备，它是通过发出CPU\_HELLO\_O信号来表明自己要发起读/写访问了，那么我们需要：
    
    *   当CPU\_ADDR\_O\[5:4\]=00时，也就是在访问掩模ROM时，我们需要让RC\_HELLO\_I与CPU\_HELLO\_O相同，其余控制器的HELLO\_I信号均为逻辑0。
        
    *   当CPU\_ADDR\_O\[5:4\]=01时，也就是在访问RAM时，我们需要让RC\_HELLO\_I与CPU\_HELLO\_O相同，其余控制器的HELLO\_I信号均为逻辑0。
        
    *   当CPU\_ADDR\_O\[5:4\]=10时，也就是在访问快闪存储器时，我们需要让RC\_HELLO\_I与CPU\_HELLO\_O相同，其余控制器的HELLO\_I信号均为逻辑0。
        
    *   当CPU\_ADDR\_O\[5:4\]=11时，也就是在访问磁盘时，我们需要让RC\_HELLO\_I与CPU\_HELLO\_O相同，其余控制器的HELLO\_I信号均为逻辑0。
        
    
    还记得之前我们制作简易RAM时所用到的`2-4译码器`么：
    
    ![image_1fan9n48l18fs0toi82e81vnp5l.png-24.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/128185cced5b43bb89fa47ac540fdaa6~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=738&h=373&s=25408&e=png&b=ffffff)
    
    这个译码器完成的功能是：
    
    *   当`S₁S₀=00`时，WE0=1，其余WE信号均为0。
    *   当`S₁S₀=01`时，WE1=1，其余WE信号均为0。
    *   当`S₁S₀=10`时，WE2=1，其余WE信号均为0。
    *   当`S₁S₀=11`时，WE3=1，其余WE信号均为0。
    
    我们可以借助这个`2-4译码器`来生成各个控制器的HELLO\_I信号，如下图所示：
    
    ![image_1fan9vvvfno613fu14a8gvvnvo62.png-23.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62828c66766f4537b2b04dac222545bd~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=789&h=293&s=23970&e=png&b=ffffff)
    
*   问题二：CPU的CPU\_ACK\_I信号如何生成？
    
    由于各个控制器都会生成ACK\_O信号，CPU该选择哪个作为CPU\_ACK\_I呢？当然是CPU现在在访问哪个设备，就接收哪个设备的ACK\_O信号喽，也就是：
    
    *   当CPU\_ADDR\_O\[5:4\]=00时，也就是在访问掩模ROM时，CPU\_ACK\_I与ROMC\_ACK\_O相同。
        
    *   当CPU\_ADDR\_O\[5:4\]=01时，也就是在访问RAM时，CPU\_ACK\_I与RC\_ACK\_O相同。
        
    *   当CPU\_ADDR\_O\[5:4\]=10时，也就是在访问快闪存储器时，CPU\_ACK\_I与FC\_ACK\_O相同。
        
    *   当CPU\_ADDR\_O\[5:4\]=11时，也就是在访问磁盘时，CPU\_ACK\_I与DC\_ACK\_O相同。
        
    
    这不就相当于从4个信号（ROMC\_ACK\_O、RC\_ACK\_O、FC\_ACK\_O、DC\_ACK\_O）中选择一个信号（CPU\_ACK\_I）么，很显然使用`4-1选择器`即可解决这个问题：
    
    ![image_1fanase391or91qnq1m39ehg18kn6f.png-37.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0bbd7f74f034b49a7ddc69f6faa1dce~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=915&h=522&s=38036&e=png&b=ffffff)
    
*   CPU收到的数据输入CPU\_DATA\_I是什么？
    
    由于各个控制器都会生成DATA\_O信号，CPU该选择哪个作为CPU\_DATA\_I呢？当然是CPU现在在访问哪个设备，就接收哪个设备的DATA\_O信号喽，也就是：
    
    *   当CPU\_ADDR\_O\[5:4\]=00时，也就是在访问掩模ROM时，CPU\_DATA\_I与ROMC\_DATA\_O相同。
        
    *   当CPU\_ADDR\_O\[5:4\]=01时，也就是在访问RAM时，CPU\_DATA\_I与RC\_DATA\_O相同。
        
    *   当CPU\_ADDR\_O\[5:4\]=10时，也就是在访问快闪存储器时，CPU\_DATA\_I与FC\_DATA\_O相同。
        
    *   当CPU\_ADDR\_O\[5:4\]=11时，也就是在访问磁盘时，CPU\_DATA\_I与DC\_DATA\_O相同。
        
    
    这不就相当于从4个信号（ROMC\_DATA\_O、RC\_DATA\_O、FC\_DATA\_O、DC\_DATA\_O）中选择一个信号（CPU\_DATA\_I）么，很显然使用`4-1选择器`即可解决这个问题：
    
    ![image_1fapfsgih11ij1b7ro9snqu3si7m.png-22.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d23f8a5b727040c4b7a1ed4ecf9a6162~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=608&h=345&s=22727&e=png&b=ffffff)
    
*   其他的信号怎么办？
    
    站在控制器的角度看，它们的DATA\_I、WE\_I均可以来自CPU的CPU\_DATA\_O、CPU\_WE\_O，另外，所有控制器的ADDR\_I都是CPU输出的地址信号的后4位，也就是CPU\_ADDR\_O\[3:0\]。
    
    有同学会想各个控制器都收到同样的DATA\_I、WE\_I以及ADDR\_I会不会有什么问题？没什么问题，因为控制器决定要不要真正的访问存储器依赖的是HELLO\_I信号，如果HELLO\_I信号保持为逻辑0，即使收到别的信号，那它也什么都不用做。
    

综上所述，CPU和各个控制器以及存储设备之间的连接关系最后应该如下图所示：

![image_1fapg8vunelin8181gjt9175g83.png-83.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6afeaf5909c495e87f524847615196a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1336&h=850&s=85520&e=png&b=fcfcfc)

线路密密麻麻，看得让人讨厌的很，赶紧把CPU和各个控制器连接的部分装到黑盒子里去，就像这样：

![image_1fapgccbk18961qak1b6rq2a10e79d.png-86.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4729099b27d47a68e6269e45b196e1c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1382&h=858&s=88990&e=png&b=fefefe)

上图中黑色背景的部分也被称作总线（Bus）模块，简化一下的示意图如下所示：

![image_1fapi3jm88r51s0u1c8dagjtmva7.png-25.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87b4b52fc03842eb9b505e53a2583918~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=917&h=644&s=25927&e=png&b=fefefe)

在使用总线模块进行通信的各个设备中，发起读/写请求的设备称作主（Master）设备，接收读/写请求的设备称作从（Slave）设备。再上图的例子中，CPU是我们唯一的主设备，ROM控制器、RAM控制器、Flash控制器和磁盘控制器作为从设备，我们也可以说上图中的总线模块是一个支持1主4从的总线模块。

以我们上边的电路图来说，如果你要开发自己的主设备，并且可以让主设备发起读操作的话，那就必须在发起读操作的那个时钟周期完成下边这些事情：

*   需要在CPU\_ADD\_O上指定地址
*   令CPU\_WE\_O=0
*   令CPU\_HELLO\_O=1

之后就可以进入等待状态，直到CPU\_ACK\_I=1，主设备就可以读取CPU\_DATA\_I的数据，取到数据之后再进行下一步操作。

类似的，你要开发自己的从设备，也要遵守相应的规则，我们把主设备和从设备之间的通信规则也叫做总线协议，我们需要遵守总线协议来开发自己的主设备和从设备。

我们目前开发的这个总线模块是十分简单的，它只支持1个主设备，内部由一些组合电路构成。如果要开发支持多个主设备的总线模块的话，当多个主设备同时发起读/写请求的时候，总线模块还需要负责决定哪个主设备先进行读/写操作，哪个主设备后进行读/写操作，总线模块中完成这个功能的部分称作`总线仲裁器`。这个时候总线模块就不能是简单的组合电路了，里边应该由更复杂的时序电路组成，由于我们现在用不到，所以就不展开实现总线仲裁器了，等之后放到纸质书中再详细展开吧。

> 小贴士:  
>   
> 其实支持多主多从的总线模块还是很有用的，比方说我们有两个CPU，这两个CPU可以访问相同的存储设备，这时就可以将两个CPU和其他存储设备和支持多主多从的总线模块连接。我们写的软件指令可以放到存储设备中被两个CPU执行，效率不就翻倍了么！这其实就是所谓的多核CPU，但是需要考虑的事情也变得复杂了起来，我们这里就不展开唠叨了。