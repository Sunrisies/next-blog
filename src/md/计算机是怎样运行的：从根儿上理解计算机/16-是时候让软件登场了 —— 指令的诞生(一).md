第17章、指令的诞生
==========

标签： 计算机是怎样运行的

* * *

支持多种运算类型的设备
-----------

经过长时间的努力，我们终于造出了一个如下图所示的可以完成累加运算的设备。

![image_1es0cibbrhdl13p51uc018mf1ksl9.png-48.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c26700111814f11a62abf7c07411190~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1170&h=693&s=49413&e=png&b=fefefe)

令我们欣慰的是这个设备非常“智能”，需要我们人类做的事只是先将需要累加的数输入到RAM中，然后将复位信号RST\_N从逻辑0调整到逻辑1即可坐等累加结果的输出。在进行累加运算的过程中，ALU的控制信号`S₁S₀`需要始终保持为`0`，也就是单纯的将ALU当作一个加法器来看待。

为加深大家印象，我们再来分析一下使用上图的设备来求解`74 + 29 + 32 + 20`的值的过程。为方便分析，我们将振荡器产生的时钟信号根据时间的变化划分成了若干个周期，其中第0个周期从RST\_N变为逻辑1开始算起，如下图所示：

![image_1esc7u0cn1j2ve1nqer1cvvblgm.png-26.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5af3bf69d6e644e08a58b9bec7e5bf19~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=819&h=350&s=27319&e=png&b=ffffff)

我们上一章分析过在不同的阶段，程序计数器（PC）输出、RAM输出、累加器（ACC）输出、ALU输出的情况都是什么，现在我们把ALU控制信号和HALT信号也放在分析的表格中，如下图所示：

阶段

PC输出（地址信号）

RAM输出

ACC输出

ALU的控制信号

ALU输出

HALT信号

第0周期

0

74

0

0（代表加法）

74（0+74）

1

第1周期

1

29

74

0（代表加法）

103（74+29）

1

第2周期

2

32

103

0（代表加法）

135（103+32）

1

第3周期

3

20

135

0（代表加法）

155（135+20）

0

我们认真看一下上边的表格，可以发现针对不同的地址信号，RAM输出不同的加数，而ALU的控制信号一直保持不变。这给了我们一个很大的启示：如果针对不同的地址信号，ALU可以有不同的控制信号，那岂不是可以做各种运算啦！比方说狗哥又来向你请教下边这个表达式的结果是啥：

    74 + 29 - 32 - 20
    

很显然这个表达式中涉及减法，我们不能直接利用前边设计的累加设备来求解它的值，不过如果我们可以针对不同的地址信号，让ALU采用不同的控制信号的话，那么在RST\_N信号从逻辑0调整到逻辑1后，`74 + 29 - 32 - 20`的求解过程就可以是这样的：

*   在第0周期中，程序计数器的输出为`0`，也就是地址信号为`0`时，RAM的输出为`74`，相应的ALU的控制信号为`0`（二进制的00），此刻ALU做加法运算。
    
    此时累加器的输出为`0`，ALU做的运算是：`0 + 74`，ALU的输出为`74`。
    
*   在第1周期中，在地址信号为`1`时，RAM的输出为`29`，相应的ALU的控制信号为`0`（二进制的00），此刻ALU做加法运算。
    
    此时累加器的输出为`74`，ALU做的运算是：`74 + 29`，ALU的输出为`103`。
    
*   在第2周期中，在地址信号为`2`时，RAM的输出为`32`，相应的ALU的控制信号为`1`（二进制的01），此刻ALU做减法运算。
    
    此时累加器的输出为`103`，ALU做的运算是：`103 - 32`，ALU的输出为`71`。
    
*   在第3周期中，在地址信号为`3`时，RAM的输出为`20`，相应的ALU的控制信号为`1`（二进制的01），此刻ALU做减法运算。
    
    此时累加器的输出为`71`，ALU做的运算是：`71 - 20`，ALU的输出为`51`。
    

我们画个表格总结一下就是：

阶段

PC输出（地址信号）

RAM输出

ACC输出

ALU的控制信号

ALU输出

HALT信号

第0周期

0

74

0

0（代表加法）

74（0+74）

1

第1周期

1

29

74

0（代表加法）

103（74+29）

1

第2周期

2

32

103

1（代表减法）

71（103-32）

1

第3周期

3

20

71

1（代表减法）

51（71-20）

0

由于振荡器生成的时钟信号频率十分高，我们手速赶不上，不能在地址信号为2时就手动的把ALU的控制信号改为`1`（二进制的01），从而让ALU做减法操作。不过既然我们可以在不同的地址信号下让RAM输出不同的数，我们也可以再整一个RAM，让这个RAM在不同的地址信号下输出不同的ALU控制信号不就得了。

由于ALU的控制信号是用来指导ALU该做啥类型的运算，所以ALU的控制信号又被称作`指令`，而新引入的RAM是用来存储ALU的控制信号的，所以新引入的RAM就可以被称为`指令RAM`。现在电路中存在了两个RAM，为做区别，我们把原先用于存储参与运算的数据的RAM称作`数据RAM`。引入`指令RAM`后的电路图如下所示：

![image_1f89au4e7brp174g1cnepu4nrh9.png-68.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adea6c37b00e4433ba44fcb955502d7f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1153&h=757&s=69702&e=png&b=fefefe)

可以看到，ALU的控制信号不再恒为0，而是依赖`指令RAM`的输出。这里需要注意注意一下，我们选用的`指令RAM`的容量仍然是`4×8`，也就意味着`指令RAM`的输出包含8个二进制位。而ALU的控制信号只需要2个二进制位。我们给`指令RAM`输出的每一个二进制位编个号，如下图所示：

![image_1eru4b0o31o8a1u3j1du01vq714rt1g.png-6.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2e47388cb914b5f81946791a5d7eb3a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=592&h=189&s=6586&e=png&b=ffffff)

我们在从`指令RAM`到ALU控制信号的连线上标注了`[1:0]`，这意味着ALU的控制信号其实是`指令RAM`输出的第0位~第1位。如下图所示：

![image_1ervap22g11vjj7v1t7orhb18id1t.png-19.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e724eb5588342119cb1d3b2af3eab33~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=623&h=287&s=19922&e=png&b=ffffff)

为求解`74 + 29 - 32 - 20`的结果，我们只需在`指令RAM`和`数据RAM`中分别填入下面的数据（其中`指令RAM`中的数据是二进制形式，`数据RAM中`的数据是十进制形式）：

![image_1esc8fh6l12rsioapoqvehkhb13.png-16.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc38764f979e4bef8f7a4312a3e8df01~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=442&h=285&s=16839&e=png&b=fefefe)

这样在将复位信号RST\_N从逻辑0调整到逻辑1后，我们只需坐等结果了。这里需要提醒大家的是，我们向`指令RAM`中填入的是ALU的控制信号，我们目前设计的ALU只支持4种类型的运算，为了勾起大家的记忆，我们还是把ALU的控制信号取不同值时对应的运算类型列举一下：

ALU控制信号的二进制形式

运算类型

简称

`00`

加法

add

`01`

减法

sub

`10`

按位与

and

`11`

按位或

or

 

控制信号`00`、`01`、`10`、`11`分别代表不同的运算，可是这样并不利于我们人类理解（比方说看到“10”之后，还得到上表中看看到底“10”代表什么运算），所以我们之后在展示`指令RAM`中的数据的时候，直接用ALU控制信号对应运算类型的简称来代替它的二进制形式。比方说我们在求解`74 + 29 - 32 - 20`的结果时，`指令RAM`和`数据RAM`中的数据之后会用下边的形式来展示：

![image_1esc8jn531be41127s2fhm47ou1g.png-18.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8800c662797b41d89017d1760b425d38~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=485&h=295&s=19287&e=png&b=fefefe)

除了加法和减法，该ALU还支持`按位与`和`按位或`的运算，想对哪些数据进行什么类型的运算，直接调整`指令RAM`和`数据RAM`的数据即可，如果`指令RAM`和`数据RAM`中的数据是这样的话：

![image_1e45kkc045pauk41gomfsl130v20.png-15.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd4e10c0fbb4382a910e630bd58a2ab~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=439&h=245&s=16304&e=png&b=fefefe)

那么就相当于对下边这个表达式求值：

    ((74 | 29) - 32) & 20
    

> 小贴士：  
>   
> 到目前为止我们搭建起了一个电路，我们把这个电路称作硬件。  
>   
> 虽然硬件结构非常复杂，但对使用硬件的用户来说是透明的，即用户只需要往数据RAM塞入需要参与运算的数据，往指令RAM塞入相应运算对应的指令，即可完成指定表达式的计算，我们把用户塞到数据RAM中的数据和指令RAM中的指令称作软件。对于同一套硬件，用户可以编写不同的软件来完成不同的功能。编写软件的过程也称作编程（program），编程程序的人又被称作程序员（programmer），就是屏幕前的你哈。

引入HALT指令
--------

我们目前选用的`指令RAM`和`数据RAM`的容量都是`4×8`， 也就是只支持对4个数进行运算，如果我们想对5个数进行运算呢？比方说对下边这个表达式进行求值：

    74 + 29 - 32 - 20 + 11
    

很遗憾，上边的设备不支持。其实做下边两个改进即可支持对5个数做运算。

*   改进一：将RAM的容量扩大，并更新配套设备（包括地址线条数以及输入设备位数）。
    
    将`指令RAM`和`数据RAM`的容量都扩展为`64×8`，这样就可以最多对64个数进行运算了。不过也意味着地址线需要变为6条（2⁶=64），
    
    为对`74 + 29 - 32 - 20 + 11`表达式进行求值，我们需要在`指令RAM`和`数据RAM`中分别填入下边的数据：
    
    ![image_1esaagnov1geo1g6husg1b7c1tr5p.png-16.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9ea7cbef27f43faa021d99536e83f89~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=479&h=312&s=17018&e=png&b=fefefe)
    
*   改进二：原先在计算4个数的运算结果时，比较器的一个恒定输入保持为3，意味着在第3周期，也就是程序计数器输出为3的时候就停止执行。现在需要计算5个数的运算结果，所以比较器的一个恒定输入需要保持为4。
    

做了上边两条改进之后，得到的电路图如下所示：

![image_1fk6bq3im1rgn1s599kc6iu4nu9.png-53.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f71794dd904837be461f9d18a07f64~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1179&h=711&s=55165&e=png&b=fefefe)

在每个时钟周期，电路中各个设备的输出如下所示：

阶段

PC输出（地址信号）

数据RAM输出

ACC输出

指令RAM输出(ALU的控制信号)

ALU输出

HALT信号

第0周期

0

74

0

00（代表加法）

74（0+74）

1

第1周期

1

29

74

00（代表加法）

103（74+29）

1

第2周期

2

32

103

01（代表减法）

71（103-32）

1

第3周期

3

20

71

01（代表减法）

51（71-20）

1

第4周期

4

11

51

00（代表加法）

62（51+11）

0

很显然，在第4周期时，电路将停止运行，我们在`8位输出设备`中可以将`74 + 29 - 32 - 20 + 11`的结果读出。

有同学会问了，那如果我们想要对6个数进行运算呢？简单，我们只需要将比较器的一个恒定输入调整为5就好了。那要对7个数进行运算呢？也简单，将比较器的一个恒定输入调整为6不就好了~

可是每次改变参与运算的数字个数时，都得调整一下比较器的恒定输入，也就意味着都得改动一下硬件，这个事情还是比较烦人的。我们重新思考一下在电路中引入比较器的原因，是因为我们需要知道在程序计数器输出哪个地址时将HALT信号设置为逻辑0，从而让电路停止运行。咦，目前我们的`指令RAM`输出8个二进制位代表一条指令，其中编号为0和1的位是用于生成ALU的控制信号的，我们完全可以从其他尚未使用到的二进制位中取一个来代表HALT信号呀，如下图所示：

![image_1esao92g41uh56fofb2cq11n6g23.png-16.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e18bdd387db477095477496790fa6e3~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=663&h=276&s=17297&e=png&b=ffffff)

接下来可以在电路图中去掉比较器，而让指令中编号为2的二进制位直接作为HALT信号，如下图所示（我们特意将指令中编号为2的二进制位对应的信号线标绿了）：

![image_1fk6br32i1l6r1p2s1i451hfonh7m.png-51.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a51b28e6064f6cb3e822ecca769019~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1206&h=730&s=53183&e=png&b=fefefe)

那么现在的指令就可以扩充为8个：

指令的二进制形式

运算类型

简称

`100`

加法

add

`101`

减法

sub

`110`

按位与

and

`111`

按位或

or

`000`

加法并停止

add\_halt

`001`

减法并停止

sub\_halt

`010`

按位与并停止

and\_halt

`011`

按位或并停止

or\_halt

然后在对`74 + 29 - 32 - 20 + 11`表达式进行求值时，最后一条指令就不再填`add`，而是填`add_halt`，`指令RAM`和`数据RAM`的数据填充情况如下所示：

![image_1esapebadf103r71m6ceii1dn02t.png-17.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d031612264754703bc13b9bea59bcc6d~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=461&h=321&s=17828&e=png&b=fefefe)

之后在每个时钟周期，电路中各个设备的输出如下所示：

阶段

PC输出（地址信号）

数据RAM输出

ACC输出

指令RAM输出(ALU的控制信号)

ALU输出

HALT信号

第0周期

0

74

0

100（代表加法）

74（0+74）

1

第1周期

1

29

74

100（代表加法）

103（74+29）

1

第2周期

2

32

103

101（代表减法）

71（103-32）

1

第3周期

3

20

71

101（代表减法）

51（71-20）

1

第4周期

4

11

51

000（代表加法并停止）

62（51+11）

0

很显然，在第4周期时，`指令RAM`输出的指令是`000`，指令中编号为2的二进制位是逻辑0，也就意味着HALT信号为逻辑0，这样电路便会停止运行。

非常好！我们通过新增指令的方式就可以让电路停下来，而不是每当参与运算的数字个数改变时，就去调整原先电路结构（改变比较器的一个恒定输入）。不过为了让电路停下来，原先的每个指令都有一个对应的halt版本（add对应add\_halt，sub对应sub\_halt，and对应and\_halt，or对应or\_halt），我们目前支持的指令较少，所以引入4条对应的halt指令看起来也没啥问题，如果我们支持的指令更多的话，那么就会有更多条对应的halt指令，这有点而麻烦哦，能不能单独引入一条halt指令来让电路停下来呢？没问题的，我们可以这样规定指令的二进制形式代表的含义：

指令的二进制形式

运算类型

简称

`100`

加法

add

`101`

减法

sub

`110`

按位与

and

`111`

按位或

or

`0XX`

停止执行

halt

这样的话，`指令RAM`和`数据RAM`的数据就得改为下边这样：

![image_1esapvugidvv1vf41heckfe1h8t3a.png-18.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70f2d50c373f48cbaf28692ee691d436~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=496&h=368&s=19284&e=png&b=fefefe)

如上图所示，我们新增加了一条指令`halt`，当程序计数器输出的地址为5时，`指令RAM`将输出halt指令，halt指令的编号为2的二进制位就代表HALT信号，此时HALT信号将变为逻辑0，整个电路停止运行。在执行halt指令的过程中，我们并不关心ALU的控制信号是什么，所以用`X`来代表指令中编号为0和1的两个二进制位的值（X表示逻辑0或者逻辑1都可以）。另外，在这个过程中地址为5的`数据RAM`中的数据是什么不重要，在执行到halt指令时我们只想让电路停下来，所以我们用`无所谓`来表示`数据RAM`中地址为5处的数据。

接着分析一下在引入halt指令后，在每个时钟周期，电路中各个设备的输出都是什么：

阶段

PC输出（地址信号）

数据RAM输出

ACC输出

指令RAM输出(ALU的控制信号)

ALU输出

HALT信号

第0周期

0

74

0

100（代表加法）

74（0+74）

1

第1周期

1

29

74

100（代表加法）

103（74+29）

1

第2周期

2

32

103

101（代表减法）

71（103-32）

1

第3周期

3

20

71

101（代表减法）

51（71-20）

1

第4周期

4

11

51

100（代表加法）

62（51+11）

1

第5周期

5

无所谓

62

0XX（代表停止执行）

无所谓（62+无所谓）

0

哇呀呀~~~ 在第5周期中，程序计数器输出的地址为5，`指令RAM`中输出的指令为halt，此时电路停止运行。但是十分不幸的是，在第4周期ALU的输出就代表了`74 + 29 - 32 - 20 + 11`的运算结果，在第5周期的时钟信号上升沿到来后，该结果又被写入到了累加器中。而且在地址为5时，`数据RAM`的输出是一个无所谓的数，这个无所谓的数和累加器的输出作为ALU的两个输入，那么ALU的输出肯定也是一个无所谓的数！该咋办呢？

也简单，因为在第5周期中，`74 + 29 - 32 - 20 + 11`的运算结果已经被写入了累加器，我们直接采用累加器的输出，而不是原先的ALU的输出作为最终输出不就好了？好简单的解决方案喔~ 赶紧改一下电路图，让`8位输出设备`连接到ALU的输出吧：

![image_1fk6c54m91aelvnb1udjnujqea2j.png-51.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0770ea32c43e4e06b856a8b15df9bf2e~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1070&h=795&s=52511&e=png&b=fefefe)

完美@\_@! 现在我们指令就扩充为：`add`、`sub`、`and`、`or`、`halt`五条。继续接下来的征程吧~