第28章、指令集体系结构
============

标签： 计算机是怎样运行的

* * *

指令集体系结构概述
---------

如果你买了一台电视，你不需要知道电视屏幕到底是怎么发出五颜六色的光的，你只需要阅读产品说明书，知道电视上的每一个按键都有什么功能，怎么通过遥控器换台、控制音量就好了。类似的，作为软件程序员的你买了一个CPU，你其实并不需要知道CPU里边到底是怎么设计电路的，只需要参照这个CPU的说明书去编写指令就好了。

在CPU的说明书里，会告知软件程序员在编程时可以使用的指令有哪些，这些指令的集合也被称作`指令集`（Instruction Set），还会告知软件程序员可以使用的寄存器有哪些，可以访问的存储单元地址范围是什么，指令的寻址方式有哪些，如何访问I/O设备等等，CPU说明书里的这些内容可以统称为`指令集体系结构`或`指令集架构`（Instruction Set Architecture），简称ISA。

A厂家和B厂家制造的电视机的内部构造可能是不同的，但可以提供相同的使用方式，即电视上的按键和遥控器的功能都相同。这样狗哥在会使用A厂家的电视后，就可以毫不费力的操作B厂家的电视。类似的，A厂家和B厂家可以生产内部构造并不相同，但却拥有相同`指令集体系结构`的CPU。这样软件程序员在A厂家生产的CPU上编写的软件程序，可以很容易的就运行在B厂家生产的CPU上。很显然，`指令集体系结构`充当了一个中间人，硬件工程师遵照`指令集体系结构`的说明去设计硬件，软件工程师遵照`指令集体系结构`的说明去编写软件，硬件工程师和软件工程师并不需要直接沟通。

`指令集体系结构`是独立于CPU的具体电路实现而抽象出的一个概念，CPU的具体电路实现也被称作`微体系结构`。随着时代的变迁，陆续出现了不同的`指令集体系结构`，很多种`指令集体系结构`也湮没在历史的车轮里，下边我们介绍几种现在市面上还在流行的`指令集体系结构`：

*   x86
    
    “灯 等灯等灯”～ 各位在电视或网络上肯定听到过Intel公司的广告音乐，足够洗脑。Intel公司开发了一系列名称以86结尾的CPU，如8086、80286、80386等等，Intel公司生产的CPU所使用的`指令集体系结构`统称为x86（虽然后续研发的CPU的命名并不以86结尾，诸如奔腾系列、酷睿系列，但仍被称作x86系列）。时至今日，大部分个人电脑上装的都是使用x86体系结构的CPU。除Intel以外，其他一些公司也在生产x86体系结构的CPU，这里头最出名的就是AMD公司，大家现在在网上选购自己电脑的CPU时选用的最多的就是AMD公司或Intel公司家的x86体系结构CPU。
    
*   MIPS
    
    MIPS是John Hennessy教授和他的朋友们在20世纪八十年代在斯坦福大学首先提出的一种指令集体系结构，在游戏机、路由器、摄像头、电视机种有很多应用。值得一提的是，中国科学院计算所自主研发的CPU——龙芯，就是基于MIPS指令集体系结构进行研发的。
    
*   POWER
    
    这是一种由IBM公司设计研发的一种指令集体系结构，应用在很多IBM制作的计算机中。
    
*   SPARC
    
    这是一种有Sun公司设计研发的一种指令集体系结构。
    
*   ARM
    
    这是一种由ARM公司设计研发的一种指令集体系结构，ARM公司并不直接参与CPU的制造与销售，而是把指令集架构授权给别的公司。目前我们常用的手机CPU很多都是用的是ARM指令集体系结构，比方说我们常听说的高通、华为海思等等。
    
*   RISC-V
    
    RISC-V是美国加州大学伯克利分校于2010年开始设计的一款新的指令集体系结构，这是一种完全开放、免费使用的指令集体系结构。
    

这些`指令集体系结构`可以被分成两个大类：

*   复杂指令集，英文名：Complex Instruction Set Computer，简称CISC。
    
*   精简指令集，英文名：Reduced Instruction Set Computer，简称RISC。
    

上述`指令集体系结构`中，只有x86属于CISC，其余的都属于RISC。CISC提供更多的指令，其中包含很多完成复杂功能的指令，这些指令平时可能很少用到。相反，RISC只提供很少的一些简单指令，那些复杂的功能需要编写若干条简单指令才能去实现。对于软件程序员来说，CISC可以让软件程序员编写的程序的指令更少，而RISC可能需要使用更多的指令；但对于CPU设计人员来说，设计RISC的电路比CISC更简单一些，而且RISC由于结构简单，指令执行效率也更好一点。

那我们之前制作的那个CPU是属于哪个指令集体系结构的呢？哪个也不算！那只是小孩子随意搭建的，没啥实用性。下边我们以MIPS指令集体系结构为例，来唠叨一下软件程序员实际应该如何编程。

真正开始编程
------

编写软件程序这个事儿说难也难，说简单那是相当简单。就像是你使用乐高积木一样，虽然单个的积木十分简单，不同积木之间的拼接方式也十分有限，但，有的人就可以拼出变形金刚，有的人却只能拼出个四不像，还一摸就破的那种。

我们说编写软件程序是相当简单的，是因为软件程序员所看到的世界是相当简单的：程序员只能看到若干寄存器和CPU地址（每个地址都对应主存的一个存储单元或I/O设备的寄存器）。MIPS指令集体系结构也有不同的版本，我们这里以MIPS32为例来唠叨如何使用指令集体系结构进行软件编程。MIPS32中的“32”指的是CPU一次可以处理的数据位数是32位，比方说一条指令最多可以将32位数据从主存或I/O设备加载到CPU。CPU一次可以处理的数据位数也可以被称作一个字（word）。

### MIPS中的寄存器

MIPS指令集为程序员提供了如下所述的寄存器（在MIPS32中，这些寄存器的位数都是32）：

*   32个通用寄存器。程序员可以将某个CPU地址对应的主存或I/O设备中的数据加载到某个通用寄存器中，也可以将某个通用寄存器中的数据写回到某个CPU地址对应的主存或I/O设备中。
    
*   程序计数器，简称PC，这是一个特殊用途的寄存器，用于存储当前正在执行指令的地址。
    
*   HI和LO寄存器，他俩也是特殊用途寄存器，当执行乘法或累加/累减指令时，HI和LO寄存器共同用于存储结果，当执行除法指令时，LO寄存器用于存储商，HI寄存器用于存储余数。
    

![image_1fcsobi4avqc15jn16kkkrbh409.png-30.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0970830f427f4a64813b1bca36552e40~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=414&h=780&s=30992&e=png&b=ffffff)

我们之前设计的CPU中只包含一个累加器用于临时存储数据，而MIPS32中提供了32个通用寄存器用于临时存储数据，这里有必要单独说明一下它们。这32个通用寄存器的详细说明如下表所示：

寄存器编号

约定名称

用途

$0

$zero

总是为0

$1

$at

用于汇编器处理伪指令

$2 - $3

$v0, $v1

用于存储函数返回值

$4 - $7

$a0 - $a3

用户存储调用函数时传递的前4个参数

$8 - $15

$t0 - $t7

临时寄存器，被调用函数在使用它们是可以不用先保存它们的值

$16 - $23

$s0 - $s7

保存寄存器，被调用函数在使用它们前需先将它们保存到主存中，函数结束时再将它们的值恢复

$24 - $25

$t8 - $t9

临时寄存器

$26 - $27

$k0 - $k1

给操作系统内核使用的寄存器

$28

$gp

全局指针

$29

$sp

栈指针

$30

$fp

帧指针

$31

$ra

用于存放函数返回地址

这些寄存器中$0比较特殊，它的值永远为0，我们并不能通过编写指令来修改它的值（这是因为MIPS中有很多指令需要访问值为0的寄存器）。其余寄存器我们可以随意使用，但为了程序的易读性，人们事先约定好它们的用途，这样狗哥写的程序也可以很快的被猫爷看懂，各个寄存器的约定用途如上表所示。

> 小贴士：  
>   
> 上表中各个寄存器用途的部分出现了很多陌生的概念，大家不懂直接跳过就好了

### MIPS中的CPU地址

在MIPS32中，CPU地址位数最多也是32位，也就是232个地址。MIPS采用内存映射式I/O，这232个地址分别对应着ROM、RAM和I/O设备，如下图所示：

![image_1fd7k23n2kno15ol1fup1rme9ab3u.png-13.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3ca8a07832e43a1b4ee54f8939a951f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=543&h=422&s=14022&e=png&b=ffffff)

其中的ROM一般用于存储系统复位时的`引导程序`，我们写的程序一般存储在磁盘、固态硬盘或者U盘中，`引导程序`会将我们写的程序复制到RAM中，然后跳转到我们写的程序的入口地址，然后CPU就开始执行我们的程序了。

### 程序员的任务

介绍了MIPS中为程序员提供的寄存器和CPU地址后，该谈一下程序员的任务了。程序员最基础的任务大致下边这些

*   将某个CPU地址对应的主存或I/O设备中的数据加载（load）到寄存器中。
    
*   将寄存器中的数据存储（store）到某个CPU地址对应的主存或I/O设备中。
    
*   对某两个寄存器中的数据进行算术/逻辑运算，将运算结果再写回到某个寄存器中。
    
    > 小贴士：  
    >   
    > 某些指令集体系结构，比如x86，还支持对寄存器和某个CPU地址对应的数据进行运算的指令；某些指令集体系结构，比如PDP系列，还支持对两个CPU地址对应的数据进行运算的指令。而以MIPS为代表的RISC仅支持对两个寄存器中的数据进行运算，这样做的目的是为了让CPU的硬件设计更加简单，单条指令的执行速度也更快。
    
*   无条件或有条件跳转到某个地址处的指令去执行。
    

为了完成上述这些功能，MIPS提供了一系列指令。MIPS的指令属于固定长度的指令，指令大小统统都是4个字节。

> 小贴士：  
>   
> 有一些指令集体系结构中的指令的长度不是固定的，比方说x86，它的指令长度在1～15字节之间，它的指令可以被称作可变长度的指令。

这些指令依据格式的不同，可以被划分成3种类型：

*   R类型指令
    
    R表示Register，即寄存器。R类型指令用于对不同寄存器中的数据进行运算，然后再写回到寄存器中。R类型指令的格式如下图所示：
    
    ![image_1fcvj8l9sv7p1tlo1euv1tthjham.png-20.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad914a5ef554ffa98a605ac7a4735e7~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1157&h=284&s=20929&e=png&b=ffffff)
    
    我们可以把op和func的组合看作是R类型指令的操作码，其余部分看成是操作数。很显然，R类型指令共有4个操作数，其中大部分算术/逻辑运算指令只需要3个操作数：rs和rt是源操寄存器的编号，rd是目的寄存器的编号，一般的算术运算指令会将rs和rt代表的源寄存器中的数据进行运算，然后存储到rd代表的目的寄存器中。sa只在移位指令中使用，用于指定移动的位数。
    
    稍后介绍具体的R类型指令。
    
*   I类型指令
    
    I表示Immediate，即立即数。I类型指令用于那些包含立即数的指令。I类型指令的格式如下图所示：
    
    ![image_1fcvjd3a61tafltq1kb91i9vcor1g.png-17.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e180f50802a44f1fb6a9b556df9f67d0~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1113&h=282&s=17805&e=png&b=ffffff)
    
    op表示操作码，rs、rt和imm表示操作数，rs和rt的含义和R类型指令中的一样（不过在某些指令，诸如lw指令中，rt是作为目的寄存器的），imm表示一个16位的立即数，在进行运算时需要将其扩展成一个32位的立即数。
    
    稍后介绍具体的I类型指令。
    
*   J类型指令
    
    J表示Jump，即跳转。J类型指令用于跳转操作。J类型指令的格式如下图所示：
    
    ![image_1fcvjeh3a8tp1tv1m7e1l731qje1t.png-16.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37beefbab7ff4d6183c2eee64afb477b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1098&h=280&s=16900&e=png&b=ffffff)
    
    op表示操作码，addr表示要跳转的地址。
    
    稍后介绍具体的J类型指令。
    

MIPS中的指令
--------

MIPS虽然不像x86那样有上千条指令，但还是有上百条的。接下来我们只介绍一些常用的指令。

### 加载存储指令

加载（load）指令指的是将某个CPU地址对应的数据加载到某个寄存器中，MIPS中常用的加载指令有下边这些：

![image_1fd6ap9us1ch3cks16097hotf4m.png-38.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f81ab9d36b9c4de493ede72fcfb2a232~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=881&h=385&s=39092&e=png&b=ffffff)

从上边的指令格式可以看出来，加载指令是I类型指令。其中的rt部分代表要将数据写入哪个寄存器中。base和offset部分共同决定该指令是要读取哪个CPU地址处的数据，具体的计算方式是：

    地址 = base寄存器中存储的数据 + 符号扩展为32位后的offset
    

下边分别看一下不同指令完成的不同功能：

*   lb指令：全称为Load Byte。表示加载一个字节的有符号数据到目的寄存器中。
    
    > 小贴士：  
    >   
    > 由于MIPS32中的寄存器都是32位的，加载一个字节的数据到寄存器的低8位后，其余高位需要使用符号扩展进行填充。
    
*   lbu指令：全称为Load Byte Unsigned。表示加载一个字节的无符号数据到目的寄存器中。
    
*   lh指令：全称为Load Halfword。表示加载半个字，也就是2个字节的有符号数到目的寄存器中。
    
*   lhu指令：全称为Load Halfword Unsigned。表示加载半个字，也就是2个字节的无符号数到目的寄存器中。
    
*   lw指令：全称为Load Word。表示加载1个字，也就是4个字节的数据到目的寄存器。由于目的寄存器也是4个字节大小，所以就不需要进行高位扩展了。
    

### 逻辑运算指令

MIPS常用的逻辑运算指令如下所示：

![image_1fd6np9mle2ki4p5pt1fhf164l13.png-55.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ffa13773e1b43c29ecfeb33751ee1b3~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=910&h=573&s=56800&e=png&b=fefefe)

其中and、or、xor、nor指令是R类型指令，andi、ori、xori是I类型指令，我们分别看一下它们的用途：

*   and指令用于将rs和rt寄存器中的数据进行与运算，将结果写到rd寄存器中。
    
*   or指令用于将rs和rt寄存器中的数据进行或运算，将结果写到rd寄存器中。
    
*   xor指令用于将rs和rt寄存器中的数据进行异或运算，将结果写到rd寄存器中。
    
*   nor指令用于将rs和rt寄存器中的数据进行同或运算，将结果写到rd寄存器中。
    
*   andi指令用于将16位立即数imm进行0扩展为32位，然后与rs寄存器中的数据进行与运算，将结果写到rt寄存器中。
    
*   ori指令用于将16位立即数imm进行0扩展为32位，然后与rs寄存器中的数据进行或运算，将结果写到rt寄存器中。
    
*   xori指令用于将16位立即数imm进行0扩展为32位，然后与rs寄存器中的数据进行异或运算，将结果写到rt寄存器中。
    

### 移位操作指令

MIPS常用的移位指令如下所示：

![image_1fd6q0jlmucph4t12n91frb1rku1t.png-28.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8dae4e81743f48739f059db00ca816a3~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=898&h=279&s=29115&e=png&b=fefefe)

这些移位指令都是R类型指令，并且rs部分的值都是0。它们的功能分别是：

*   sll指令：全称为Shift Word Left Logical。表示将rt寄存器中的值向左移动sa部分代表的位数，空出来的位置用0填充，然后将结果写到rd寄存器中。
    
    比方说有一个rt寄存器存储的数据是（中间实际没有空格，为了美观才加的空格）：
    
        11100111 11100111 11100111 11100111
        
    
    如果执行sll指令，将其向左移动2位，那写入rd寄存器的结果就是：
    
        10011111 10011111 10011111 10011100
        
    
*   srl指令：全称为Shift Word Right Logical。表示将rt寄存器中的值向右移动sa部分代表的位数，空出来的位置用0填充，然后将结果写到rd寄存器中。
    
    比方说有一个rt寄存器存储的数据是（中间实际没有空格，为了美观才加的空格）：
    
        11100111 11100111 11100111 11100111
        
    
    如果执行srl指令，将其向右移动2位，那结果就是：
    
        00111001 11111001 11111001 11111001
        
    
*   sra指令：全称为Shift Word Right Arithmetil。表示将rt寄存器中的值向右移动sa部分代表的位数，空出来的位置用原最高位填充，然后将结果写到rd寄存器中。
    
    比方说有一个rt寄存器存储的数据是（中间实际没有空格，为了美观才加的空格）：
    
        11100111 11100111 11100111 11100111
        
    
    如果执行sra指令，将其向右移动2位，那结果就是：
    
        11111001 11111001 11111001 11111001
        
    

### 算术运算指令

MIPS常用的算术运算指令如下所示：

![image_1fd6sf418aqtkp01igr15n51sjd2a.png-65.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fbb9568fa854ecbb5c91d496d52b376~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=926&h=559&s=67347&e=png&b=fefefe)

上述算术运算指令都是R类型指令，它们的功能分别是：

*   add指令用于将rs和rt寄存器的值相加，将结果放到rd寄存器中。如果运算时产生了溢出（rs和rt当作两个有符号数），则会产生一个异常。
    
*   addu指令用于将rs和rt寄存器的值相加，将结果放到rd寄存器中，运算时溢出也不会产生异常。
    

sub和subu类似add和addu，只不过做的是减法运算。

*   mult指令用于将rs和rt寄存器的值看作是有符号数并相乘，产生一个64位的结果，将结果的高32位存储在寄存器HL中，低32位存储在寄存器LO中。
    
*   multu指令用于将rs和rt寄存器的值看作是无符号数并相乘，产生一个64位的结果，将结果的高32位存储在寄存器HL中，低32位存储在寄存器LO中。
    
*   div指令用于将rs和rt寄存器的值看作是有符号数并相除，将商放在寄存器LO中，将余数放在寄存器HI中。
    
*   div指令用于将rs和rt寄存器的值看作是无符号数并相除，将商放在寄存器LO中，将余数放在寄存器HI中。
    

### 跳转指令

MIPS常用的跳转指令如下所示：

![image_1fd6ve1sjnpg9gr8ho3kc14ch2n.png-38.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaecac0db9494fe1b7de8a87d1ab4c88~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=908&h=469&s=39533&e=png&b=fefefe)

其中jr和jalr是R类型指令，j和jal是J类型指令，它们的功能分别是：

*   jr指令用于将rs寄存器中的值作为新的PC。
    
*   jalr指令用于将rs寄存器的值作为新的PC，并且将跳转指令后的第2条指令保存到rd中。
    

j指令和jalr指令的用法较为复杂，这就不说了。

### 分支指令

MIPS常用的分支指令如下所示：

![image_1fd74rohh3p11g8mhgajup1e423h.png-46.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81f2f7cd59614113b08fa87d0ba673dc~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=900&h=442&s=47199&e=png&b=ffffff)

上述指令都是I类型指令，它们用于实现程序是否跳转到新地址执行，新地址的计算方式是：

    新地址 = offset左移2位后进行符号扩展到32位 + 当前PC的下一条指令的地址
    

接下来看一下各个指令都完成什么功能：

*   beq指令：全称为Branch on Equal。表示当rs和rt寄存器中的值相等时才跳转，否则不跳转。
    
*   bne指令：全称为Branch on Not Equal。表示当rs和rt寄存器中的值不相等时才跳转，否则不跳转。
    
*   blez指令：全称为 Branch on Less Than or Equal to Zero。表示当rs寄存器中的值小于或等于0时才跳转，否则不跳转。
    
*   bgtz指令：全称为Branch on Greater Than Zero。表示当rs寄存器值大于0时才跳转，否则不跳转。
    
*   bltz指令：全称为Branch on Less Than Zero。表示当rs寄存器的值小于0时才跳转，否则不跳转。
    
*   bgez指令：全称为Branch on Greater Than or Equal to Zero。表示当rs寄存器的值大于或等于0时才跳转，否则不跳转。
    

好了，先介绍这么多指令吧，介绍的太多大家也接受不了。程序员在学会各式各样的指令后，就相当于有了最基础的积木，然后就可以让这些积木组合成更复杂的形状，从而编写出各式各样的软件。什么大型游戏、办公软件、视频播放巴拉巴拉各种软件都是基于这些最基础的指令的。

> 小贴士：  
>   
> 很遗憾的告知各位，我们的小册的正文部分到这里就结束了，各位同学有没有一种突然戛然而止的感觉，好像电影逐渐进入高潮的时候突然来了一句“全剧终”。反正小孩子是有这么一种感觉，虽然已经写了不少东西，但感觉要写的还有好多，不过一时半会儿不知道怎么表达出来。给小孩子一点儿时间，再认真积淀出一本纸质书出来，2022年见～