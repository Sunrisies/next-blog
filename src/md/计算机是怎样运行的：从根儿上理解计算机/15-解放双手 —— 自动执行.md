第16章、自动执行
=========

标签： 计算机是怎样运行的

* * *

实现自增
----

上一章中我们说每次CLK信号上升沿到来之前，都需要通过2位输入设备生成`RAM`需要的地址信号，而每次生成的地址信号都比上一次生成的大1！对于懒癌患者的我们来说，手动输入地址信号仍然是一件很费力的活，而且也不能保证输不错，所以我们引入一个加法器来继续解放一下双手：

![image_1es0bo6ma1q7717q21eje18c19959.png-24.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d042608760541ce9772f8dd26f03faf~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=672&h=420&s=25314&e=png&b=fefefe)

如图所示，我们引入了一个`2位加法器`，并且保证`Cin`始终为逻辑0。加法器的一个输入恒为1，另一个输入是寄存器的输出，也就是说加法器完成的功能就是将寄存器的输出加1。而加法器的输出又作为寄存器的输入，每当CLK信号上升沿到来的时候都把加和结果存储在该寄存器中。

这样的话，初始情况下我们只需要将寄存器清零，然后每次CLK信号上升沿到来后，寄存器的输出都会自动加1～也就是说上图中Y的值将会是0、1、2、3、...

赶紧把上图中的电路放到之前设计的累加设备中（为方便大家对比，我们把新添加的设备用绿色背景标出来）：

![image_1es0c34pi17trjnv1ls31i3i1jlj13.png-52.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40c5cc59da0c4244a3987791f3dacdd0~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1113&h=690&s=53511&e=png&b=fefefe)

如图所示，在添加了这个“智能”生成地址信号的设备之后，我们的双手又得到了一次解放。不过此时电路图中出现了两个寄存器，为了区分一下，我们把图左下方的那个用于生成地址信号的寄存器称之为`程序计数器`（英文名：Program Counter，简称PC），把图上方之前用于存放累加过程中间结果的那个寄存器称之为`累加器` （英文名：Accumulator，简称ACC）。

值得注意的是，`程序计数器`和`累加器`共享同样的CLK信号和同样的RST\_N信号。

之后就可以按照下边的步骤完成累加4个加数的目标（前提是这4个加数都已经事先存储到了RAM中）：

*   将RST\_N设置为逻辑0后再调整为逻辑1。
    
    此时`程序计数器`输出的地址信号为`00`，RAM的输出Dout就是第一个加数，也就是74，累加器的输出为0，ALU的输出就是74+0=74。
    
*   再将CLK信号从逻辑0调整到逻辑1后再调整为逻辑0。
    
    此时`程序计数器`输出的地址信号为`01`，RAM的输出Dout就是第二个加数，也就是29，累加器的输出就是上一步骤中ALU的输出，也就是74，现在ALU的输出就是29+74=103。
    
*   再将CLK信号从逻辑0调整到逻辑1后再调整为逻辑0。
    
    此时`程序计数器`输出的地址信号为`10`，RAM的输出Dout就是第三个加数，也就是32，累加器的输出就是上一步骤中ALU的输出，也就是103，现在ALU的输出就是32+103=135。
    
*   再将CLK信号从逻辑0调整到逻辑1后再调整为逻辑0。
    
    此时`程序计数器`输出的地址信号为`11`，RAM的输出Dout就是第四个加数，也就是20，累加器的输出就是上一步骤中ALU的输出，也就是135，现在ALU的输出就是20+135=155。
    

执行完上边几个步骤后，我们就可以在`8位输出设备`中读取到累加结果`155`的二进制形式了。

稍微总结一下，这个过程中需要我们人动手干的就是最初通过设置RST\_N来对各个寄存器做清零操作，然后只需要反复调整CLK信号就好了~

振荡器
---

### 周期和频率的概念

我们现在可以通过1位输入设备手动地将CLK时钟信号从逻辑0调整为逻辑1，之后再将其从逻辑1调整为逻辑0，假设该信号电压波形图是这样的：

![image_1e38ls7tt1v9gph0bemkgd1n1h9.png-6.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/defdf09f977b4d16ab3610dd7b99d775~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=447&h=180&s=6324&e=png&b=ffffff)

从图中可以看到，该信号维持在逻辑0或者逻辑1的时间长短并不相同，如果我们手拿秒表，然后每5秒（也就是让`t₁=t₂=t₃=...=5s`）按动一下1位输入设备的按钮，这样该信号随时间变化的示意图就长这样：

![image_1e38luk8sos5ele1ph44ga1essm.png-5.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/657543fc49314a95aa15df12419c5254~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=413&h=164&s=5251&e=png&b=ffffff)

如图所示，CLK信号发生了有规律的变化，具体就是在`t₃～t₄`时间段内该信号的变化方式和`t₁～t₂`时间段内相同，`t₅～t₆`时间段内该信号的变化方式和`t₃～t₄`时间段内相同，我们可以继续推导，该信号在`t₇～t₈`时间段内的变化方式也将和`t₅～t₆`时间段内相同，这样我们就说该信号发生了周期性变化。

我们可以把两个相邻的上升沿之间的时间间隔或者两个相邻的下降沿之间的时间间隔称之为该信号变化的一个周期（用大写的`T`表示），该信号的在某一个周期的变化方式和上一个周期的变化方式是相同的，如图所示：

![image_1e38mhlju1v3rrcc17st1q061i7a13.png-8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7a9385ae1454bf9a628f78b7fe735ff~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=356&h=195&s=8164&e=png&b=ffffff)

> 小贴士：  
>   
> 大家在仔细看看这个图，CLK信号有规律的一高一低，一高一低，一高一低... 有没有想起一个声音：嘀、嗒、嘀、嗒、嘀、嗒... 像不像钟表走动时发出的声响，我们之后用到的CLK信号将都是这种周期性变化的信号，所以它也被称为时钟信号～

我们每隔5秒调整一次CLK信号，每个周期内需要调整两次，所以一个周期的时间就是10s。那么一秒钟就相当于包含`1/10`，也就是`0.1`个周期，我们把周期的倒数也称为频率，单位为`赫兹`（英文缩写为：Hz），也就是说CLK信号变化的频率为`0.1Hz`。很显然，频率是一个代表信号在单位时间内周期性变化快慢的一个单位，频率越高，意味着信号周期性变化发生的越快，频率越低，意味着信号周期性变化发生的越慢。

CLK信号的周期也被称作时钟周期，本例中的时钟周期就是10s。如果我们提升手速，时钟周期缩短到0.2秒，那么CLK时钟信号变化的频率就提升到了`5Hz`，当然，这个频率对于人来说已经很快了（想想一秒钟要按动10次按钮，那是有多酸爽），如果想再快一点的话，就不得不借助机器的力量了。

### 振荡器

我们不停拨动的手指可以让CLK信号发生从逻辑0到逻辑1，再从逻辑1到逻辑0这样的周期性变化，人类非常懒，懒到连按动生成CLK信号的按钮都不想做，所以需要寻找一个可以自动生成CLK信号的设备～ 而反相器正好可以完成将逻辑0变为逻辑1、将逻辑1变为逻辑0的功能，我们看看把反相器的输出连接到它的输入会发生什么神奇的事情：

![image_1e3lp955otvumm11pfg1j44vj89.png-3.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2295e67da7d43a19bfc03af46644b9b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=278&h=143&s=3385&e=png&b=ffffff)

使用电路符号其实不是很直观，我们采用反相器的继电器实现来观察一下上述电路：

![image_1erj3aj3515fmfkf95k3ke7osm.png-41.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4c3726c199e430f8b876cc253cecf5e~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=619&h=660&s=42184&e=png&b=ffffff)

如图所示，现在A点的信号为逻辑0，经过反相器后得到Y点的信号为逻辑1，而A点和Y点又是通过导线连接，所以A点的信号马上也会变成逻辑１，如下图所示：

![image_1erj3pis51h4s15sm18nohlieai13.png-43.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd140265073467a93f90df2b455f0f9~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=598&h=689&s=44230&e=png&b=ffffff)

在A点的信号变为逻辑1后，经过反相器后，Y点的信号又变成了逻辑０，A点和Y点是通过导线连接的，所以A点的信号又跟着变为了逻辑0。所以Y点信号的变化过程就是：

    逻辑０ -> 逻辑1 -> 逻辑0 -> 逻辑1 -> ···
    

循环往复，无休无止，直到电池没电。我们把这种产生周期性变化信号的设备成为`振荡器`。图中的电路绕成了一个环，所以也可以被称作`环形振荡器`。

> 小贴士：  
>   
> 对于由继电器组成的非门来说，单个非门的输出连接到输入构成一个环形振荡器没啥问题，不过对于由pMOS管和nMOS管组成的CMOS反相器来说，基于物理方面的原因，一般使用3个或者3个以上并且是奇数个CMOS反相器串联起来，并且最后一个反相器的输出连接到第一个反相器的输入来构成环形振荡器。

这个环形振荡器特点是结构很简单，但是有一个致命的弊端：它的输出信号频率不能调节。比方说对于上图中使用继电器构成的反相器来说，在电池没电之前，Y点的信号就是一个周期性变化的信号，变化频率取决于继电器通电时将铁片吸下所需的时间以及继电器断电时铁片在弹簧的作用下回归原位的时间长短。后来科学家们利用石英晶体的压电效应来产生频率稳定并且可调节的周期性变化的信号。

> 小贴士：  
>   
> 啥是个压电效应我们就不唠叨了，怎样利用石英晶体产生稳定频率的时钟信号咱也不深入唠叨了，要不然又会打开一个学科的大门，然后深陷其中不可自拔，咱现在就把它当作黑盒子封装起来，知道某个设备可以产生频率稳定并且可调节的时钟信号就好了。

现在赶紧使用抽象大法，把这个振荡器封装起来：

![image_1erj4rnpe1ups1g251g64188snbu1g.png-8.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d37cecb2112d43e2beec18af110fb586~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=535&h=197&s=8454&e=png&b=ffffff)

下边就可以使用振荡器来替代手工生成CLK信号的1位输入设备了：

![image_1es0c8k2a3hji41samin6cg11g.png-42.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c82287bf29945ce8d6502cffc7fa247~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1158&h=680&s=43174&e=png&b=ffffff)

假设振荡器产生的电压波形图是这样的：

![image_1eroafgol1b4hdgd1tof15ttqsr2a.png-10.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e1e36de81474afdb3e00be1db1b61c4~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=920&h=306&s=10786&e=png&b=ffffff)

在初始时，我们先将复位信号RST\_N设置为逻辑0，这样程序计数器和累加器的输出就都清零了。之后在某个时刻，比方说t₀时刻将RST\_N设置为逻辑1，之后上述设备就可以自动运行了。为方便分析，我们规定：

*   把从t₀时刻到下一个CLK信号上升沿到来的时刻的时间间隔称为第0周期；
*   把从下一个CLK信号上升沿到来的时刻到下下个CLK信号上升沿到来的时刻的时间间隔称为第1周期；
*   把从下下个CLK信号上升沿到来的时刻到下下下个CLK信号上升沿到来的时刻的时间间隔称为第2周期;
*   ...

以此类推，还有第3周期、第4周期等等。其中，每个时钟周期只包含前一个上升沿，不包含后一个上升沿。如下图所示：

![image_1esc7gjcd1t61qad1lmp2l419cjp.png-26.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7563a71127e41ba80e08ae9f4f8a08d~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=817&h=356&s=27408&e=png&b=ffffff)

> 小贴士：  
>   
> 虽然从t₀时刻到下一个CLK信号上升沿到来的时刻的时间间隔不足一个时钟周期，但我们只关心RST\_N从逻辑0设置为逻辑1后发生的事情，所以就把第0周期定义为从t₀时刻到下一个CLK信号上升沿到来的时刻的时间间隔了。

对照着电路图，我们可以分析出在不同阶段，程序计数器（简称PC）、RAM、累加器（简称ACC）、ALU的输出都是什么：

阶段

PC输出（地址信号）

RAM输出

ACC输出

ALU输出

第0周期

0

74

0

74

第1周期

1

29

74

103

第2周期

2

32

103

135

第3周期

3

20

135

155

很显然在第3周期的时候，ALU的输出就是我们想要的结果。不过如果各位稍微思考一下就会发现一个天大的问题：这个电路停不下来！在第3周期结束、第4周期开始时，又一个CLK信号上升沿到来，程序计数器会继续自增。本例中我们采用的是2位加法器，当程序计数器的值到达3（也就是`11₂`）时，再加1的结果就是4（也就是`100₂`）。而使用2个二进制位是无法表示`100₂`的，所以会产生溢出现象，导致程序计数器会重新从0（也就是`00₂`）开始计数。随着更多CLK信号上升沿的到来，RAM中的加数会继续累加，ALU的输出不断增大（当然增大到一定程度也会发生溢出）。

这显然不是我们想要的结果，在RAM中的4个加数累加完毕后，我们就想让电路停止运行，继而从8位输出设备中读出结果。其实做到这一点也不难，只要在时钟信号进入第3周期后，让程序计数器和累加器接受到的CLK信号保持不变就好了（也就是让这些寄存器接收不到CLK信号的上升沿），这样所有寄存器输出的值保持不变，看起来相当于电路停止了运行。

我们引入一个HALT信号即可解决问题：

![image_1es0cbblgd8b4o79cpib81881t.png-44.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77268b50969c475bb92e334945bbdab3~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1126&h=691&s=45158&e=png&b=ffffff)

如图所示，我们在电路图中新增了一个两输入与门，该与门的一个输入信号为振荡器产生的CLK信号，另一个输入信号我们命名为HALT的信号（英文HALT翻译成中文就是“停止”的意思）。这样：

*   当HALT=1时，该与门的输出信号与CLK信号一致，也就是此时与不引入HALT信号的效果是一样的；
    
*   当HALT=0时，该与门的输出信号将保持为逻辑0不变，也就是说在HALT=0时，所有的存储设备接收到的时钟信号都为逻辑0，此时它们均不允许写入数据，相当于整个电路停止了下来。
    

很显然，我们在进入第3周期后就可以将HALT信号设置为逻辑0。可是问题是现在CLK信号并不是我们手动生成的，而是通过振荡器自动生成的，我们怎么知道现在已经进入第3周期了呢？这其实也好办，看程序计数器的输出就好了啊。程序计数器的输出是几，就意味着我们现在进入了第几周期。那我们就可以在初始时让HALT=1，直到程序计数器的输出为3（也就是二进制的11）时，让HALT=0即可。

接下来的问题就是我们怎么知道程序计数器的某个输出是不是等于3呢？这时就需要引入一个`比较器`来完成这个功能。还记得很久之前我们唠叨过的两输入异或门吗，它的真值表如下所示：

A（输入）

B（输入）

Y（输出）

0

0

0

0

1

1

1

0

1

1

1

0

那我们就可以根据异或门的输出信号来判断两个输入信号是否相同：

*   如果异或门的输出信号为逻辑0，那么两个输入信号是相同的。
*   如果异或门的输出信号为逻辑1，那么两个输入信号是不相同的。

不过人类的一般认知是逻辑0代表否定，逻辑1代表肯定，所以如果可以设计出满足下边功能的设备就更符合人类认知了：

*   如果该设备的输出信号为逻辑1，那么两个输入信号是相同的。
*   如果该设备的输出信号为逻辑0，那么两个输入信号是不相同的。

实现这个需求超简单的，直接在异或门后边添加一个反相器即可：

![image_1erqhik5k17hbbdb137t5dk1ch14b.png-10.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a10b505a46849d694de274520daa6fb~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=620&h=117&s=10981&e=png&b=fefefe)

其实这个设备有一个专门的名称：`同或门`（XNOR），并且有专门的电路符号，如下图所示

![image_1erqhiuu6qardoe167v1j94rft4o.png-10.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e2d71d583b94a81b395d71c418621c7~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=546&h=124&s=10420&e=png&b=fefefe)

使用同或门可以轻松比较两个1位二进制数是否相等，如果我们想比较两个n位二进制数的话，只需要使用n个同或门来分别比较这两个数的每一个二进制位。如果这两个n位二进制数相等的话，那么n个同或门的输出信号均为逻辑1，如果不相等的话，那么有的同或门的输出信号就可能为逻辑0。这时候将这n个同或门的输出信号作为一个n输入与门的输入信号，那么这个n输入与门的输出信号为逻辑1时，说明这两个n位二进制数相等，如果该n输入与门的输出信号为逻辑0时，说明这两个n位二进制数不相等，电路图如下所示：

![image_1erqii86f18jj16rh1n9utel7345l.png-31.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcb283b560c643a9aebb9d4a6013f633~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=758&h=373&s=31987&e=png&b=ffffff)

上图中的设备就是一个`比较器`，我们可以通过它的输出信号Y，来判断两个输入是否相等：

*   如果Y=1，则说明n位二进制数`An-1An-2...A₂A₁A₀`和`Bn-1Bn-2...B₂B₁B₀`是相等的；
*   如果Y=0，则说明n位二进制数`An-1An-2...A₂A₁A₀`和`Bn-1Bn-2...B₂B₁B₀`是不相等的。

我们再画一个简化的示意图表示一下`比较器`：

![image_1erqj7p8b1ah21ra1b999ai10d962.png-13.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b079d768e1524da199ff1f5f434aa3cc~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=604&h=192&s=13637&e=png&b=fefefe)

有了这个比较器之后，再回到我们的累加电路中来，我们只要将程序计数器的输出和一个固定的值3通过`比较器`比较，如果这两个值不相同，则将HALT信号置为逻辑1，否则置为逻辑0。我们可以这样修改累加电路图：

![image_1es0cf0tq1v2p4i712ff18tp5bg2a.png-48.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d7373317f04fb7b9beac5cb4acc79c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1159&h=693&s=49358&e=png&b=fefefe)

emmm... 这回美滋滋啦，只要在初始的情况下将程序计数器和累加器的输出都清零，然后电路在振荡器产生的CLK信号的推动下自动运行，直到程序计数器输出的值为3（也就是`11₂`）时，比较器得到输出信号为逻辑1，再经过反相器后得到的HALT信号为逻辑0，此时电路中的各个寄存器接收到的CLK信号均为逻辑0，电路停止运行，我们从8位输出设备上读出累加结果就好！赞~