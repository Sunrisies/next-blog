第21章、指令升级
=========

标签： 计算机是怎样运行的

* * *

操作数和操作码
-------

我们之前在计算第一个表达式`74 + 29 - 32 - 20`的值时，`指令RAM`和`数据RAM`中的数据分布情况如下图所示（当然后边可能还会有别的指令，不过我们目前只聚焦于下边这5个指令）：

![image_1et93rsaf1cvgvb81iku1b6i1pfp1g.png-17.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f9ef54be1c4e4f8ae4058b16c224a6~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=492&h=326&s=17769&e=png&b=fefefe)

如图所示，有的指令需要读取`数据RAM`中的数据，比方说`load`、`add`、`sub`等；有的指令需要向`数据RAM`中写入数据，比方说`store`。各个指令完成的任务如下所示：

*   地址为`0`的`指令RAM`对应的指令为load，它要完成的任务就是将`数据RAM`中地址也为`0`处的数据，也就是74加载到累加器。
*   地址为`1`的`指令RAM`对应的指令为add，它要完成的任务就是将`数据RAM`中地址也为`1`处的数据，也就是29与累加器中的数据相加，结果再存储到累加器。
*   ...
*   地址为`4`的`指令RAM`对应的指令为store，它要完成的任务就是将目前累加器中的数据，也就是之前指令的运算结果（也就是74 + 29 - 32 - 20的结果）写到`数据RAM`中地址也为`4`的地方。

从上边的叙述中我们可以看到，某个指令在`指令RAM`中的地址是什么，那么它需要访问（访问既可以是读取，也可以是写入）的数据在`数据RAM`中的地址也必须是什么。对于我们日常使用来说，这样子的规定不是不行，但是太僵化，也导致了我们不能重复利用`数据RAM`中的空间，是时候再继续改进一波了～

可否让指令所在`指令RAM`中的地址，与该指令所需访问的数据在`数据RAM`中的地址不必须一致呢？比方说在`指令RAM`的地址为`0`处存储的指令为`load`，那么在执行该指令时，可以指定将`数据RAM`中任意地址处存储的数据加载到累加器，而不一定是地址为`0`处的数据。

这样的话，我们就必须指定某个指令需要访问`数据RAM`中哪个地址对应的数据，所以需要将一条指令拆分成两个部分，我们可以分别把它们叫做`操作码`和`操作数`，就像这样：

![image_1e4l51vtu1tsq1k851e5hgft1es5m.png-8.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4433f94bbb8a4fed8a379102bedbfd34~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=316&h=165&s=9108&e=png&b=fefefe)

如图所示，`操作码`指的就是我们之前所描述的指令，它代表着这条指令将要执行什么操作，比方说操作码是`add`的话，意味要进行加法操作，如果操作码是`store`的话，意味着将要进行将数据从累加器中写入数据RAM的操作。`操作数`指的就是该指令将要访问`数据RAM`中的哪个地址处的数据。这样为了计算表达式`74 + 29 - 32 - 20`的值，`指令RAM`和`数据RAM`中的数据分布情况可以是这样：

![image_1et93t2l4eot10e6fe4132p1ut91t.png-19.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a161d50396d1423d98251d354c952e8f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=489&h=315&s=19547&e=png&b=fefefe)

如图所示:

*   `load 0`表示将`数据RAM`中地址为0处的数据加载到累加器；
*   `add 1`表示将累加器中的数据与`数据RAM`中地址为1处的数据相加后再保存到累加器；
*   `sub 2`表示将累加器中的数据与`数据RAM`中地址为2处的数据相减后再保存到累加器；
*   `sub 3`表示将累加器中的数据与`数据RAM`中地址为3处的数据相减后再保存到累加器；
*   `store 4`表示将累加器中的数据保存到`数据RAM`中地址为4的地方。

有点儿像脱了裤子放屁啊，和不区分操作码和操作数的时候完成的功能一样～ 其实如果我们改变一下某个操作码对应的操作数，那么事情就变得有意思了起来：

![image_1et93uvmd1u2f1b911t7b1t88pv2a.png-19.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f19b0872d1fe4ef7bd00f759f4626544~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=536&h=312&s=19593&e=png&b=fefefe)

如图所示:

*   `load 3`表示将`数据RAM`中地址为3处的数据加载到累加器；
*   `add 0`表示将累加器中的数据与`数据RAM`中地址为0处的数据相加后再保存到累加器；
*   `sub 1`表示将累加器中的数据与`数据RAM`中地址为1处的数据相减后再保存到累加器；
*   `sub 2`表示将累加器中的数据与`数据RAM`中地址为2处的数据相减后再保存到累加器；
*   `store 0`表示将累加器中的数据保存到`数据RAM`中地址为0的地方（也就是将`数据RAM`中原先地址为0的数据给覆盖掉）。

也就是说这个过程其实计算的是`20 + 74 - 29 - 32`的值（而不是`74 + 29 - 32 - 20`的值了），并将最终的计算结果存放到`数据RAM`中地址为0的地方。灵活性是不是大大提高了，而且还重复利用了`数据RAM`中地址为0的存储空间！

在我们目前的设计中，一个操作码需要4个二进制位表示，一个操作数（也就是RAM的一个地址）需要6个二进制位表示，也就是一条指令总共需要10个二进制位表示。不过我们目前使用的`指令RAM`的容量是`64×8`，也就是说指令RAM的输出是一个8位二进制数，为了方便起见，我们将其扩充为容量为`64×16`的`指令RAM`，就像这样：

![image_1e4n6mmae1dbpkii1v98522j3f16.png-23.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/489eb0d7a7644434ad615074deacfde0~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=623&h=224&s=24455&e=png&b=fefefe)

如图所示，`指令RAM`的输出就变为了一个16位二进制数。我们可以人为的规定前8个二进制位用于表示操作码（目前实际上只使用其中的4个二进制位），后8个二进制位用于表示操作数（目前实际上只使用其中的6个二进制位），如图所示：

![image_1et94gh361kjou3bef111eea6u2n.png-28.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45964da8cd5429db92f2193eb97fff9~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=967&h=328&s=29583&e=png&b=fefefe)

我们规划使用编号为8～15这8个二进制位作为操作码，不过目前的指令较少，实际只使用了编号为8～11这4个二进制位表示操作码；我们规划使用编号为0～7这8个二进制位作为操作数，不过目前最多支持64个地址，所以实际只使用编号为0～5这6个二进制位作为操作数。

现在一条指令分成了`操作码`和`操作数`两部分，我们就可以这样改造电路图了：

![image_1fk6d3git1gv41al11krv3vh1udt2r.png-59.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cc1b9946e9d47f68d92ca537dd7141b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1308&h=733&s=60552&e=png&b=fefefe)

与之前的电路图相比，我们做了如下修改：

*   `数据RAM`不再接收程序计数器的输出作为地址信号，而是将`指令RAM`输出的编号为0～5的二进制位（也就是指令的操作数）作为地址信号。
*   控制单元接收`指令RAM`输出的编号为8～11的二进制位（也就是指令的操作码）作为输入。

立即数
---

我们上边介绍的`操作数`指的是`数据RAM`的地址，也就是说在执行指令过程中，需要通过`操作数`所代表的地址到`数据RAM`中获取需要参与运算的数据，这是一个间接获取数据的过程。如果我们乐意的话，也可以在编写指令的时候直接将需要参与运算的数据作为`操作数`，这样的操作数也被称作`立即数`。当然这么描述可能不太直观，还是来举个例子吧。我们刚才计算表达式`20 + 74 - 29 - 32`的值时，`指令RAM`和`数据RAM`中的数据分布如下图所示：

![image_1e4njat5rbvq10gus451mnhnngm.png-19.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32138d961b8a4956bc5df4d8e59be6f4~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=514&h=262&s=19778&e=png&b=fefefe)

指令`load 3`、`add 0`、`sub 1`、`sub 2`、`store 0`中的`3`、`0`、`1`、`2`、`0`指的都是`数据RAM`中的地址，如果我们把这些间接定位数据的地址换成要直接操作的数据，就像是这样：

![image_1e4njgn2o19llklk1rpknc55b313.png-18.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9133147413734128891915b16191d491~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=512&h=271&s=19257&e=png&b=fefefe)

如图所示：

*   `load 20`就表示直接把数据`20`加载到累加器；
*   `add 74`就表示将累加器中的数据与74直接相加后再保存到累加器；
*   `sub 29`就表示将累加器中的数据与29直接相减后再保存到累加器；
*   `sub 32`就表示将累加器中的数据与32直接相减后再保存到累加器。

不过`store 0`表示的含义仍然不变，就是将累加器中的数据保存到`数据RAM`中地址为0的地方。这样`20`、`74`、`29`、`32`就代表立即数。

大家可以看到，引入立即数的好处就是指令看起来更加直观，并且我们不再需要将数据先输入到`数据RAM`，然后再到`指令RAM`的操作数中填入这些数据所对应的地址。不过这里边儿有一个巨大的问题，我们怎么知道一条指令中的操作数是一个地址还是一个立即数呢，比方说我们怎么知道`load 20`中的`20`是一个立即数还是一个地址呢？我们不知道！所以有必要将操作数为RAM地址的指令和操作数为立即数的指令区别开来，如下表所示：

指令名称

指令的二进制形式

指令的十进制形式

描述

add\_m

0000

0

加法，操作数为地址

sub\_m

0001

1

减法，操作数为地址

and\_m

0010

2

按位与，操作数为地址

or\_m

0011

3

按位或，操作数为地址

halt

0100

4

停止执行

store

0101

5

向数据RAM中写入数据（操作数为地址）

load\_m

0110

6

将数据RAM中的数据加载到累加器中，操作数为地址

jmp

0111

7

跳转到某条指令执行（操作数为地址）

je

1000

8

如果上次ALU运算结果为0，就跳转到某条指令执行（操作数为地址）

add\_i

1001

9

加法，操作数为立即数

sub\_i

1010

10

减法，操作数为立即数

and\_i

1011

11

按位与，操作数为立即数

or\_i

1100

12

按位或，操作数为立即数

load\_i

1101

13

将一个立即数加载到累加器中

可以看到，如果我们在add、sub、and、or、load这些运算或者加载指令后边添加了`_m`后缀，就意味着该指令的操作数是一个地址，如果我们在指令后边添加了`_i`后缀，就意味着该指令的操作数是一个立即数。另外需要注意的是，我们实际支持6条地址线，我们只使用指令中的0～5位表示地址操作数；而对于立即数操作数来说，指令中的0～7位都可以用作立即数操作数。

> 小贴士：  
>   
> 目前halt、store、jmp、je指令不需要后缀，store、jmp、je指令的操作数必定是一个地址（store指令要指明将累加器的数据写到数据RAM的哪个地址处，jmp和je指令要指明需要跳转到指令RAM的哪个地址处的指令执行），halt指令不需要操作数。

当然，引入了立即数的概念之后，我们也要相应的改造一下电路图：

![image_1fk6d4a2h19011qd0juuhda108438.png-70.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c3d1938f604dffad05017b8b8d27c6~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1282&h=773&s=72002&e=png&b=fefefe)

如图所示，我们在ALU的输入B前边加了一个2-1选择器，该2-1选择器的控制信号ALU\_B\_SEL由控制单元生成：

*   当执行以\_m为后缀的指令时，控制单元生成的ALU\_B\_SEL为逻辑0，那么采用`数据RAM`的输出作为ALU的输入。
*   当执行以\_ｉ为后缀的指令时，控制单元生成的ALU\_B\_SEL为逻辑1，那么采用立即数作为ALU的输入。

完美解决！