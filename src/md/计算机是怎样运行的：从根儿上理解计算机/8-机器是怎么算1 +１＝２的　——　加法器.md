第9章、加法器
=======

标签： 计算机是怎样运行的

* * *

使用逻辑门实现加法
---------

### 半加器

想必各位都是从小孩子一路长大的吧，谁还没有个掰着手指头算`3+5`等于几的历史呢～ 不过长大之后我们可以不用掰着手指头算了，貌似可以直接得到`3+5=8`的结论，为啥呢？这是因为下边这个加法表已经深深的刻在了我们脑子里：

![image_1dnen2himad81ot41uiq1ctpmmb9.png-104.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a776c901f74c8c83fb98e54bfb5288~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=807&h=519&s=106608&e=png&b=fefefe)

上图是针对于十进制数字的加法表，如果对于二进制来说，因为只有2个符号来代表数值，加法表就应该长这样：

![image_1dnenf6d11g3nkpvujj9ih1fjtm.png-24.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6856317e8aa8461bb8e87f848dad2554~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=372&h=245&s=25227&e=png&b=fefefe)

哇唔，好简单喔。不过对于这个二进制加法表来说，有一个地方需要注意一下，就是在计算`1+1`的时候，需要2个二进制位来表示结果，我们把结果中左边的那个位称之为进位，右边的那个位称之为加法位，那么对于`1+1`这种情况来说，它的结果的进位就是`1`。其实其他的情况下我们也可以使用2个二进制位来表示结果，只不过进位为0罢了。我们修改一下二进制加法表的形式：

![image_1dner8mos140e1qq47a7fps16ul3m.png-31.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbe238efde204f1d8ced6bceaa118552~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=429&h=293&s=32099&e=png&b=fefefe)

假设`A`、`B`分别代表仅有1位的二进制数，那么`A+B`可能的情况就有4种，我们画个表格表示一下：

![image_1duepguku157agqb131k0b1eab37.png-43.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d68f869cffa047ccb47040a77bf19373~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=514&h=228&s=44715&e=png&b=fdfafa)

奇妙的事情发生了，这个表格看的有点儿眼熟啊，好像在之前的某个地方见过。仔细想想，这玩意儿不就是两输入逻辑门的真值表么～ 其中：

![image_1dueplfp41bs9i7l11sg1uiv1uka3k.png-92.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c34ef80715c4bc0af00781a8e7ece83~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=745&h=483&s=94321&e=png&b=fffefe)

也就是说我们可以让：

*   `A`和`B`作为与门的输入，那么该与门的输出就代表进位的值。
*   `A`和`B`作为异或门的输入，那么该异或门的输出就代表加法位的值。

对应的电路图就长这样：

![image_1eq7249d582u1i5u117ps1o1b549.png-18.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c146117165440ada3773d59e5159b05~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=625&h=320&s=19036&e=png&b=ffffff)

当然，为了简单起见，我们决定把这个电路装到一个盒子里，只露出输入和输出的连接线，就像这样：

![image_1eq72io0juu8q22g6o2bv1o38m.png-7.5kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66345dc0aa3640488aae272c5f40fb47~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=584&h=176&s=7674&e=png&b=ffffff)

我们把方框里边的那个电路称之为`半加器`（Half Adder），以后我们就使用上图中的电路符号来代表`半加器`，而不用关心内部是如何实现的了（又一层抽象哈）。

### 全加器

遗憾的是，在采用半加器解决两个二进制数的加法运算问题时，加数必须是由单个二进制位组成的（加数必须是0或者1）。而我们平时所做的加法运算中，各个加数都可能包含多个二进制位，比方说这样：

    11010111 + 10010001
    

上边的例子中每个加数都包含8个二进制位。对于这种包含多个二进制位的加数相加的场景，我们可以将两个加数权重相同的位对齐，从权重最低的位开始相加，逢2进1，直到所有的位相加完毕。对于上边的例子来说，将加数的各个位对齐之后：

*   先计算权重最低的位之和，就像这样：
    
    ![image_1duelb5hjj721nf89a41m241lf61g.png-19.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53046e57c9ac414ab863a2c5fedfa66a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=436&h=166&s=19626&e=png&b=ffffff)
    
    我们在前边介绍二进制数的时候说过，我们规定最右边的那个二进制位为第0位，之后沿着从右向左的方向依次是第1位、第2位、...。两个加数中权重最低的位自然是第0位，两个加数的第0位的值分别是`1`和`1`，我们计算`1 + 1`的值，得到的加法位就是`0`，进位为`1`。
    
*   接着计算两个二进制加数的第1位的和，就像这样：
    
    ![image_1duelice5i2uqkug11cqngb01t.png-20.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ecf6445768e4409b35a5b6cd9f8b932~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=445&h=176&s=21447&e=png&b=ffffff)
    
    两个加数的第1位的值分别是`1`和`0`，当然还需要考虑上一步骤中的进位，也就是说我们需要计算`1 + 0 + 1`的值，得到的加法位就是`0`，进位为`1`。
    
*   依次类推，直到所有的位相加完毕，得到的结果就是这样：
    
    ![image_1dueln6jd12hmbckcsurjd15bm2a.png-22.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c46994c94c144abbf0b52a4a8edfca5~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=442&h=160&s=22639&e=png&b=ffffff)
    

现在重新思考上边的计算过程，在计算两个加数权重最低的位，也就是从右往左数的第1列二进制位相加时，我们可以直接使用前边已经唠叨过的`半加器`来获得对应的加法位输出和进位输出，可是对于其他位置的位相加时，不能单纯的使用`半加器`了，这是因为要考虑上一列二进制位相加的进位，其实本质上我们需要一个可以计算3个二进制位相加的机器，也就是说我们期望有下边电路结构（图中的`Cin`表示上一列二进制位相加的进位）：

![image_1eq74etpikn1g45bfjgh91tlf13.png-20.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4926aba9d1f491e9acaf7b895be6642~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=877&h=246&s=21083&e=png&b=ffffff)

接下来的任务就是思考一下图中的电路黑盒该如何实现了。`A`、`B`、`Cin`这三个输入都可能取0或者1，所以总共的输入情况共有8种，我们把每一种输入情况下产生的进位输出`Cout`和加法位输出`S`列一个表格：

![image_1duerv3jvba1q616uf1ae314et4r.png-74.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5386c1409f8144109a9cd07ba5c341bb~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=535&h=415&s=76727&e=png&b=fffdfd)

熟悉的配方，熟悉的味道，我们可以针对输出`Cout`做一个三输入逻辑门，再针对输出`S`做一个三输入逻辑门。比方说对于输出`Cout`来说，在`Cin=0, A=1, B=1`、`Cin=1, A=0, B=1`、`Cin=1, A=1, B=0`、`Cin=1, A=1, B=1`四种情况下的输出为1。那么我们可以：

*   先做一个只有在`Cin=0, A=1, B=1`时输出才为1的设备，就像这样：
    
    ![image_1eq74qv671p4m1c5h147gnh96fc2d.png-7.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c0a7bf3cbf74fcf92c9ee8cbce076e3~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=567&h=148&s=8086&e=png&b=fefefe)
    
*   再做一个只有在`Cin=1, A=0, B=1`时输出才为1的设备，就像这样：
    
    ![image_1eq74qkef1h9cd2jov91ck218e520.png-7.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b523bf6110e4ff894f4aced5f91986a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=564&h=145&s=7870&e=png&b=fefefe)
    
*   再做一个只有在`Cin=1, A=1, B=0`时输出才为1的设备，就像这样：
    
    ![image_1eq74si4p1sms1l771q0h1nid6as37.png-7.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f20c924647d14389a80c507ef34ef2f6~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=569&h=151&s=8046&e=png&b=ffffff)
    
*   再做一个只有在`Cin=1, A=1, B=1`时输出才为1的设备，就像这样：
    
    ![image_1eq74t4ig10tr1ps612hu1o63ki03k.png-7.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e653d43bf56940a597430cfe11f01803~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=566&h=147&s=7287&e=png&b=ffffff)
    
*   上述四个设备产生的输出作为一个四输入或门的输入：
    
    ![image_1eq7536ij16n33kv1r7eb5n10eh41.png-41.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9fe2e6210284008966f538f990afd44~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1247&h=628&s=42062&e=png&b=ffffff)
    
    通过上图中的设备我们就可以顺利地生成`Cout`信号。
    

我们也可以通过类似的手段来实现生成`S`信号的电路，从而实现我们想要的电路黑盒。当然，除了这种直接通过输入与输出的真值表来实现期望的电路黑盒的方式以外，我们还可以使用我们之前设计的`半加器`来实现这个电路黑盒。三个单独的二进制位相加的计算过程肯定是先计算其中两个二进制位相加的和之后再和第三个二进制位相加，我们看一下计算步骤：

1.  做第一次加法：先对A、B这两个二进制位做加法运算，我们把这次加法得到加法位和进位分别称作`S₁`和`CO₁`，如图所示：
    
    ![image_1duetot54esu1pe1eha1gjjcl18s.png-4.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36ba6df3bbd048f094b9637e72ef927d~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=223&h=162&s=4702&e=png&b=ffffff)
    
2.  做第二次加法：把上一步算出来的加法位`S₁`和进位输入`Cin`相加，我们把这次加法得到的加法位和进位分别称作`S₂`和`CO₂`，很显然`S₂`就是这三个二进制位加法运算的最终加法位，如图所示：
    
    ![image_1duetqngckfn4a3epib41p669p.png-4.8kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0728acf9f010440383601320719a9e7f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=219&h=152&s=4946&e=png&b=ffffff)
    
3.  接下来需要将`CO₁`和`CO₂`相加一下，不过`CO₁`和`CO₂`肯定不会同时为1，不信我们分析一下：
    
    *   如果`CO₁`为`1`的话，说明`A`和`B`的值均为`1`，那么它们相加产生的加法位`S₁`肯定为`0`，那么不管进位输入`Cin`是什么，`Cin`与`0`相加产生的加法位`S₂`的值就是`Cin`自己，进位`CO₂`肯定是`0`。
        
    *   如果`CO₂`为`1`的话，说明`S₁`和进位输入`Cin`均为`1`，如果此时`CO₁`的值也为`1`的话，那就意味着`A`和`B`相加的结果是二进制数`11`，而我们知道这是不可能的。
        
    
    综上所述，`CO₁`和`CO₂`的值不可能同时为`1`。那么：
    
    *   如果`CO₁`和`CO₂`均为0，那么它们的和也为0。
    *   如果`CO₁`和`CO₂`中有一个为1，那么它们的和就是1.
    
    什么样的两输入逻辑门在两个输入均为0的时候输出是0，在两个输入有一个为1时输出为1呢？很显然或门是符合这个要求的。也就是说我们让`CO₁`和`CO₂`作为一个或门的输入即可得到进位输出`Cout`。所以最终的电路结构就如下图所示：
    
    ![image_1eq77733acro1s82rrikaai3l4e.png-25.4kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a204587ba5c1491aba53eeedd269123c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1016&h=274&s=26045&e=png&b=ffffff)
    

不论是采用直接根据真值表实现，还是采用`半加器`实现，我们都把这个期望的电路黑盒实现了，太烦了，赶紧使出`抽象`神器，把那一大坨逻辑门和线路装到盒子里，只露出输入和输出的连接线，就像这样：

![image_1eq7784aj11541mqo1elq16lhluq4r.png-8.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c72073be28341dbaf4c474c6767effc~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=597&h=174&s=8857&e=png&b=ffffff)

我们把方框里边的那个电路称之为`全加器`（Full Adder），以后我们就使用上图中的电路符号来代表`全加器`，而不用关心内部是如何实现的了。

### 处理多个位的加法

还是拿这个加法运算做例子：

        11010111
    +   10010001
    

这个加法运算的每一个二进制加数都包含8个位，如果我们想用`全加器`来计算它们的和，那就需要八个步骤：

1.  先分别取出两个二进制加数第0位作为全加器的输入`A`和输入`B`，此时的进位输入`Cin`为`0`，得到加法位输出`S₀`和进位输出`C₀`。
    
2.  再分别取出两个二进制加数第1位作为全加器的输入`A`和输入`B`，将上一步骤的进位输出`C₀`作为本次运算的进位输入`Cin`，得到加法位输出`S₁`和进位输出`C₁`。
    
3.  类似的，两个二进制数的第2位相加，得到加法位输出`S₂`和进位输出`C₂`。
    
4.  类似的，两个二进制数的第3位相加，得到加法位输出`S₃`和进位输出`C₃`。
    
5.  类似的，两个二进制数的第4位相加，得到加法位输出`S₄`和进位输出`C₄`。
    
6.  类似的，两个二进制数的第5位相加，得到加法位输出`S₅`和进位输出`C₅`。
    
7.  类似的，两个二进制数的第6位相加，得到加法位输出`S₆`和进位输出`C₆`。
    
8.  类似的，两个二进制数的第7位相加，得到加法位输出`S₇`和进位输出`C₇`。
    

然后我们只需要将各个步骤的加法位输出按照从大到小的顺序排列，并将第8步的进位输出`C₇`作为最高位就可以得到最终的加和结果：

    C₇S₇S₆S₅S₄S₃S₂S₁S₀
    

累不累呀～ 累！能用机器做的事儿就让机器做吧！总结一下上边除步骤1以外的其他步骤都有一个共同的操作：将上一步骤的加法产生的进位输出作为本次加法的进位输入。假设我们现在要计算两个8位二进制数的和，这两个8位二进制数分别是`A₇A₆A₅A₄A₃A₂A₁A₀`、`B₇B₆B₅B₄B₃B₂B₁B₀`，其中`An`和`Bn`（n是`0~7`之间的整数）分别代表一个二进制位。我们很容易可以画出下边的电路图（为了达到更好的观赏效果，我们觉着把`全加器`竖着放更好看一点）：

![image_1eq7c3ola12augrq1hl512rlpqq58.png-27.7kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc384077dbd140e4bf5f49fe1258a7d2~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1559&h=337&s=28383&e=png&b=ffffff)

我们按照从右往左的顺序看这个电路图，这是一个解决8位二进制数加法的电路图。初始的时候进位输入为0，然后每一位相加的进位输出当作高一位相加的进位输入，`C₇S₇S₆S₅S₄S₃S₂S₁S₀`就是最后的加法结果。

> 小贴士：  
>   
> 有没有同学注意到我们在处理A₀和B₀这两个二进制位加法的时候采用的不是半加器，而是全加器。其实在这个场景中采用半加器是完全足够的（因为A₀和B₀相加时的进位输入一直是0），这里采用全加器其实是为了解决减法问题而埋的一个伏笔，大家稍安勿躁，等我们唠叨完如何解决减法问题的时候大家就知道此处的妙用了。

我们简化一下上边的图，下图中`Cout`代表最高位全加器的进位输出`C₇`，初始的进位输入`Cin`恒为0：

![image_1eq7cmebi1d8jie21rpc9t024d5l.png-14kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14fb237c2fa04c0892c8b1cd787f000e~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=794&h=314&s=14366&e=png&b=ffffff)

但是这个图还是太复杂了，继续简化一下。现在我们假设`A`、`B`是两个8位二进制数，分别代表`A₇A₆A₅A₄A₃A₂A₁A₀`、`B₇B₆B₅B₄B₃B₂B₁B₀`，`S`代表最终的输出结果`S₇S₆S₅S₄S₃S₂S₁S₀`，那么简化后的电路图就长这样：

![image_1eq7d6it8nh91gp9sfj17gqs7i62.png-30.2kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a46c55eac264557bf5480413b1887e7~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=832&h=591&s=30898&e=png&b=ffffff)

在这里需要提醒大家注意一下，上图中的输入`A`、输入`B`和输出`S`不是代表着单个二进制位，而是代表着8个二进制位，所以我们在图中故意加粗了连接线，并在线上画了一个斜杠，而且在斜杠的旁边标记了数字`8`，意味着这条加粗的线其实是用来代表8根独立的线，用来传播8个独立的信号。为方便起见，我们把上边的这个电路也叫做`8位加法器`，之后我们就不会再去讨论这个`8位加法器`是怎么实现的了，只需要知道这个`8位加法器`的功能就好了。

当然，为了通用起见，我们也可以设计处理`n`位（n是大于0的整数）二进制数加法的加法器（只需要串联n个`全加器`就好了），一个更通用些的`n位加法器`的示意图就如下所示：

![image_1fd9i1ptk1c2fqd116de2131m9.png-14.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ec0a7a40d97439f9147840c72e2ec4c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=583&h=398&s=14997&e=png&b=ffffff)

画成水平方向的也可以，如下所示：

![image_1eq7egm2m1lk91vfs12tqshq5qtm.png-14.9kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a9345bb485844fe8bb21f046ab936b0~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=538&h=380&s=15282&e=png&b=ffffff)

> 小贴士：  
>   
> 我们刚刚实现的这个加法器是通过将一堆全加器串联起来，某一个全加器的进位输出作为下一个全加器的进位输入来实现多位二进制数之间的加法的，我们把采用这种实现的加法器称为行波进位加法器。行波进位加法器的劣势就是随着二进制加数的位数变多，就需要更多个全加器串联起来，信号必须依次通过各个全加器，信号每通过一个全加器都会有一个传输延迟时间，串联起来的全加器越多，信号通过所有全加器的传输延迟时间就越长。不过聪明的人类也发明了加法器的别的实现，比方说先行进位加法器、前缀加法器等，有兴趣的同学可以去搜索一下，我们这里就不深究了，大家以后只需要把加法器当作一个黑盒对待，清楚它的功能就好（顺便再说一句，这就是抽象的好处，只在乎黑盒提供的功能，而不在乎黑盒具体是如何实现的）。

### 溢出

在现实世界中，我们可以使用任意个数的二进制位来表示数字，不过如果将二进制位映射到信号线上，由于信号线的个数有限，所以我们只能使用固定个数的信号线来表示数字，这也就意味着我们只能使用固定个数的二进制位来表示数字。为方便起见，我们在使用固定个数的二进制位表示的数字时，将最左边的那个二进制位，也就是权重最高的那个二进制位称为`最高有效位`，把最右边的那个二进制位，也就是权重最低的那个二进制位称为`最低有效位`。

如果我们规定最多使用8个二进制位表示数字，那么两个8位二进制数相加之后产生的结果也需要由8个二进制位来表示。视角回到上边介绍的`8位加法器`，两个8位二进制数A、B分别代表`A₇A₆A₅A₄A₃A₂A₁A₀`、`B₇B₆B₅B₄B₃B₂B₁B₀`，它们相加的结果就是：`C₇S₇S₆S₅S₄S₃S₂S₁S₀`，如果我们现在规定只能使用8个二进制位来表示数字，那只能把两个加数的最高有效位相加时的进位输出`C₇`给舍弃掉，单纯使用`S₇S₆S₅S₄S₃S₂S₁S₀`来表示加和结果。那么：

*   当进位输出`C₇`的值为`0`时，舍弃就舍弃了，并不会改变结果的大小。
    
*   当进位输出`C₇`的值为`1`时，舍弃时就相当于将最终的结果减去了`28`，我们就称此时的加法运算发生了`溢出`。
    

现在如果我们规定使用8个二进制位表示数字，能表示的二进制数范围就是：`00000000₂~11111111₂`，也就是：`0~28-1`，如果两个8位二进制数相加的结果大于`28-1`，那么最终的结果是无法用8个二进制位来表示的，此时就会发生溢出现象。比方说二进制数`11010111₂`（十进制形式：215）和`10010001₂`（十进制形式：145）相加：

      11010111
    + 10010001
    ------------ 
     101101000
    

得到的结果是`101101000`，不过很无奈，现在只能使用8个二进制位表示数字，那结果自然就成了`01101000`（十进制形式：104），此时便发生了溢出。

更一般的，如果我们使用n个二进制位表示数字，能表示的数值范围就是`0~2n-1`，如果两个n位二进制数相加的结果大于`2n-1`，那么最终的结果是无法用n个二进制位来表示的，此时就会发生溢出。