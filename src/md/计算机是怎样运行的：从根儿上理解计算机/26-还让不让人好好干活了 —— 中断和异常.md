第27章、中断和异常
==========

标签： 计算机是怎样运行的

* * *

外部中断
----

我们看一下下边两个问题：

*   狗哥和猫爷分别写了一个程序，他们的程序都想在CPU上运行。狗哥的程序大概需要3个小时才能运行完，猫爷的程序大概要5个小时才能运行完。此时我们能做的就是先等狗哥的程序运行完，然后再执行猫爷的程序。
    
    很显然这个过程对猫爷很不公平，凭什么自己的程序要等别人的程序运行完了才能运行呢？如果狗哥写的是一个游戏程序，那么用户不主动关闭程序的话就永不停止，那猫爷的程序岂不是永远都不能运行了？
    
*   对于CPU来说，I/O设备的速度是很慢的，CPU想访问I/O设备时，只能依靠`轮询`的方式查看I/O设备是否准备好，在轮询时CPU是不能去做别的事情的，这是对CPU的一种浪费。
    

之所以有上述的两个问题，是因为在我们目前的设计中，CPU拥有牢牢的主动权，即CPU主动的从主存中取指令和数据并执行指令，CPU主动的从输入设备中读数据也主动的将数据写入到输出设备，在整个执行程序的过程中，外部设备并不会打断CPU的工作。如果外部设备能够打断CPU的工作，那上边两个问题可以很容易的解决：

*   我们可以在CPU外部做一个计时器，可以规定每当过多少个时钟周期就打断CPU一下，CPU在收到外部的打断信号后，就先不执行当前正在执行的程序，转而去执行另一个程序去。这样的话，狗哥和猫爷的程序就可以轮着被CPU执行。
    
*   当I/O设备准备好数据后，主动通知CPU，CPU可以先暂停下手头的事情去处理外部设备的通知，等处理完了再回去做原先的事情。
    

这个外部设备打断CPU的正常执行流程的机制被称作`中断机制`，外部设备打断CPU的通知被称作`中断请求`，产生`中断请求`的设备也可以被称作`中断源`。当CPU执行完当前正在的指令后，会检测有没有外部设备给自己发送中断请求，如果有的话，可以跳转到所谓的`中断服务程序`。我们可以自己编写自己的中断服务程序，比方说CPU收到的是计时器中断的话，可以让CPU跳转到猫爷的程序执行；如果收到的是键盘中断的话，可以将按键值存储到某个地方，然后再返回到中断发生之前的下一条指令继续执行原程序。

软件中断
----

我们在写和I/O设备打交道的程序时候需要注意很多问题，比方说我们想让显示器显式一些字符，我们得考虑写入的字符展示在显示器的哪个位置，还得考虑如果写的字符多了应该让显示器的文字如何翻滚，还有许许多多的细节需要考虑，这是在每一个程序员进行编程时都会遇到的问题。为了方便广大程序员，我们可以把和硬件打交道的程序都事先写出来，后续的程序员只需要跳转到相应的指令地址去执行就好了。这些事先写好的和硬件打交道的程序也被称作`操作系统`（当然，操作系统还有别的很多功能），我们自己写的程序也被称作`用户程序`。

每当用户程序需要使用到操作系统提供的某些功能的话，就需要先跳转到操作系统程序的某个地址处。可是操作系统会不断的升级换代，它的程序也会不断的修改，每个功能的入口地址可能一直都在变，这就意味着每次更新操作系统后，用户程序也需要跟着调整，这是十分不方便的！

此时我们可以引入一种软件中断指令，当CPU执行到软件中断指令时，CPU会跳转到相应的中断服务程序。操作系统可能提供若干种不同的功能，每个功能可以被编一个号，比方说0号功能，1号功能等等，我们在使用软件中断指令时，可以将想要使用的操作系统功能编号写在某个寄存器或者存储单元中，甚至可以直接写在指令的操作数中，这样在中断服务程序中就可以知道应该跳转到哪个功能对应的地址处去执行。用户程序采用软件中断的这种形式去使用操作系统提供的功能也被称作`系统调用`，`系统调用`的概念在我们讲解操作系统时将会频繁用到。

> 小贴士：  
>   
> 操作系统并不神秘，当我们了解了CPU的运行原理之后就可以着手去编写纯软件的操作系统了，有了操作系统，才能让程序员更简洁的编程。不过那是另一本书的事情了，大家可以小期待一下~

异常
--

我们软件程序员编写的程序在执行过程中可能遇到很多意外情况，比方说：

*   我们使用了一个未定义指令。
*   算术操作指令（比方说add、sub）发生溢出
*   在支持除法指令的CPU中除数为0

当然还有很多意外情况，我们就不一一列绝了，这些意外情况统称为`异常`。当异常发生时，CPU应该暂停目前正在执行的程序，转而去执行所谓的`异常服务程序`，如果异常能在`异常服务程序`中修复，则返回原程序继续执行发生异常的那条指令，如果不能修复，那就终止程序就好了。

CPU的异常处理
--------

不论是外部中断、软件中断还是异常，CPU的处理方式都是一样的，我们统称为CPU的异常处理，处理方式大致分为2步：

*   在取指前先检测一下有没有发生外部中断、软件中断或者异常，如果发生了，需要跳转到中断服务程序或者异常服务程序去处理。
    
    *   对于外部中断来说，每一个外部中断源都可以有一根中断信号线与CPU相连，我们可以规定当中断信号线为逻辑1时，表示有中断产生。当然，CPU也可以选择处理或者不处理某个外部中断，所以需要引入一个`中断屏蔽寄存器`，如下图所示：
        
        ![image_1fc4t8vmdq612uaqct1691dda9.png-40.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8231531b2a8841afa7c46afbaf4c9627~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=896&h=715&s=41237&e=png&b=fefefe)
        
        上图中共画了IRQ0、IRQ1、IRQ2、IRQ3（IRQ是Interrupt Request的缩写）四个中断请求。相应的，`中断屏蔽寄存器`包含4个二进制位，与中断请求一一对应。 `中断屏蔽寄存器`的值可以通过专用的指令进行设置（我们并未实现这种指令），当CPU不想处理某个中断请求时，可以将中断屏蔽寄存器相应的二进制位设置为逻辑1。
        
        上图中还引入了一个用于保存中断信号的寄存器，这是因为CPU在跳转到中断处理程序后，需要知道到底是谁引起了中断。
        
        另外还引入了一个保存是否允许中断的寄存器，当该寄存器的值为1是，表示CPU会处理中断请求，否则CPU不会处理中断请求。该寄存器的值也可以通过专用的指令进行设置（我们并未实现这种指令）。
        
        上述装置会生成一个OUTER\_INT信号，如果OURTER\_INT=1表示有外部中断产生，在取指时就需要跳转到中断处理程序去处理。
        
    *   对于软件中断来说，我们需要设计专用的中断指令来支持软件中断。我们可以通过修改控制单元，让控制单元可以识别该指令是否是软件中断指令，如下图所示：
        
        ![image_1fc5h69811c8j1f4a1s029p819op.png-11.3kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5a2025d0d464a158d5290fe88a4e64c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=807&h=219&s=11619&e=png&b=ffffff)
        
        如果INT\_INS=1时，表明该指令是软件中断指令，否则不是。在取指时如果INT\_INS=1就需要跳转到中断处理程序去处理。
        
    *   对于异常来说，有各种各样不同的异常可能发生，我们需要分别设计相应的硬件去处理，这里以使用未定义指令的异常为例来唠叨一下。我们可以通过修改控制单元，让控制单元可以实别某个指令是不是未定义指令，如下图所示：
        
        ![image_1fc5i4ctu1toe3fr1puh30k1q2u26.png-12.6kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1824182a58bf476f9b4a16df00c0aba9~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=909&h=195&s=12900&e=png&b=ffffff)
        
        如果UNDIFINED\_INS=1时，表明该指令是未定义指令，否则不是。在取指时如果UNDIFINED\_INS=1就需要跳转到异常处理程序去处理。
        
    
    上边的叙述解决了发生中断或异常时要不要跳转的问题，下边应该解决跳转到哪里的问题。外部中断、软件中断和异常发生后跳转到的指令地址可以是不同的，也可以是相同的，这取决于我们的设计。比方说我们想让它们跳转到不同的地址：
    
    *   当发生异常时，也就是当UNDEFINED\_INS=1时，让程序跳转到地址为30处执行。
    *   当发生软件中断时，也就是当INT\_INS=1时，让程序跳转到地址为40处执行。
    *   当发生外部中断时，也就是当OUTER\_INT=1时，让程序跳转到地址为50处执行。
    *   否则按照正常的执行流程执行
    
    那么我们可以这样设计电路：
    
    ![image_1fc62hvdp3bto8m1co4g6p0u9.png-23.1kB](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4df97099f8ca4966b311a5c8ddc4b8fc~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=930&h=286&s=23650&e=png&b=ffffff)
    
    如上图所示，new\_pc就是CPU下一条要执行的指令地址。
    
*   当中断服务程序或者异常服务程序执行完后，需要返回到原程序继续执行。
    
    我们需要搞清楚返回到原程序时，返回的地址是个啥。
    
    *   对于外部中断来说，CPU只会在当前指令执行完成后，在读取下一条指令前才会判断有没有外部中断发生，那么在中断服务程序执行完成后，需要跳转到原先正常执行流程的下一条指令。
        
    *   对于软件中断来说也一样，需要跳转到原先正常执行流程的下一条指令。
        
    *   对于异常来说，有些异常不可恢复，比如执行到未定义指令，此时应该在异常处理程序中停止程序的执行，有些异常可以恢复，比方说缺页异常，此时执行完异常处理程序后应该跳转到原先正常执行逻辑的原指令继续执行。
        
    
    > 小贴士：  
    >   
    > 缺页异常是引入操作系统后才会出现的一个概念，等我们之后唠叨操作系统的时候再详细讲述。
    
    很显然，不论发生中断还是异常，在跳转到相应的服务程序前都需要保存一下执行完服务程序后需要恢复到的地址，这里的硬件我们就不实现了。
    

为了更好的理解中断和异常，我们可以举个通俗的例子。就像你在图书馆正在好好学习，忽然狗哥约你一起去嘘嘘，你和狗哥嘘嘘完之后需要再回到原先的座位，从原来写的上一个字开始继续往下写，这就是一种中断场景；如果你正在写某个字的时候忽然笔没有水了，你得先去楼下小卖铺买根笔，再回到原先的座位上把之前没写完的字写完，这就是一种异常场景。中断和异常是CPU的一种非正常执行逻辑，在CPU进行异常处理时，还需要特别注意两个事情：

*   当进入中断服务程序或异常服务程序时需要注意“保护现场”。
    
    所谓的“现场”指的是执行原程序时肯定会读写一些寄存器，在我们制作的CPU中就是累加器和ZF寄存器，在执行中断服务程序或异常服务程序时肯定也会修改这些寄存器，如果放任其不管的话，那么在恢复到源程序时，这些寄存器的值被修改了就会导致原程序的执行错误，所以我们在进入中断服务程序或者异常服务程序时需要将这些寄存器的值保存到主存中。这个任务可以通过设计硬件完成，也可以我们在软件中自己完成，比方说进入中断服务程序或者异常服务程序时先调用store指令保存一下累加器的值（不过我们目前没有设计读取和保存ZF寄存器的值到主存中的指令，需要发明一下，但是这里就不展开了）。
    
*   当从中断服务程序或异常服务程序时需要注意“恢复现场”。
    
    也就是将进入中断服务程序或异常服务程序时保存的那些寄存器的值再恢复出来，这样才能让原程序觉得刚才啥也没发生，就像是时间暂停了一会儿，然后继续开心的往下执行就好了。
    

正因为有了CPU的异常处理机制，我们才能在如今的计算机上既听音乐，还打游戏，后台还下载着电影，我们在键盘上按下的每一个键都可以得到及时的处理，人们写的程序不需要因为操作系统的更新换代而重新编写。CPU的异常处理机制的引入，让原本死板的、可能只适合进行数学运算的CPU有了更有趣的灵魂。

> 小贴士：  
>   
> 大家可能看出来了，这一章的内容其实并不是非常好，小孩子只概要性的介绍了与中断和异常相关的一些概念，并没有深入特别细的细节，是因为这一块其实比较复杂，我们目前设计的CPU支持的指令太少，寻址方式也少，内部只能操作一个累加器，这些局限性导致这个CPU并不能很好的处理中断和异常。等之后再版纸质书的时候再重新优化一下吧~