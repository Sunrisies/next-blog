上一章，我们讲了常见数据结构的设计思路，那么本章，我们就来看下要怎么使用这些数据结构，以及面对不同场景要如何选择合适的数据结构。

一级数据结构案例
--------

> 所谓一级数据结构，就是我们上一章讲到的几种能直接拿来实现现有需求的数据结构。

那么，我们到底要翻谁的牌子呢？看例子：

假如现在我要做一个**直播间的用户列表**，我要选择哪种数据结构来存储呢？

我们先来分析一下直播间的用户场景：

1.  直播间用户是个列表，点击就展示出来；
2.  直播间用户可能频繁地进出；
3.  点击列表中的一个用户，要显示出它的个人信息；
4.  点击列表中的一个用户，要能踢出他。

其中，第一条等于废话，我们讲到的所有数据结构都是集合，都能展示出一个列表。

第二条：意味着数据的添加删除可能很频繁，嗯，如果是在末尾添加/删除数据，那么顺序表和链表的效率都是一样的。如果是在中间插入/删除元素，那么链表的效率就高一些。所以链表加一分。

第三条：意味着随机访问元素，这个明显是顺序表占优，顺序表加一分。

第四条：点击踢出用户，首先要找到用户，然后踢出，这就等于“随机访问+删除元素”，也就是等于第二条和第三条的复合操作。

那这就麻烦了，各有各的优势，我们要如何选择呢？

嗯，明面上是 55 开，其实有很大的考量度，我们来分析下上述操作的**权重**问题，也就是哪些操作可能会比较多，哪些比较少。

我们知道，对于一个直播间，踢出这个操作是用得最少的，毕竟是隐藏的金主，能忍就忍。其次就是查看个人信息，因为既然是直播间，我们的关注点大多都在主播身上，进直播间不看主播看别人的信息，这就是对主播的侮辱。最后就是用户的进入和退出，因为大多数场景下，每个人进入直播间都是被封面吸引的，进去之后看到实际跟预期并不符合，就会大失所望，就直接跑了，这是个很频繁的操作。而且，大多数直播间的用户列表都是有排序的，比如：金主排前面，非金主但充值的次之，排最后的才是我们这些三无人员。这就导致每次进入/退出的人不是直接从列表的最后面操作的，而可能插入到列表中间或者前面，或者从列表中间删除，这明显就是链表占优了。

综上，对于很频繁地进入/退出操作，链表是占优势，所以我们应该选择链表来存储。

当然你也可以根据你们的数据统计来给每个操作进行加权，比如：在 1 小时内，进入/退出发生了 80 次，点击个人信息发生了 20 次，那么就是进入退出占 0.8 分，点击个人信息占 0.2 分，而进入/退出是链表占优，所以就选链表。

再比如，**直播间的消息列表**，我们很少对消息列表进行插入/删除，而往往是消息来了就加到最后一条，并且我们需要很频繁地点击消息去查看发送这条消息的人的信息，那这明显就是顺序表占优了。

直播间还有啥列表呢？还有礼物。

对于直播间来说，礼物是最重要的，也是肾上腺素飙升的主要来源。现在，假如直播间有 1w 个人在 5s 内都刷了一个礼物，那么，这 1w 个礼物会同时播放吗？

不会！

为啥呢？因为我们的手机都有内存限制啊，你这 1w 个礼物呢？假如一个礼物要 1 兆内存，1w 个礼物就是 10G 内存啊，这能同时播放吗？估计卡得你又要骂安卓垃圾、iOS 垃圾了。

那怎么办呢？排队播放！

一次我播不了 1w 个，那一次我播 100 个总是可以的，100 个也就是 100M 内存，还行。这样我就每次播 100 个，播放 100 次，就可以了。

每次播放 100 个，就按照播放两秒算，总共也就 200 秒，也就是 3 分钟左右，还可以接受。这也就是为什么很多直播间礼物不断的原因了。

好，既然说到了排队，那就明显是用我们上一章设计到的队列了。我们按照收到礼物的先后顺序进入队列，监测到当前播放个数是否大于 100，如果不大于，那么就让它播放，否则就添加到等待队列里面去。

    // 等待队列
    Queue waitingQueue;
    // 播放队列
    Queue playingQueue;
    // 播放礼物
    fun playGift(Gift gift) {
        // 如果播放队列没有满，那么就直接播放
        if(playingQueue.size < 100) {
            playingQueue.inQueue(gift);
            playGiftAnim(gift);
        }else {
            // 如果播放队列满了，就加入到等待队列中
            waitingQueue.inQueue(gift);
        }
        
        
    }
    
    // 播放礼物动画
    fun playGiftAnim(Gift gift) {
        // .... 播放礼物动画
        gift.play()
        
        // 播放完毕就移出播放队列
        playingQueue.outQueue(gift);
        
        // 检测并播放下一个
        playGift(waitingQueue.outQueue());
    }
    

上述代码仅供参考，但我们可以依此知道使用队列进行排队的方法，这个说白了就是当轮不到的时候，就先用一个集合把暂时轮不到的存放进去，前提是要按照先后的顺序存放，所以我们就选择使用队列。

有人说了，我要插队怎么办？你看银行还有 vip、svip，vip 中 p 呢。这就可以用到**优先级队列**了，这里限于篇幅问题，就暂时不做讲解了，我们就在后面的项目实战章节来看一下它是怎么使用的。

我们先来看一个我们用得很频繁的数据结构：哈希表，或者叫字典。

二级数据结构
------

> 二级数据结构是用一级数据结构组合而成的，最常见的就是`哈希表`。

什么是哈希表呢？它就是个数组。只不过这个数组的元素又是链表。所以我们可以称它为：**链表数组**。当然，在有的语言中，它也会用二叉树来实现。它大概就是这样的：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e3d16cc7c014506ba358091e662ba43~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=448&h=380&s=14167&e=png&b=fcfcfc)

那它可以用来干啥呢？可以**存放键值对**，图中的每一个元素，都不是一个数值，而是一个个的键值对，也就是我们高中学过的映射，你可以理解为：`f(x)=x`，而图中存放的就是这个关系。

关系？这玩意儿怎么存放呢？我们可以定义一个对象来存放：

    // 定义键值对，也就是图中的链表的元素
    class Node {
        int key; // 这就等价于x
        int value; // 这就等价于f(x)
        Node next;
    }
    

那么，怎么用呢？用在哪些场景呢？我们考虑下：如果要保存你的名字、年龄、性别，你要怎么保存呢？

用列表啊，直接按顺序放进去就行了。比如：

    list.put("张三");
    list.put("20");
    list.put("男");
    

这样当然可以，不过可读性太差，我还要记住下标，而且，如果有一天，你把 1 号位置删除了，那去 1 号位置拿年龄，就拿到了性别，这肯定不行。

其实这个例子中 x 就是下标，f(x) 就是下标对应的元素，但是 x 太不稳定了，所以我们需要个稳定的 x 值，来维持这个稳定的关系，我们就设计如下 API：

    fun put(String key, String value) {
    }
    
    fun getValue(String key) {
    }
    

当你 put 的时候，就等于存放一个**关系**，也就是键值对，比如：

    put("name","张三"); // 等价于f(name) = "张三"
    put("age","20"); // 等价于f(age) = "20"
    put("sex","男";) // 等价于f(sex) = "男"
    

获取的时候呢就这样：

    String name = get("name"); // 等价于 String name = f(name);
    

这样是不是更人性化了？完全就是在调用函数，`put`的时候保存函数变量和函数值，`get`的时候根据函数变量获取函数值。

这就是在做数学题。

所以，**当我们遇到存取`关系型`数据时候，哈希表就是不二之选**。

比如，上述的直播间用户列表，我们最后是用链表存放的，访问速度很慢，那么用哈希表，就能解决这个问题。

我们可以将用户的 id 作为哈希表的 key，也就是函数中的变量 x；将用户数据作为哈希表的 value，也就是函数中的 f(x)；这样，我们点击某个用户的时候，只要用 id 去`get`，就能立刻获取到用户的数据，这是不是快多了呢？并且，我们的插入/删除速度也很快。

那么，它为什么这么快呢？

因为它虽然是个数组，但是插入/删除元素的时候，数组并不进行位置移动。我们来看下元素的存放过程，假如我们要存放键值对：name=zhangsan。

1.  先计算 name 的哈希码（hashcode），结果是一个 int 值，这是个很快的操作。
2.  用 name 的哈希码对数组的长度求余，得到 a 应该存放的位置，这里假设位置是 0。
3.  如果这个位置没有其他元素，那么就直接放在这。如果有其他元素进行第 4 步。
4.  这里我们就得到了 0 号位的链表。我们从前往后逐个对比它们的哈希码，如果都不同，则把 name 这个键值对插入到这个链表的头部。如果有相同的则进行第 5 步。
5.  如果哈希码相同，就对比它们的 name 的值是否相同，如果不同则插入到链表头部，如果相同则用新的 value 替换掉老的 value。

有点懵，我们再来捋一下：先根据 name 计算 hashcode，然后用 hashcode 计算下标，然后找到下标对应的链表，没有则直接存放；有就继续对比 hashcode，都不同则插入到头部；有相同则继续对比 name 是否相等，如果不同则插入到链表头部，相同则直接替换掉原来的 value 值。

有人说，你这也太绕了，你这先计算哈希值，再计算下标，最后又对比 name 是否相同，图啥呢？

这其实就是伟大的**分页功能**。

还记得找张三的例子吗？我们按照姓名首字母、名字笔画数等分了那么多组，就是为了找起来快一点。哈希表也是这个原理。

不同的对象，它们的哈希码可能是相同的（这叫做哈希冲突），而不同的哈希码对数组长度求余得到的结果也可能是相同的。所以，我们就借此来给它们进行分组。

把哈希码相同的分为一组，把对数组长度求余结果相同的分为一组，这样，我们的范围就逐渐缩小了。这不就是分页吗？

哈希表也是基于这个原理设计的。

在这个过程中，计算哈希码很快，计算下标也很快，就是最后对链表计算比较慢，但是，在常规情况下，链表一般都很短，所以这个速度也是很快的。

总结
--

本章我们介绍了一些常见的数据集合的实践方法，以及哈希表的设计原理，我们再来回顾下。

*   当用到**非关系集合**时，我们优先考虑线性数据结构，读多写少就用顺序表，读少写多就用链表，要排队就用队列，要做对称性操作就用栈。
*   当用到**关系型集合**时，我们优先考虑哈希表，哈希表存放的是一个个键值对，类似于数学中的函数。
*   对于哈希表，它本身就是一个数组，只不过数组的元素是链表，它用了**分页的思想**。

那么下一章，我们就来看下计算机本身是怎么设计的，它里面又是怎么灵活使用各种设计思想的。