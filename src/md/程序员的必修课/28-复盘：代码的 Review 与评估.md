前两章，我们已经把直播间的需求搞完了，那么本章节，我们就来 Review 下我们项目中的问题，我们主要反思做得不好的地方，次要反思做得好的地方。

对于做得不好的地方，我们重点分析原因，到底是因为理性还是因为感性，是因为时间问题还是因为性格问题，最后反思出解决方法；对于做得好的地方，我们主要记录下结果和心得，以便下次还这么做。

且把闲话休提，只说正话，我们的复盘就开始了。

我们先说做得不好的地方（减分点），后说加分点，这样就能有个好结尾，也就能给人留个好印象。

减分点
---

成大事者，不虑胜先虑败。

我们就首当其冲地来痛定思痛，看一下我们哪里做得不够好。

### 1\. 数据安全问题

我们第一个做得不好的地方就是数据安全问题，我们的所有数据都是通过`json`传递的，不够安全，别人很容易通过我们传递的数据推测出我们的意图，然后自己去模仿数据向服务器发送，这样以来，我们的直播间就有了安全隐患。

那么怎么办呢？

嗯，加密！

用什么加密呢？MD5？

算了洗洗睡吧，你这加密加的连你们自己服务器都不认识了。

我们肯定要选个可逆的加密，对称加密还是非对称加密就看你们自己怎么定的了，加密这个事情一般都是服务器出策略的。客户端照着接上就行。

假如，我们采用了 RSA 加密，我们岂不是在所有发送数据的地方都要包装一下吗？

非也！

其实，我们发送数据的地方就一个，就是`socke.sendMsg(json)`，我们完全可以在这里直接将 json 数据用加密算法包装一下，然后发送给服务器。

好，我知道了，那你一开始为啥不做呢？

因为我们 app 目前不出名，而且加了代码混淆。技术差的人反编译不了，技术好的人不屑于反编译。等我们 app 用户起来了之后，再做加密这件事也不迟，不然就等于给一个 100 块钱的手机买了个 200 块钱的保护套，不值！

......行吧。

接着说说第二点吧。

### 2\. 并发问题

第二点值得我们反思的就是并发问题，我们目前的解决方案很简单粗暴，**在非 UI 线程中去解析数据，在 UI 线程中去分发事件来处理 UI**。

这是没问题，但是，不够细化。

如果有其他耗时操作，比如读取文件，网络请求，要放在哪里呢？

嗯，统一放在非 UI 线程中吗？肯定不行。这样可能就导致数据解析变慢，而 UI 的更新又是在数据解析之后的，这明显就会影响 UI 的更新，让户看起来可能就会卡顿。

所以，我们应该有个细化操作，可以将非 UI 线程细分为：网络请求线程，文件读取线程，数据解析线程等。

对应的操作就放在对应的线程中去做，这样达到各司其职，避免拥堵，让逻辑更合理。

当然有的语言可以采用线程池技术去处理，其实，不用也没问题，但是前提是自己维护好、管理好这些线程，只要能达到目标，采用什么方式都是可以的。

那这个为什么当初没做呢？

还是因为时间太紧急了，而这个又属于低优先级任务，不算是功能点，算是优化点，所以，后面再加也是可以的。毕竟，我们是先保证功能能用、有人用，然后再去优化功能点的。如果一次做到最好很浪费时间，那就先做成，再做好从而让时间分配灵活些。

接下来，再说说频控问题吧。

### 3\. 频控问题

啥是频控问题呢？

嗯，你有没有想过这样一个问题：假如我点击一个按钮请求一次数据，那么，当我第一次点下按钮的时，到第一次数据过来时，这期间我们的按钮时应该让点击呢，还是不让点击呢？

如果不让点击，用户就会觉得：这是不是卡了？如果让点击，那就会频繁地请求数据，导致出现一些无用的请求。

那怎么办呢？

我们可以让按钮可以点击，一直都可以点击，但是请求数据的时候就要做个判断了，如果当前正在请求 A 这个数据，后续如果还有请求 A 这个数据的动作，我们就直接忽略这个请求。

这样以来，用户自己也点了，他觉得自己请求了，他的心理得到了满足；而实际上，我们也只请求了一次，我们的心理也得到了满足，双赢！也就是赢两次！

那这样是不是太费劲了？

每个接口我都得加个标记来判断吗？烦死了。

其实也不用，我们考虑一下，如果网络正常的情况下，一个数据请求大概都是几百毫秒，我们就取 500ms 吧，然后，我们就对可点击的控件，比如`Button`，它的点击事件加个拦截，让其 500ms 内只响应一次点击事件，但是点击效果还是有的，只是拦截了点击事件。

这样以来，所有使用`Button`的地方，他们点击事件在 500ms 只会响应一次，那么点击请求数据的场景，也就是 500ms 内最多请求一次了。

有人说，如果网络不好，500ms 内数据还没请求过来呢？

那也没问题啊，那就多一次请求呗，假如你的网络卡得要死，请求一次数据需要的时间是 T，那么你最多请求这个数据的次数就是`T/500`，假如 5000ms 才请求过来数据，那最多就是 10 个请求这个数据的调用，这还是发生在用户疯狂连点的情况下，用户的单身时间要足够长，手速要足够快、心态要足够爆炸，网络还要卡，这是多小小概率事件啊，比谷歌收购微软 还 腾讯收购阿里，真是离谱他妈给离谱开门，离谱到家了，我们就不用咸吃箩卜淡操心了，多干点有用的事吧。

上述这个，就是频控问题，也就是**我们要控制某个事件发生的频率**，从而减少无效事件的发生次数，这样能节省流量，节省 CPU，各种节省，简直美滋滋。

那这为啥一开始不做呢？

嗯，还是没时间，要不是项目急着上线，产品经理猴急猴急地催，谁都想把代码写到最好。

......好吧。

好，接下来就该吹吹我的加分点了，我都迫不及待了。

加分点
---

终于到了加分点了，这个我可要往死里吹，先把优点列出来，然后该扩句的扩句，往死里写，不解释。

### 1\. 生命周期的控制

首先，第一个，就是我用了逻辑转移，也就是把直播间的逻辑处理从全局转移到了局部，在代码里就是从`Socket`中转移到了自己创建的`RoomContext`中，大家都知道，`Socket`是`App`一级的，就是全局的，它的生命周期跟`App`一样长，这样的话，就算直播间销毁了，这一块的逻辑还会有，可读性差，不利于维护。

所以，我就自己创建了个`RoomContex`来处理直播间逻辑，这样一来，直播间的生命周期就跟着`RoomContext`走，生命周期就比`App`短，直播间没了，房间处理的逻辑也没了，有效控制了房间的生命周期，可读性好，容易维护。

### 2\. 代码的设计优先原则

这一块功能我用了大量的设计模式以及设计思想，代码完全解耦，拓展性强，后面如果有其他改动，就会非常容易。

比如，我在消息分发的时候，使用了`Map`来存储事件，而不是用`if-esle`跳转，这样后续有新事件添加或者删除，就只需要添加/删除一个键值对就行，非常方便，且不会有其他影响。

而且，项目的整体架构我采用的是分层模式，顶层是基础房间，第二层才是我们的语音直播间，如果将来要扩展其他类型的房间，直接在适合的层级添加一个对应的`RoomContext`即可，逻辑完全能够复用。

我在房间层级的实现是采用的 MVC 模式，数据放在`RoomContext`中，完全和 UI 分离，即使将来要换皮，换 UI，完全不会影响到数据部分。

最后，我设计了直播间的相关类图，将来如果有其他同学要参与到项目中，可以看下这个类图，逻辑应该就会清晰很多：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/327e2c0ed2eb44bebb1f5ecef73886f6~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=868&h=489&s=114788&e=png&a=1&b=eeeeee)

大家应该还记得对象的 UML 图，如果不记得的话，就去复习下第 [24 章](https://juejin.cn/book/7196580339181944872/section/7196592243296501794 "https://juejin.cn/book/7196580339181944872/section/7196592243296501794")。

我们光看代码很容易迷失，看类图是不是清晰多了？我们看这个就知道谁继承谁，谁持有谁，当然，这个类图并不完善，因为只是列出了类名和它们之间的关系，并没有列出它们的函数和变量，所以看不到它们的功能，这个就要靠你去实现了，你可以看下相关的书籍，然后把这个类图补全，等到补全之后，你光看类图就大概知道整个项目的代码是怎么设计的了，这就是软件工程的必修本领——UML 图——的强大之处。

等你看完本小册时，你再回来看下这个类图，看看它是不是和你补完的一样吧。

总结
--

本章，我们讲解了一个项目的复盘实战，总结来说就是这么几点。

*   反思自己的缺点，以及为什么会犯，要怎么改。
*   总结自己的优点，哪里做得好，值得大家学习。
*   给自己打分，建议不要太高，但是也别太低。

项目复盘必不可少，且是大公司的最爱。一般来说，我们要做到以下几点，那么就能从容应对各种复盘。

1.  提前列出自己的缺点，并想好应对措施和答词。应对措施是让自己反思的，答词是给别人听的。
2.  反思缺点时候一定要认真，态度要真诚。其中认真是为自己考虑的，态度是给别人看的。
3.  说优点时一定要放大，这里面有多少水分自己知道就行。放大是为了别人看得懂、看得清，知道其中的利害。
4.  打分时，不要太高，也别太低，太低会让人觉得自己不够自信，太高会让别人觉得自己自大，别人心里都清楚的。

相信，看到这里，你应该比油条“**老**”那么一点了吧。

好，那么关于技术的，我们到这里就结束了，后面的两章，我们就开始学习程序员必须掌握的基本功能——**版本控制**，我们就一起来看看`Git`是怎么使用的吧，我们下一章见。