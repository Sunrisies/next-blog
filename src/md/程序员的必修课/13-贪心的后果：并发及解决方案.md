在上一章中，我们提到**资源冲突的充要条件是同一时刻、同一目标**。资源冲突是并发引起的问题，要破坏资源冲突，就要干掉同一时刻、同一目标这两个条件之一即可。那么我们就来看看到底怎么破坏这对儿活宝。

解决并发的基本操作
---------

> 要解决并发引起的资源冲突，核心就是破坏同一时刻或同一目标。

### 破坏同一时间

> 破坏同一时间的核心就是**排队**。

假设我们有如下代码：

    class A {
        int a = 0;
        // 开启一个线程不断增加a的值
        Thread t1 = new Thread() {
            void run(){
                for(int i =0; i< 1000_000_000; i++) a++;
            }
        };
        t1.start();
        
        // 开启另一个线程不断增加a的值
        Thread t2 = new Thread() {
            void run() {
                for(int i =0; i< 1000_000_000; i++) a++;
            }
        };
        t2.start();
    }
    

简单，执行完之后 a 等于 2000\_000\_000。

错！你可以试试，大概率不是 2000\_000\_000。

这是为啥呢？因为这是两条执行流在同时跑，假设我们只执行了`a++`，那么流程如下：

![两个线程操作](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a796058b087444b6a0c75fdba461adfe~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=643&h=602&s=66518&e=jpg&b=fdfdfd)

我们看到，两个线程几乎同时把 a 读如自己的缓存中，然后去执行加法，如下：

*   Thread1 把 a 读入自己的缓存中，此时 a=0。
*   Thread2 把 a 读如自己的缓存中，此时 a=0。
*   Thread1 执行 a++，此时 a=1。
*   Thread2 执行 a++，此时 a=1。
*   Thread1 把 a 写回主内存，此时 a=1。
*   Thread2 把 a 写回主内存，此时 a=1。

于是就会导致两个线程都执行了一轮`a++`之后，a 从 0 变成了 1，而不是 2。

这怎么办呢？

我们可以给 a `加锁`，也就是说：在 a 被一个线程读取后，就加个锁，如果被写回来，就释放锁，其他线程过来了之后发现有锁，就等着，这就会导致**同时只能有一个线程使用 a**。

就像酒店的宾馆，有人住的话就得到钥匙，并且锁门，这样别人就进不来了；离开再交还钥匙，这样下一个人就能住了。这就是**排队**。

我们也给线程安排上这个逻辑，排队后的流程如下：

![排队操作](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e23fb808efd4538a00feebd231ae2c1~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=669&h=602&s=77634&e=jpg&b=fcfcfc)

我们看到，排队之后，线程是按照顺序来操作 a 了。

*   Thread1 把 a 读入自己的内存中，并获取锁，此时 a=0。
*   Thread2 去读 a，发现被锁了，就等着。
*   Thread1 对 a 进行自增，此时 a=1。
*   Thread1 用完 a 了，把它写回主内存，并释放锁，然后通知其他线程你们可以用了，此时 a=1。
*   Thread2 知道自己可以用了，赶紧上号，就从内存中读入 a，并获取锁，此时 a=1。
*   后续的使用流程就跟 Thread1 一样了。

可以看到，加了锁之后，我们原来的**并行（多个线程一起执行）**，变成了**串行（线程排队执行）了**。串行就破坏了同一时间这个条件。

那么，怎么破坏同一目标的呢？

### 破坏同一目标

> 破坏同一目标的核心就是**分散目标**，但前提是目标能被拆分。

那么，上述的例子能破坏同一目标吗？不能，因为 a 已经是一个数字了，没法再拆分了。

我们看个例子：

    List list = new List();
    
    Thread t1 = new Thread() {
        void run() {
            // 我读读读
            list.forEach {it->
                println(it);        
            }
        }
    
    }
    
    Thread t2 = new Thread() {
        void run() {
            // 我写写写
            for(int i = 0; i< 1000_000;i++) {
                println(list.add("yyds"));
            }
        }
    }
    

俩线程同时操作一个顺序表，t1 不断地读，t2 不断地写，这就会导致问题了，可能本来集合是空。

*   t1：哦空的啊，哈哈哈，那我就做做样子，美滋滋。
    
*   t2：与此同时我要开始搞事情，我开始写。
    
*   t1：？？？咋一下这么多数据了。要加钱！
    

这就出现问题了，因为 t1 看到的跟预期不符。

那怎么办呢？嗯，集合啊，可以分离啊，那就分离目标，我们可以这样：t2 每次在写数据的时候，都不直接对 list 写，而是把 list 复制一份，写到复印件里去，写完了再把它同步到 list。如下：

    Thread t2 = new Thread() {
        void run() {
            // 我写写写
            
            // 创建个复印件
            List newList = new List();
            newList.addAll(list);
            
            // 对复印件操作
            for(int i = 0; i< 1000_000;i++) {
                println(newList.add("yyds"));
            }
            
            // 同步到list
            list.clear;
            list.addAll(newList);
        }
    }
    

都看懂了吧？看不懂的话仔细看注释。

为啥要这么干呢？这样可以把目标分离，写的时候针对的是 newList，而不是原来的 list，这样别的线程在读的时候还是原来的 list，也就是**读和写的不是同一个目标，这就是目标分离**。这样读写操作即使同时执行，也不会互相影响。

这种做法叫做：**写时拷贝（copy on write）**。

有人说，为啥不读时拷贝呢？劳资就要读时拷贝。

不行，你忘了我们上一章说的吗：竞争冲突发生的前提是对冲突资源发生了操作，操作就是：增删改。而读，它不是操作，它是访问。

假如你对读操作加了，那么两个线程一起写呢？不是照样出问题吗？

所以，我们要理解核心：同时操作！操作！操作！针对引起问题的动作进行处理，也就是针对**操作这个动作**进行处理。

再比如：哈希表，经过[第 12 章节](https://juejin.cn/book/7196580339181944872/section/7196590693987385384 "https://juejin.cn/book/7196580339181944872/section/7196590693987385384")，我们知道哈希表是**链表数组**。存储的元素要先找下标。

如果两个线程同时 put 元素的时候，下标不同，是不是就能同时 put 呢？

对！所以，我们可以给哈希表**分段**，每次 put 元素的时候，如果是同一段，就等待；如果是不同的段，就可以直接 put。

比如，线程 1 来 put，计算到下标是 4，那就直接 put。同时线程 2 也来 put，计算到下标是 5，也直接 put。同时线程 3 也来 put，计算到下标是 4，就看线程 1 是否 put 完了，没完就等着，完了自己再 put，依此类推。

其实，分段思想，也是分离目标，将一个大段分为不同的小段，就等于把一个大目标拆分，我们上面的写时复制是复制了一份，而分段则是把自己拆分为几份，不过，核心思想都是：**目标分离**。

**目标分离是一种思想，而`写时拷贝`和`分段`都是实现这个思想的手段，我们要掌握本质，也就是要理解目标分离这个思想**。

我们来看下，基于这个思想衍生出来的工具。

处理并发冲突的工具
---------

并发的处理免不了要等待操作，那么，就有两种情况：

1.  我等着，你好了叫我；
2.  我等着，每隔一段时间再来看看你搞完了吗。

第一种情况：你好了叫我，明显就是可能你要很久，劳资不等了，所以就是**假设你要等很长时间**，这是带有悲观色彩的，我们就叫它 **`悲观处理`**；第二种情况：我等一会儿再来看看，明显就是可能你很快就完了，也就是**只等很短时间**，这就是带有乐观色彩的，我们就叫它 **`乐观处理`**。

嗯，听口气也大概猜到是这个意思了。

### 悲观处理

> 凡是可能要等很久的都是悲观处理，我们以此可以发明一个**悲观锁**。

**悲观锁的核心就是等待，被唤醒**。

也就是说，我可能要等很久，那就算了，我不等了，你完事了跟我说下吧。

那么，我们以此发明的悲观锁就叫 **synchronized**，大部分语言都有这个关键字，前缀`sync`也表示同步的意思，相反的，`async`就表示异步。

比如，上面的`a++`例子，第二种排队的图示我们都看懂了，那么对应的代码呢？

就如下：

    class A {
        int a = 0;
        // 开启一个线程不断增加a的值
        Thread t1 = new Thread() {
            // 加了synchronized关键字
            synchronized void run(){
                for(int i =0; i< 1000_000_000; i++) a++;
            }
        };
        t1.start();
        
        // 开启另一个线程不断增加a的值
        Thread t2 = new Thread() {
            // 加了synchronized关键字
            synchronized void run() {
                for(int i =0; i< 1000_000_000; i++) a++;
            }
        };
        t2.start();
    }
    

很简单，直接在函数上加上`synchronized`关键字就行了，就默认等于对当前对象（this）进行加锁。线程每次调用方法都要获取 this 这个锁，获取到就执行，获取不到就等着；函数执行完了就会默认释放 this 这个锁。

那么，集合呢？比如上面的`list`，是不是也这样就行了？

对！不过，有的语言已经自己对集合做了特殊处理了，比如`Java`的`SynchronizedList`，自己在内部已经对`add()`、`remove()`等函数进行了加锁操作，大概如下：

    class SynchronizedList {
        // 我自己加了，外面就别费事了
        synchronized void add(int num) {
        }
        
        // 我自己加了，外面别费事了
        synchronized void remove() {
        }
    }
    

这就是简单粗暴的设计思路。

有人说，我都懂了，这个是需要排队，然后等别人执行完，来叫我一声就行。

对，正是这样！

那么，它先叫我吗？还是说谁排在前面就叫谁？

随机的！完全随机！不是排在前面的就先叫，所以也叫：**非公平锁**！

啥！不公平？不干了！

别激动别激动，这是有道理的。这样随机唤醒，就等价于后面的每个线程的机会都是均等的，不会出现那种黄牛线程，自己往死里排队，结果后面的都得不到执行。

没问题的话，我们就接着来看下乐观处理的方式。

### 乐观处理

> 凡是可能等很少时间的都是乐观处理，我们可以以此发明一个**乐观锁**。

**乐观锁的核心就是自旋**。

大家都知道大名顶顶的 **CAS**，这就是个乐观锁。

乐观锁因为只要等很少时间，所以，与其我回家等着，倒不如我在这看着，过一段时间就来问问，反正也没多久。

这种过一段时间就来看看的叫做**轮询**，过一段时间来问问中的“一段时间”我干啥呢？我原地转圈玩，反正不闲着，这就叫做**自旋**。

所以，我们可以发明一种**自旋锁**，自旋锁就是乐观锁的一种。

比如，还是上面的`a++`的例子，我们改成自旋的：

    class A {
        int a = 0;
        
        boolean lock = false;
        
        // 开启一个线程不断增加a的值
        Thread t1 = new Thread() {
            // 加了synchronized关键字
            void run() {
                // 发现被锁了，就死循环自己转圈玩
                while(lock) {
                    // 大风车吱呀吱哟哟地转
                }
                // 哦，终于拿到锁了，搞起!
                lock = true; // 自己拿到锁了，标记一下
                for(int i =0; i< 1000_000_000; i++) a++;
                lock = false; // 自己执行完了，释放锁
            }
        };
        t1.start();
        
        // 开启另一个线程不断增加a的值
        Thread t2 = new Thread() {
            // 加了synchronized关键字
            void run() {
                // 发现被锁了，就死循环自己转圈玩
                while(lock) {
                    // 大风车吱呀吱哟哟地转
                }
                // 哦，终于拿到锁了，搞起!
                lock = true;
                for(int i =0; i< 1000_000_000; i++) a++;
                lock = false;
            }
        };
        t2.start();
    }
    

很简单，就开个死循环，不断检测着玩，一旦死循环结束，说明拿到锁了，就干自己该干的。

有人说，这好费劲啊，一直在`while(true)`，CPU 就得一直工作，费电啊。

对！确实费电，所以它的使用条件是**等的时间短**，如果等的时间很长，那么就是悲观的，就不要用乐观锁了。

还有，我们可以改造我们的锁，每次都间隔一段时间再去访问，换句话说就是：在`while(true)`里面让线程休眠一段时间，如果好几次都获取不到锁，那就增加时间，比如：

    int len = 0
    while(true) {
        sleep((len++)*200);
    }
    

这样就会依次休眠 200ms、400ms、600ms……这就叫做**自适应自旋**。

当然，很多语言中都给我们提供了现成的工具，比如很多语言中都有`CAS`这个关键字，代码中敲一下就提示出来了，我们可以选择性使用。

总之，大家要根据具体的场合去选择合适的锁。

总结
--

本章给大家讲解了并发中冲突的处理方式：**破坏同时性或破坏同一目标**。只需要破坏一个条件即可。我们可以概括为`一个思想、两个策略`。

*   一个思想：在遇到问题时，列出问题发生的充分必要条件，只要破坏一个条件就能解决问题。比如，本章的并发。
    
*   策略 1：当我等待一个资源的时候，如果资源迟迟不到位，那么我就告诉资源持有者，等资源到位的时候，通知我一下，这样可以不浪费我的时间，但是可能不及时，我们可以称之为：**被动型通知**。
    
*   策略 2：当我等待一个资源的时候，如果资源迟迟不到位，那么我就在这等着，这样可能比较浪费时间，但是比较及时，我们称之为：**主动型获取**。
    

大思想是我们必须掌握的，小策略则各有优缺点，需要我们根据具体情况去选择。

好，那么，下一章，我们就来看下：计算机是怎么使用这种策略来调度我们的线程的。