在上一章中，我们讲了 TCP 的可靠传输原理，以及连接和释放过程，这些都是理论知识，除了可以让自己豁然开朗、心情舒畅外，还可以应对面试官的刁难。

那么，本章就来从实践方面搞定网络部分的优化，这可以让爱找茬的测试闭嘴，也可以让爱挑刺的用户禁言。

我们先提纲挈领，总结出来网络优化的几句`总纲`：**尽量不请求，尽量少请求，尽量提前请求**。

好，下面就让我们来详细剖析下这几句秘籍的具体含义吧。

不请求
---

我们的数据从哪来的？——从服务器啊。

那你不请求还会有数据吗？——会啊。

抬杠是吧？你把网络关了，看看数据从哪来？

好，现在我去把网络关了，打开微信，我照样能看到聊天记录，照样能看到发送和接收到的图片，照样能看到好友信息。

这是为啥？**缓存**！

要想不请求只有一个办法：缓存！

缓存是啥呢？

> 缓存就是将从网络获取到的数据保存到客户端本地。

这样一来，下次使用的时候，即使网络没有数据，也能用本地的数据显示给用户。

那么，是不是有了缓存之后，就不用再请求服务器数据了呢？

肯定不是，因为缓存的数据是固定不变的，而服务器的数据是不断变化的，我们不能一直看老数据吧，所以，缓存也要实时更新，我们可以每次从服务器请求到数据后，都更新到本地，这样来提高缓存数据的实时性。页面显示的时候，我们优先显示缓存的数据，同时去拉取服务器的数据，服务器数据过来后，再更新的页面上，同时更新到缓存中，就行了。

    fun showUI {
        // 先用本地数据渲染页面
        val localData = getLoalData();
        refreshUI(localData);
        
        // 请求网络数据，这是个异步操作
        val newData = requestData();
        // 用网络新数据渲染页面
        refreshUI(newData);
        // 将网络新数据保存到本地，这也是个异步操作
        saveDataToLocal(newData);
    }
    

如上所示，简单明了。

我们可以这么理解：我们的缓存其实也是服务器。

啥叫服务器呢？——提供服务的机器。

啥服务呢？——提供数据！

所以，**从广义的角度来讲，请求数据的叫客户端，提供数据的叫服务器**。

所以，一旦没有了网络，提供数据的就是缓存，也就是本地文件，那么，此时的服务器就是缓存。

换句话来讲，客户端不管面对谁，只要你是给我提供数据的，你就是服务器。

那从这个角度来讲，内存也是服务器啊。我可以把请求过来的数据缓存到内存中，下次直接从内存中拿不就完事了？

当然可以！

好，现在让我们站在客户端的角度来看问题。

首先，我有个页面叫`PageA`，是用来展示 UI 的；我有个对象叫`DataStoreA`，是用来存放数据的。那么此时，`PageA`就是客户端，`DataStoreA`就是服务器，我们来实现如下代码：

    class PageA {
        
        // 从服务器获取数据
        private DataStoreA dataStoreA;
        
        // 展示UI
        void showUI(){
            String data = dataStoreA.getData();
            uiTitle.setData(data);
        }
    }
    
    calss DataStoreA {
    
        String Data = "太阳当空照，花儿对我笑";
        // 提供数据
        public String getData() {
            return data;
        }
    }
    

代码也很简单，我们直接从`DataStoreA`中获取数据，显示在 UI 上就完事了。

有人说了，你这不对啊，你这数据在内存中，一旦应用被杀死了，数据就没了，还显示个毛啊。

别急别急，我代码还没写完呢。

那我们就上完整版代码：

    class PageA {
        
        // 从服务器获取数据
        private DataStoreA dataStoreA;
        
        // 展示UI
        void showUI(){
            String data = dataStoreA.getData();
            uiTitle.setData(data);
        }
    }
    
    calss DataStoreA {
    
        String Data = "太阳当空照，花儿对我笑";
        // 提供数据
        public String getData() {
             // 从内存中获取数据
            if(data != null) return data;
            // 如果数据为空，就从本地缓存中获取数据
            data = getLocalData();
            if(data != null) return data;
            // 如果数据为空，就从网络获取数据
            String newData = requestData();
            
            
            // 数据获取到了，更新到缓存
            saveDataToLocal(newData);
            // 同时更新到内存
            data = newData;
            
            return data;
        }
    }
    

这就是大体的代码逻辑，可以看到，我们一个页面有三个服务器，分别是：内存服务器、缓存服务器、网络服务器。其实这就是`三级缓存`，按照优先级来排名的。读取速度越快，优先级越高。

这个代码有个好处就是：无论`DataStoreA`的数据从哪里来，`PageA`都不知道，它只知道有个`getData()`方法可以获取数据，这就是**最少知识**原则。

其实，这里面有几个优化点。

1.  在`DataStore`的初始化方法内，可以提前调用`getLocatData()`方法，给`data`赋值，这样在获取数据的时候，就不用再读取了，就会快一点。
2.  在`saveDataToLocal()`时候，如果数据比较大，我们就可以将其拆开保存，每次只保存变化的部分，毕竟保存文件也是一个耗时操作。

拆开保存数据属于**粒度细化**，这跟我们[第 21 章](https://juejin.cn/book/7196580339181944872/section/7196591861673230371 "https://juejin.cn/book/7196580339181944872/section/7196591861673230371")要讲的**单一职责原则**和**接口隔离原则**有异曲同工之妙，核心都是粒度细化。

有人说，那我第一次上来就断着网，你从哪缓存？

这就没办法了，就算是巧妇，也难为无米之炊，所以必须要做一次网络请求。

既然必须请求了，那么能省就省，我们就少请求一些吧。

少请求
---

少请求有两层含义：**服务器少返回数据，客户端少发请求**。

首先，根据上面我们说的，**我们对数据要做个细化操作**，也就是说：我需要啥你就返啥，别的别瞎返回。

比如：我要这个人的基础资料，也就几个 kb 的数据吧。结果呢，服务器接口定义得不好，直接给我返回了他家一户口本的信息，他有 3 个妹妹、4 个姐姐、5 个哥哥、6 个弟弟，加上父母俩人，一共 21 个人的信息，好家伙！直接返回了 21 倍的数据，你说这能不慢吗？TCP 原来传输 1 秒就行了，你这一下传输 21 秒，数据到我这之后，我还要从里面挑选出来那个人的数据，能改就改、不能改就会议室见！

所以，数据要细化，细化之后，返回的数据就少了，那么肯定就快了啊。

我们还可以改下我们的数据格式，比如，使用 proto 而不是 json，图片采用 webp 而不是 png，对数据进行压缩，等等，总之，想尽一切办法减少数据量。

再者，客户端要控制自己的请求次数，不能页面显示一次就请求一次，如果真的对实时性的要求比较高，可以采取 TCP 等长连接的方式，而不是客户端不断地发 HTTP 请求。所以，如果：

*   对实时性要求高，就采用长连接的方式；
*   对实时性要求不高，就只请求一次，然后添加下拉刷新等方式让用户手动刷新。

我们也可以用**数据共享**的方式来减少请求次数，比如，我的 App 有个首页，会推荐几个陌生人给我；还有个二级页面，这里就显示完整的推荐列表，下拉可以显示更多陌生人。

那么，我们就应该让首页的这部分和二级页面的这部分共用一份数据，首页加载前 20 条数据，并且显示出来，进入二级页面就直接显示首页的那 20 条数据，并且同时去加载下 20 条数据。这样以来，二级页面不但避免了一次加载，还会显示得更快，这就是数据共享。

但是我的数据都写在页面里了啊，这让我怎么共享？

谁让你写在页面里的？先把你的代码 MVC 一下再说吧。

任何优化，都逃不过 MVC 模式，一定要做好数据和 UI 的拆分。

其实，客户端请求的数据量就等于：**请求次数 x 单次请求量**，我们上面说的也正是针对这两点做的，但是这些都是针对开发人员的，如果我作为用户，我最在意的肯定是：快不快！然后才是省不省！

那么，怎么让客户觉得快呢？

提前请求！

提前请求
----

提前请求我知道，就是页面还没点我就先把可能点击的页面的数据先请求过来准备着对吧？

没错！但是不完全对。

假如，有个列表页，每一条数据都有可能被点击，你难不成把显示列表的所有数据都加载出来吗？这肯定不可能的。

再比如，一个页面上有 10 个按钮，每个按钮都可能进入一个新页面，你难道把这 10 个页面数据提前加载出来吗？也不可能。

那么怎么办呢？

我们先来做个分类，有 10 个按钮的那个页面，就是固定的 10 个页面，不会变化，我们叫做**可枚举**；而那个列表页呢，每次滑动的时候，都会变化，我们叫做**不可枚举**。

**对于可枚举的，我们就做埋点分析**。我相信大部分公司的产品运营应该都有要求埋点的；我们可以默认拉取埋点占比最高的那个页面的数据，或者占比最高的前几个页面的数据。比如：这个页面总共显示了 100 次，其中按钮 A 被点击了 70 次，按钮 B 被点击了 10 次，按钮 C 被点击了 3 次。那么，按钮 A 的点击率是最高的。我们就可以认为每个用户进来都会点击它，所以我们就提前把按钮 A 对应的页面数据拉过来以备使用。

这属于`概率学`问题了，肯定不能完美解决问题，比如用户不点就白拉数据了，但是这是已知的最优解了。

那么，对于列表类的那种，埋点你都埋不了，你怎么办呢？

**对于不可枚举的，我们就做用户分析**。因为列表都不可枚举了，埋个毛的点啊，所以，我们就找可枚举的，比如这个用户。首先，我们要针对这个用户做出行为分析，比如这个用户喜欢看什么类型的，然后，我就在当前列表中，挑选出最贴近这个用户喜欢的类型的，提前加载出来，然后就洗白白等着他点。

什么，他没点？

看来他喜欢的类型不包含这个，那就再记录下，下次就不提前加载这个了。

这就是`行为分析`，也可以叫`大数据杀熟`，说白了就是根据你的操作，分析并记录你的行为习惯，然后做出推断，从而给你推送相关内容。

有人说了，你这也太费劲了吧，如果我们没有埋点，也没有分析算法，这要怎么做呢？

也是可以的！

大部分人的代码大概是这样：点击启动页面，在页面的生命周期方法中去请求数据，数据过来后就渲染 UI。

这一点都没错，只能说太矬了。

我们假设，从点击启动页面开始，到页面的生命周期方法过来为止的时间为 t1，从请求数据开始，到数据过来为止的时间是 t2，那么，对于人眼来说，就是一共等待了`t1+t2`的时间。

可不可以快点呢？可以！

我们可以这样，点击启动页面的一瞬间，同时异步去请求数据，等到页面的生命周期过来后，判断数据是否已经请求到了，如果请求到了，就直接渲染 UI，如果还没请求到，就等待数据过来后再渲染 UI，这样花费的时间一共是`max(t1,t2)`。

因为启动 UI 是在 UI 线程的，而请求数据是在工作线程的，并且它俩是没有资源竞争的，这样就可以利用多线程的优势来缩短时间，我们在[第 14 章](https://juejin.cn/book/7196580339181944872/section/7196591134489968692 "https://juejin.cn/book/7196580339181944872/section/7196591134489968692")讲过这样的例子，这里就不废话了。

这样需要一个前提：数据和 UI 分离。不然，如果数据先过来了，就会没地方存放，所以你看：MVC 是多么重要啊！

有人说，你这有问题啊，如果我点击了页面，然后赶紧退出页面，这样你数据过来了页面已经没了，那数据怎么销毁呢？

我们可以在数据仓库中添加标记，当页面销毁的时候，就设置这个标记，数据请求过来后就判断这个标记，然后清除数据即可。

我们把可枚举和不可枚举的策略叫做**预判加载**，把点击时立刻去加载的策略叫做**提前加载**，我们可以同时使用预判加载和提前加载，比如：点击的时候就先判断，发现数据已经被预判加载过了，就不再执行提前加载了；如果没有被预判中，那就执行提前加载。这个策略是不是跟缓存策略有类似的地方呢？对比一下你就知道了，这里不再废话。

总结
--

本章从实践角度讲解了网络请求的优化，核心就三点：**尽量不请求，尽量少请求，尽量提前请求**。

*   尽量不请求：使用缓存避免无用请求。
*   尽量少请求：使用数据细化、数据压缩、数据共享等方式减少请求次数。
*   尽量提前请求：使用预判加载和提前加载减少用户等待时间。

好，本章到此结束，下一章，我们就要站在计算机角度，来彻底了解下我们朝夕相处的好朋友的工作方式了。