通过前面两节课的内容我们介绍了自定义类型的知识细节，现在我们可以自由地用 C++ 来定义世界里形形色色的事物了。

不过类型的作用远不止于此，我们还可以用类型描述相似的事物（`继承`），用类型描述相似事物的不同特征（`多态`）。

本节课我就将带领大家学习 C++ 面向对象编程泛式另外两个重要知识：继承和多态，通过继承可以扩展已有的类型进而创建新的类型。**继承是多态的基础，多态是面向对象编程的核心知识，是 C++ 描述事物多种形态的有力工具**。

C++ 的面向对象编程比 JavaScript 的面向对象编程要复杂得多，不过它们的目的都是一样的（殊途同归），如果你已经娴熟地掌握了 JavaScript 面向对象的技能，那么相信你学习本章内容也不会感到吃力。

继承与多态的基本用法
----------

假设我们在开发一个即时通讯应用，用户可以在这个应用中发送多种不同类型的消息，比如纯文本消息、图片消息或文件消息等。

在下面这个示例中，我们抽象出了一个消息类型 `Message` 作为所有消息类型的父类。接着定义了一个文本消息类型 `TextMessage` 作为 Message 的一个子类和一个文件消息 `FileMessage` 作为 Message 的另一个子类。

父类 Message 拥有所有消息的共同特征和行为，比如都拥有 `MessageId` 属性和消息发送方法 `SendMessage` 等。

两个子类**继承**了`Message`父类的特征和行为，同时它们还拥有自己独特的特征和行为，比如文本消息拥有 `Text` 属性，文件消息拥有 `FilePath` 属性。

两个子类都可以被当作父类对待，比如我们把子类对象的引用传递给了通用消息处理方法`Send`（此方法的传入参数是`Message&`类型）， Send 方法内部调用的实际上是子类实例的 `SendMessage` 方法。

    #include <iostream>
    #include <random>
    #include <string>
    using namespace std;
    //消息父类。用于描述所有消息都具备的共同特征
    class Message
    {
    public:
        Message() : MessageId{ createMessageId() } { }
        const int MessageId;
        virtual void SendMessage() { }
    private:
        int createMessageId() { //生成消息ID
            random_device dev;
            return dev();
        }
    };
    
    //文本消息子类
    class TextMessage: public Message
    {
    public:
        TextMessage() : Message() {}
        void SendMessage() override { //重写父类消息
            cout << "发送文本消息：" << MessageId << ":" << Text << endl; //MessageId来自父类
        }
        string Text;
    };
    
    //文件消息子类
    class FileMessage : public Message
    {
    public:
        FileMessage() : Message() {}
        void SendMessage() override { //重写父类消息
            cout << "发送文件消息：" << MessageId << ":" << FilePath << endl; //MessageId来自父类
        }
        string FilePath;
    };
    
    //通用消息处理方法
    void Send(Message& msg) {
        msg.SendMessage();
    }
    
    //入口函数
    int main() {
        {
            TextMessage txtMsg;
            txtMsg.Text = "明天下午又个会";
            Send(txtMsg); //传递引用 输出：发送文本消息：1286241589:明天下午又个会
        }
        {
            FileMessage fileMsg;
            fileMsg.FilePath = "c://hello.png";
            Send(fileMsg); //传递引用 输出：发送文件消息：860319378:c://hello.png
        }
        auto c = getchar();
    }
    

继承的细节：构造函数
----------

在这段代码中，子类继承父类的方式是：`class SubClass: public ParentClass`，这里`public`关键字大部分时候都是需要的（不详细介绍这里，避免陷入知识细节的深渊）。

子类可以在成员初始化列表中调用父类的构造函数，如果想要向父类的构造函数传参，也可以在此时完成：`TextMessage() : Message(123) {}`。

子类不会从父类继承构造函数（可以使用 using 引入父类的构造方法，不多解释了），当子类和父类中有签名相同（方法名、参数列表和方法修饰符相同）的构造函数时，会优先使用子类中的构造函数。

继承的细节：实例创建和销毁的流程
----------------

当我们创建一个子类实例时，首先执行父类成员初始化列表，然后执行子类成员初始化列表，然后执行父类的构造函数，然后执行子类构造函数。

当我们销毁一个子类实例时，首先执行子类的析构函数，然后执行父类的析构函数，整个过程如如下图所示：

![ObjectCreateFlow.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d9a7bb5c21142b1a9532ace39720e0c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=889&h=613&s=23445&e=png&b=fdf4f4)

继承的细节：成员
--------

我们在消息父类的构造函数中初始化了消息 ID：`MessageId`（随机整数），这个 MessageId 是公开的，被两个子类继承，也就是说子类对象也拥有 `MessageId` 成员变量。

我们在文本消息子类 `TextMessage` 中扩展了一个新字段：`Text`，在文件消息 `FileMessage` 子类中扩展了一个新字段：`FilePath`。这代表着不同的子类拥有自己不同的特性。

声明为 protected 的基类成员不能在类的外部访问，但可以在子类的成员函数中访问。声明为 public 的基类成员可以在类的外部访问，也可以在子类的成员函数中访问。声明为 private 的基类成员不能在类的外部访问，也不能在子类的成员函数中访问。

当子类包含有与父类相同名称的变量或函数时，父类的变量或函数会被隐藏，这和我们在前面的章节中介绍的程序块变量隐藏的概念类似。我们在子类中可以使用父类的名称限定符来访问父类被隐藏的成员变量或函数（`Message::HidenProperty`）。这里需要注意的是：**只要名称相同就会被隐藏**，不管子类的成员方法是否与父类的成员方法具有相同的参数。

多态的细节：隐式转换
----------

在上面的代码中，我们定义了一个**通用的**消息处理方法：`Send`，它接收父类类型对象的引用`Message& msg`，当我们把`TextMessage`或`FileMessage`的实例传递给`Send`方法时，这些实例自动地完成了**隐式类型转换**，变成了一个`Message`类型的实例引用。

也就是说，**我们可以把子类对象的引用当作父类对象的引用使用**。同样的道理，我们**也可以把子类对象的指针当作父类对象的指针使用**。但我们不能把子类对象直接当作父类对象使用（只能是引用或者指针）。

多态的细节：重写
--------

`Message`类只是通过`SendMessage`方法描述了它拥有这样的行为，但并没有给出具体的实现，具体的实现是在子类中完成的。

在 `Send` 方法内部，执行的是子类对象的 `SendMessage` 方法，之所以达到这样的效果，就是因为我们把 `Message` 父类的 `SendMessage` 方法标记为 `virtual`。如果没有这个`virtual`关键字，那么执行的就是 `Message` 父类的 `SendMessage` 方法。

父类 `SendMessage` 方法被标记为 `virtual` ，说明这是一个虚函数，需要被子类重写。子类 `SendMessage` 方法被标记为 `override` ，说明这个方法用于重写父类的方法（需要注意的是：重写的概念与隐藏的概念是不同的）。两个子类 `SendMessage` 方法的实现逻辑是不同的。

子类的方法上加上 `override` 关键字之后，编译器就会帮我们检查父类是不是存在对应的虚方法（`virtual`标记过的方法），如果不存在，就报编译错误。不过这个关键字不是必须的，如果你不写这个 `override` 也能完成方法的重写，`override` 关键字只起到编译期检查的作用。我还是建议写上这个关键字。

假设我们还有一个表情消息类型：`EmojiMessage` ，这个消息的 `SendMessage` 逻辑和文本消息`TextMessage` 的 `SendMessage` 逻辑是一模一样的，那么此时我们就可以把这个逻辑放到父类的 `SendMessage` 方法中，表情消息和文本消息就不用再重写父类的 `SendMessage` 方法了，只要文件消息类重写这个方法即可。

假设 `Message` 类的所有子类都重写了 `SendMessage` 方法，那么就可以把 `Message` 类的 `SendMessage` 方法设计为纯虚函数，如下代码所示：

    virtual void SendMessage() = 0;
    

**包含纯虚函数的类就是抽象类**，抽象类是不能实例化的，子类必须实现了父类的所有纯虚函数才不是一个抽象类，否则子类也是抽象类。

多态的细节：虚析构函数
-----------

假设 Send 方法接收的是一个 Message 类型的指针，而且我们要在 Send 方法内 delete 这个指针，那么我们就要考虑把 Message 的析构函数设置为虚析构函数了。如下代码所示：

    virtual ~Message() {
    
    }
    

因为如果不把 Message 的析构函数设置为虚析构函数，那么 delete 指针的时候调用的就是 Message 的析构函数，而不是子类的析构函数。这和虚方法的道理是一样的。

即使子类的析构函数重写了父类的析构函数，在 delete 指针时，子类的析构函数还是会调用父类的虚构函数。执行顺序和我们上面介绍的子类实例销毁过程是一样的。

多态的应用场景
-------

现在我们拓展一下视野，假设我们的应用中有很多数据类型，每个数据类型都拥有很多成员属性，每个数据类型都对应数据库中的一张表，成员属性对应表里的字段。

显然这些类型都有一些相同的行为：持久化数据到数据库（`SaveDataToDB`）、从数据库中读取数据（`GetDataFromDB`）等。此时我们就可以把这些相同的行为抽象到一个父类中。

现在假设你根据用户的输入，动态创建了某个数据类型的实例，那么你就可以把这个实例当作父类类型处理，当存储数据到数据库时，就可以调用父类定义的`SaveDataToDB`方法，最终执行的是子类实例的`SaveDataToDB`方法，从数据库读取数据也是一样。

在 C++ 代码中使用多态特性是有性能损耗的，不过这些性能损耗微乎其微，只有在性能高度敏感的应用中才应该考虑减少使用这个特性。

> 我们应当忘记小的性能改善，97% 的情况下，过早的优化就是万恶之源。 —— 高德纳
> 
> 以效率之名犯下的计算机之罪比其他任何一个原因都多。 —— 威廉·沃尔夫

总结
--

至此，我们已经把面向对象的三个基本特征介绍完了（封装、继承、多态）。我个人认为掌握这三个基本特征是有次序的，**先掌握封装，再掌握继承，最后掌握多态**。它们的价值也是依次递增的，封装的价值小于继承，继承的价值小于多态。多态才是面向对象的核心。相信你在业务开发过程中娴熟地掌握了这些技能之后也会得出类似的感悟。

本节课我们从一个例子出发，讲解了 C++ 面向对象继承和多态的知识，不过这节课的内容并没有涵盖所有的知识细节，比如多重继承、私有继承、友元函数等。但我觉得这些知识相对来说应用场景比较少，等大家用到之后再去查阅资料学习也不迟，不要在这里陷入知识细节的深渊。

下一节，我们将介绍智能指针及资源获得即初始化 RAII 惯用法相关的知识。