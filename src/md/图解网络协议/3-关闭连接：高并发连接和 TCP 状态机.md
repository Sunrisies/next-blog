讲完了`TCP`协议连接**建立**和**传输**的基本原理和过程，以为就结束啦？

那就高兴得太早，因为`TCP`不仅仅只有连接的建立和传输，关闭连接也还有很多值得关注的问题。最开始提出的`长短连接选择`的问题和`关闭异常`的问题还没有回答，让我们带着这两个问题一起来看一看关闭连接的原理以及过程吧！

关闭连接：为什么大家关心“关闭连接”的过程？
----------------------

`关闭连接`是`TCP 状态机`的一环，但比起`TCP 协议`要达到的目的来说，可能乍看起来似乎并不那么重要，“不就是关闭连接吗？”可能你会这么说。然而实际上却非常重要。`TCP`的整个`生命流程`都很关键，不仅包括`连接建立`的过程、`数据传输`的过程，也包括`连接关闭`的过程。

在实际生产活动中，大家都很关注`TCP 关闭连接`的过程，主要原因是现在系统的`并发量`**很大**。系统并发量大，往往意味着连接多，比如成千上万，甚至更多。`TCP 连接`是衡量系统并发量的最重要因素之一，如果关闭连接出现了异常，系统就容易在高并发环境下出现异常，影响系统的运行。

所以关闭连接非常的重要！那么什么时候关闭连接呢？

### 关闭连接：选择时机？

什么时候关闭连接其实就两个选择，一是传输完数据之后马上关闭连接，二是保持较长时间的连接，后续有数据要传输的时候还可以继续使用这个连接传输数据。一般称第一种情况为`短连接`，相应的第二种情况称为`长连接`。

首先说到连接，因为建立连接是需要分配资源的，Linux系统默认每个进程的最大并发连接数（其实是文件描述符数量，每个连接都会分配一个文件描述符）为1024，可通过修改配置文件调整。服务端使用5元组（`protocol、localIp、localPort、remoteIp、remotePort）`确定一个连接。

回到文章开头提出的**长短连接选择的**问题，客户端收发数据的时候应该选择长连接还是短连接呢？

`短连接`一般只会在`Client`和`Server`之间发起一次**请求响应**操作，任意双方都可以主动关闭连接。`短连接`管理起来比较简单，存在的连接都是**活跃的**连接，不需要额外的控制手段。比如，客户端`浏览器`访问服务器的时候一般使用短连接，`Web 服务器`收到请求并**传递数据**后会马上关闭连接；但`HTTP`请求也有头部字段`Connection: Keepalive`来让服务器不要马上关闭连接，并且使用`Keep-Alive:xxx`头部来表示维持多长时间的连接，`Keep-Alive`的默认连接保持时间是 60 秒。

长连接可以保持较长时间，只要没有客户端或服务端主动关闭连接，从而省去了建立和关闭连接的操作，减少了CPU和内存资源的使用。但是，长连接的并发连接数需要谨慎控制，因为一个系统可以接受的连接数量取决于其资源和网络带宽等因素。

所以怎么选择呢？对于`用户量大、并发量大、请求频率高`的应用系统，建议使用短连接。这是因为长连接会耗费服务端的大量资源，而且保持上百万的长连接会给服务端带来巨大的压力，甚至可能会导致崩溃。使用短连接可以减轻这些问题，因为连接会很快关闭，同时打开的并发连接也不会太多。如果必须使用长连接，也要尽量缩短保持连接的时间，例如浏览器默认的 Keep-Alive 时间为 60 秒。

而对于并发量小、性能要求高的应用系统，可以选择具有“无限期时间”的长连接，如MySQL连接池和Redis等DB的连接池。

需要根据实际使用情况来决定使用长连接还是短连接，时间的长短是相对的。此外，连接的双方都可以在任何时刻关闭连接，以控制并发连接对当前系统的影响。

### 关闭连接：如何完善地关闭连接？

高并发情况下如果不能正确地关闭连接，将引起非常大的麻烦。

在高并发场景下，关闭连接就是要达到这样的目的：一点多余的资源都不要占用。这就像一对异地的情侣写信分手的场景，分手分得彻底，不要产生什么误会。

#### 异地分手场景

假设小花和小草是异地的情侣，我们可以用如下简单的语言描述分手过程：

*   首先，小花想分手了（并且不会再反悔）。
    
    1.  小花给小草写了一封挂号信，表示自己想要分手。
    2.  小草收到信，`邮局`将信件送达的信息反馈给小花。
*   小草知道了小花的意图，同样也想分手，于是爽快地答应了，于是小草这样做：
    
    1.  小草也写挂号信，表示自己同意了分手。
    2.  小花收到信时，同样的，邮局也将这个送达的信息反馈给小草。
    3.  **小草收到反馈，于是就默认分手成功。** 愉快地整理好心情！
    4.  最后，小花也默认分手成功，愉快地整理心情！

但也存在这种情况，小草知道了小花的分手意图，但就是不想分手。比如还存在没有清算的资产，或者小草根本就不想分手，那小花就无法单方面分手成功，假设法律上承认情侣关系，那这就还是情侣关系！

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b455b66227f492e95b87f084f266802~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1968&h=758&s=70721&e=png&b=e9ecef) 上面的过程也还可能存在异常，当小草写出的回信被小花收到了，邮局会给小草回执，但是邮局给小草的回执是否一定收到呢？如果小草**没收到最后的回执**，就会继续写信来表示自己的意愿。所以小花在收到信后不要马上就默认分手成功，而是先等待一段时间，发现小草也没有再次写信过来表达分手意愿，那么就默认小草已经分手了。

#### 怎么设计关闭连接的交互？

关闭连接的交互完全可类比于上面分手的交互，只是也要合理地处理其他异常情况。

`TCP`要怎样设计这关闭连接的过程呢？实际上`TCP`用了**形象的语言**和**状态机**作为工具来处理`TCP`关闭的过程，也对异常情况做了很好的处理。

虽然`TCP`连接是复杂的，但是将`TCP`流程设计为状态机可以让复杂的事情变得井井有条。客户端和服务器的交互动作触发了状态的变化，设计为状态机保证了`TCP`生命周期的每一个节点都得到了完善的处理。

在聊`TCP`**设计思路**的时候给出了建立连接的状态变迁图，描述了 TCP 连接建立的过程，本文主要描述 TCP 释放连接的状态变迁过程，两者结合的整体状态我也画了一张图，一起来看一下吧！

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/105705245ef84510a3b84cebc49159c8~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=2521&h=1008&s=278419&e=png&b=ffffff)

你可以参照上图按照发包的顺序描述一下这个状态机，假设图中上方的客户端名字是 A，下方的服务器名字是B。

*   让我们先复习一下连接建立的过程。
    
    1.  A 发出第 1 个包`Syn`，处于`Syn-Sent`状态。
    2.  B 收到第 1 个`Syn`包，处于`Syn-Rcvd`状态，并且发出第 2 个包`Ack+Syn`。
    3.  A 收到第 2 个`Ack+Syn`包后，回复第 3 个包`Ack 回执`，状态从`Syn-Sent`变为`Established`。
    4.  B 收到第 3 个`Ack 回执`，状态也变为`Established`。
*   连接建立，A 和 B 开始传输数据，数据传输的包都是用的**没有特殊标记的包**（图中的第 4 个包）。
    
*   连接建立后，任意方都可以关闭连接。
    
    1.  上图中，A 主动关闭连接。A 发出第 5 个包`Fin`，状态从`Established`变为`Fin-Wait1`。
        
    2.  B 收到第 5 个包，发出第 6 个包`Ack 回执`，状态从`Established`变为`Close-Wait`。
        
    3.  A 收到第 6 个包，状态从`Fin-Wait1`变为`Fin-Wait2`。
        
    4.  直到处于 Close-Wait 状态的 B 发出第 7 个包`Fin`，B 状态从`Close-Wait`变为`Last-Ack`。
        
    5.  A 收到第 7 个包，回复第 8 个包`Ack 回执`，状态从`Fin-Wait2`变为`Time-Wait`。
        
    6.  这之后 B 可能收到第 8 个包`Ack 回执`，也可能超时没收到第 8 个包`Ack 回执`。
        
        *   如果 B 收到第 8 个包`Ack 回执`，则连接变为`Closed`状态，A 等待一定时间后也关闭连接；
        *   如果超时没收到第 8 个包`Ack 回执`，则重传第 7 个包`Fin`，也就是图中的第 9 个包`Fin`；
        *   同样，A 收到第 9 个包`Fin`后，重置`Time-Wait`的计时器。

从图中给出的`9`个数据包，我们已经很能够理解`TCP`完整的状态机过程了。这样设计关闭连接的交互看起来也合情合理。无需过多的解释，我们知道各种状态名字就是很精简的语言描述，描述了当前连接所处的状态、是怎样来的、将会变成怎样。

关闭连接异常处理
--------

上面的状态机只是对通用的正常情况做了一个描述，`关闭连接` 还会存在很多异常。比如，为了解决分手过程可能的异常，我们看到`TCP`四次分手机制的`TIME-WAIT`状态会有一个等待的时间，但是 A 的连接的等待状态计时器要等待多久呢？

### 关闭处理机制：`TIME-WAIT`等多长时间？

`TCP`定义`MSL`是**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。一般认为是半分钟。`2MSL`即两倍的`MSL`，`TCP`的`TIME_WAIT`状态也称为`2MSL 等待状态`，也就是等待两倍`MSL`的时长。A 在正常情况下，`TIME-WAIT`状态等待`2MSL`时间主要目的是：以防最后一个给 B 的`ACK 回执`却没被收到。B 没收到`ACK 回执`，则会超时重传第三次挥手的`FIN 包`，如下图蓝色箭头的走向：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36fc71f33e0e4e3c8c8ef930590ef612~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=511&h=492&s=51729&e=png&b=ffffff)

这样 A 可以再次受到`FIN 包`并`ACK`。A 收到**重传的 FIN 则再次 ACK，`TIME-WAIT` 等待状态和计时器也会重置**。如果 A 未再次收到 FIN 包，有可能对方已经关闭，也有可能还是网络异常，但再等也没有意义，只会平白无故地浪费网络连接资源，所以**等待 2MSL** 的时间后也会关闭连接。

如果对方收到了`ACK 回执`，那么皆大欢喜。只是最后的等待`2MSL`可能比较久，对于高并发系统可能会导致系统的**可用连接耗尽**，从而无法打开新连接。

### 问题处理：如果很多的连接处于关闭连接的某个中间状态

就像上面说到的那样，如果很多的连接处于关闭连接的某个中间状态，比如`TIME-WAIT`，对于高并发系统可能会导致系统的**可用连接耗尽**，从而无法打开新连接。

#### 大量的`TIME-WAIT`状态

当系统出现很多`TIME-WAIT`状态的时候，为了更好地回收资源，我们可以设置一些系统参数：

*   `net.ipv4.tcp_fin_timeout` 修改系統默认的`TIMEOUT`时间，也就是`TIME-WAIT`等待的时间；
*   `net.ipv4.tcp_tw_reuse = 1` 表示开启重用，允许将`TIME-WAIT`重新用于新的`TCP`连接，默认为 0，表示关闭；
*   `net.ipv4.tcp_tw_recycle = 1`表示开启 TCP 连接中 `TIME-WAIT sockets` 的快速回收，默认为 0，表示关闭。

修改之后，再用命令查看 TIME\_WAIT 连接，如下：

    netstat -ant |grep "TIME_WAIT" |wc –l
    

采用 **TCP 这种 4 次挥手**的机制会有等待的问题，虽然可以采用修改系统参数的方式来避免等待，但是这样可能导致对方的连接没有正常的关闭。

大胆设想一下，是否可以采用 5 次挥手呢？

当对方收到最后一个 ack 的时候，准备关闭连接了，如果再发送一个最后的 ack 过去，那处于 time-wait 的连接就可以及时关闭了，不再需要等待。

你是否认可这种设想呢？或者你有没有更好的办法？欢迎在评论区留言。

#### 大量的`CLOSE-WAIT`状态

比如一开始提出的问题：为什么客户端连接池很多连接处于`CLOSE-WAIT`？

具体背景是这样的：有一个**同步数据的应用**从服务器并发同步大量数据，这个过程比较慢，于是想着怎么去加快同步的速度。首先**查看网络连接**，发现设置的最大 20 个连接的连接池里面还有很多处于`CLOSE-WAIT`状态的连接。

针对客户端连接池中处于 `CLOSE-WAIT` 状态的连接，我们进行了分析并找到了解决办法。我们的应用在与服务器进行大量数据同步时，发现连接池中有很多连接处于 `CLOSE-WAIT`状态。通过分析，我们发现这是因为服务器在某些情况下异常关闭了连接，而我们的应用连接池并没有发送 `FIN` 释放包。为了解决这个问题，我们等待连接池中的连接全部处于正常状态后，同步速度得到了大幅提升。此外，如果对方没有回应关闭连接，我们可以使用 `RST` 包来强制关闭连接。

总结
--

现在，你是否更可以理解 TCP 连接是有状态的连接了呢？

**TCP 设计的初心（不丢包和按序交付）一直表现在 TCP 协议实现的每一个细节里面，而 TCP 状态机是保证 TCP 高并发的关键。**

TCP 状态机是 TCP 这棵大树的骨架，理解了这个状态机之后，我们可以继续学习其他相关的知识，这些知识都是在这棵树上枝繁叶茂，难度也会变得比较小。例如，TCP 心跳和 TCP 拥塞处理。TCP 的心跳包机制通过 SO\_KEEPALIVE 选项实现，默认情况下 Linux 系统设置为 2 小时的心跳频率。TCP 拥塞处理是考虑网络拥塞的处理机制，我们后续会再仔细聊聊这个主题。

有任何问题，欢迎在评论区留言哦～