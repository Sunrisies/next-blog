本小册已涵盖了许多网络协议的内容，但是我们还未涉及计算机网络中最基础的寻路算法。

因此，该文将探讨`网络中路由和寻路`算法的基本思想。除了`IP 寻址`，我们还将讨论`P2P 节点和资源`的寻址，探讨庞大的分布式计算机网络的寻路更多可能性。

初探计算机路由
=======

[第七节](https://juejin.cn/book/7209116225988165667/section/7214846119883309108 "https://juejin.cn/book/7209116225988165667/section/7214846119883309108")介绍了`IP 层次`的划分，帮助我们了解如何在网络世界中找到另一个主机。实现`IP`协议的机器维护一张路由表，记录其他网络和主机的地址信息及到达这些地址的路径，这些路由信息有助于选择最佳路径发送数据包，确保数据能够正确到达目的地。

你会用 route 命令吗？
--------------

使用`route`命令可以查看主机或路由器上的路由表。

    # route 
    Kernel IP routing table
    Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
    default         9.134.64.1      0.0.0.0         UG    0      0        0 eth1
    9.0.0.0         9.134.64.1      255.0.0.0       UG    0      0        0 eth1
    9.134.64.0      0.0.0.0         255.255.240.0   U     0      0        0 eth1
    192.168.0.0     9.134.64.1      255.255.0.0     UG    0      0        0 eth1
    192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 docker0
    

这个输出显示了路由表的信息，各个字段的含义如下：

*   `Flags`列表示路由的标志，包括`U`表示路由已启用，`H`表示目标是主机，`G`表示使用网关。
*   `Gateway`列表示网关所在的主机名或 IP 地址。
*   `Genmask`列，即子网掩码，是一个 32 位的 IP 地址，用于将 IP 地址分割成网络标识和主机标识两部分。通过将`Genmask`和数据包的目的 IP 地址进行按位`&`操作，如果结果与`Destination`列的值相同，则将数据包转发到此`Destination`所在的网络，否则将无法转发到此`Destination`所在的网络。
*   `Destination`列表示路由的目标网络。

以下按照子网掩码优先级从高到低排列，列出了这台主机可达的网络列表：

1.  子网掩码`255.255.255.0`，目标网络为`192.168.10.0`，实际是这台主机上安装的`Docker`环境的网络。
2.  子网掩码`255.255.240.0`，目标网络为`9.134.64.0`，是一个`B 类`网络，也是当前机器 IP 所在的局域网。
3.  子网掩码`255.255.0.0`，目标网络为`192.168.0.0`，表示当前局域网所在的网络，是一个`私有 IP 地址`，通常被用作内部网络中的地址，需通过网关`9.134.64.1`转发。
4.  子网掩码`255.0.0.0`，目标网络为`9.0.0.0`，是一个`A 类`网络，通过网关`9.134.64.1`可达。
5.  如果以上规则都不符合，则使用默认路由，通过网关`9.134.64.1`将数据转发到公网（目标网络为`0.0.0.0`）。

路由器的选择是基于子网掩码最长匹配原则进行的，即匹配目标地址与路由表中已有的网络地址中最长的前缀匹配项，并将数据包转发到该条目对应的网关上。如果存在多个匹配项，路由器会选择前缀长度更长的条目作为最佳匹配项。

路由器的路径寻找
--------

使用 `route` 命令可以确定网关，通常是指路由器的地址，例如 `9.134.64.1`。这意味着主机将通过该 IP 地址的路由器进行寻路。那么路由器是如何进行寻路的呢？路由器会根据自己的路由表，计算出数据包的最佳路径，并将其转发到下一个路由器，直至数据包到达目的地。

路由器的配置有两种方式：`静态配置`和`动态算法`。`静态配置`需要手动设置路由器的路由信息，但不适用于大型网络且缺乏灵活性。 路由器寻路的`动态算法`的大致思想是基于`路由选择协议`的。它通过路由器之间交换路由信息来计算出最佳的路由路径，并将这些信息存储在路由表中。常见的动态算法有`RIP（Routing Information Protocol）`、`OSPF`、`BGP`等。这些算法会根据网络拓扑的变化不断更新路由表，以保证数据能够快速、准确地传输到目的地。

使用距离向量算法的 RIP
-------------

`距离向量算法`是网络层路由算法中最简单的一种算法之一。路由器将自己的`整个路由表`转发给相邻的路由器，这个路由表是`距离矢量表`。

路由器通过使用`IP 广播地址`和自己的邻居来交换信息。路由器每隔一定时间，比如`30S`（具体看路由器的配置）广播一次自己最新的路由表。

`RIP`每条记录通常包含以下关键信息：

*   目的网络或主机的`IP 地址`；
*   到达目的地的最短距离（通常以`跳数`表示）；
*   下一跳路由器的`IP 地址`。

其中，最短距离表示到达目的网络或主机所需经过的路由器数量，也就是跳数。而下一跳路由器的 IP 地址则指示了路由器应该将数据报文发送到哪一个邻居路由器。

路由器和邻居交换信息，下图是 3 个节点交换了信息的一个非常简单的场景。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9344698e591a4bbdbe48d502c4b532c4~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=897&h=441&s=36186&e=png&b=e9ecef)

图中一共有 `R0`、`R1` 和 `R2` 3 个路由器节点。

*   `R0`的邻居是 `R1` 和 `R2`，`R0`得到一个这样的距离向量`[(R1，1),(R2，1)]`，到 `R1` 和 `R2` 的距离都是1。
*   `R0`得到了自己的距离向量列表，于是也将这个距离向量表告知自己的邻居 `R1` 和 `R2`。
*   因为 `R1` 被通告了一条新的路由(`R2，1`)，该路由在 `R1` 结点的路由表中原不存在，但得到这个信息后，`R1` **加入这条新的路由，得到(`R2，2`)，也就是通过 `R0` 可以到达 `R2`，需要经过的跳数是2。**
*   `R2`同理能得到 `R1` 的路径。

同理，下图中的 3 个同样拓扑的路由器`R3`、`R4`和`R5`也通过交换向量表得到了所有的可达节点向量表。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/375d764987b2440ba578733f491eee9d~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=849&h=395&s=34151&e=png&b=e9ecef)

如果我们让这两个子网联通，也就是在`R0`和`R3`之间接入一条网线来联通，如下图所示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4f9ae1baa0d4e98964d02b974880e22~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1296&h=860&s=70826&e=png&b=ffffff)

联通之后， 很快`R0`和`R3`作为相邻的节点就会交换信息，我们来看看信息的变化吧！

*   `R0`获得`R3`的视角，更新自己的的距离向量，变为了`[(R1, 1), (R2, 1), (R3, 1), (R4, 2), (R5, 2)]`。

> 注意这里的表达为了简明，并没有将经过的下一跳画上，`(R4, 2)`的通过路径是`R3`。

*   接着，`R0`和`R1`交换信息，`R1`更新自己的距离向量，获得了全局的拓扑图。
    *   `(R3, 2, R0)`，到`R3`需要经过`R0`。
    *   `(R4, 3, R0)`，`R0`表示通过的下一跳，先经过`R0`再经过`R3`，最终可到达`R4`。
*   `R0`和`R2`继续交换信息，`R2`更新自己的距离向量，也获得了全部可达的距离向量表。

其他路由节点同理，最终都获得了全部可达的距离向量表。

以上可以看出，距离向量算法的基本思想很清晰简洁！

### 最短路径优先

当然还有一些问题是需要考虑的，比如两个路由器之间存在的路径可能不止一个，那么应该选择哪一个路径呢？

还是上面的拓扑图，假设此时又加入了一个路由器 `R6`，`R6`先和`R4`联通，如下图左侧所示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5effb3a3c3cd4ae3816d5baf692e1abb~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=2595&h=1049&s=148694&e=png&b=e9ecef)

对于`R0`来说，`R0`的距离向量表里面会新增一个记录（`R6`,3,`R3`），这表示`R0`到`R6`通过的路径，需要先经过`R3`去达到的。

然后，假设在`R6`和`R1`之间也加入了一条链路，如上图右侧所示。经过两次间隔时间后，`R0`从`R1`处得到自己到`R6`可以通过`R1`且跳数是 2，该路由与当前使用的路由 3 相比，有更短的距离。这样就可以用更短的新路由替换路由表中到达同样目的地的现有路由，即 `R0`的距离向量更新`R6`的记录为(`R6`,2,`R1`)。

这样之后，通过路由器的主机到`R6`的主机后，会选择(`R6`,2,`R1`)这条路由，路由器就是按这种基本策略来选择路由寻路的。

在距离向量算法中可能存在一些问题，比如会增加`网络的负担`，而且在距离向量算法中，最严重的问题是存在`动荡`。

解决 RIP 动荡问题：OSPF 优化方案
---------------------

如下图这是一个例子：如果在网络中断开了 `R0` 到 `R3` 之间的链路，当 `R0` 需要到达 `R5` 时，以下情况会发生：

*   在链路中断之前，从 `R0` 到 `R5` 的距离为 2，下一跳是 `R3` 。
*   当链路和 `R3` 断开时，`R0` 将无法到达 `R5`。
*   `R0` 可能会在一段时间内失去到达 `R5` 的消息，直到 `R6` 告知 `R1`，然后 `R1` 再将消息传递给 `R0`，大约需要多次广播的延迟。
*   但是，在经过多次信息交换后，又能够发现到达 `R5` 的路径（`R5`，5，`R1`），距离为 5。

这种突然失去联系的情况被称为网络动荡。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf32f3fecf7b4dec9bfe5a3529f9406d~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1462&h=891&s=74958&e=png&b=e9ecef)

在 RIP 协议中规定的最大跳数为 `15`，`16` 跳或以上则被视为目的网络不可达。`根本原因` 是如果跳数变大，则 `一致性` 和 `动荡问题` 将会扩大，使得网络几乎不可用。因为 RIP 协议中规定的最大跳数为 `15`，距离向量算法只适合**小型网络**。而大型的网络环境，`OSPF 协议`可以完美地解决。

在 OSPF 协议中，`网络拓扑图`是指整个 OSPF 域内的所有网络、路由器、链路和链路的状态信息。每个 OSPF 路由器都会维护一个`拓扑表`，其中记录了该路由器所在的 OSPF 域内的所有路由器和链路信息。

拓扑表中的每个条目都包含了一个`链路状态记录`，包括该链路所连接的路由器、链路的类型、链路的状态信息以及链路的成本等。通过交换`链路状态广播包`， OSPF 路由器之间可以互相更新自己的拓扑表，从而计算出到达目的网络的最短路径。

与 `RIP` 协议相比，`OSPF` 协议能获得全局地图，然后运用了`图查找`最短路径的知识（计算机算法的基石之一）有效避免了动荡的问题。

接下来我们将类比计算机网络 `IP` 的寻路，也深入去探讨 `P2P` 文件传输中的寻路机制，之前我已经讲过 `P2P`，但并未深入探讨其文件传输的寻路机制，现在我们可以趁此机会一探究竟。

P2P 中的寻路
========

几乎所有人都已经使用过 `P2P` 了吧，`BT` 种子和磁力链接基本都是 `P2P`，文件分布式地存储于各个用户的节点上，而不是存在于一个中心服务器上。每个节点既是提供者又是用户，这种系统具有高可用性，即使一两台机器下线也不会导致整个服务无法使用。

那么，`P2P` 系统是如何去中心化并实现高度自治的呢？

中央服务器 vs. 去中心化：哪种思路更好？
----------------------

`P2P`网络需要解决的最重要问题之一是如何确定用户从哪个节点请求资源。

在第一代`P2P`网络中，通过设置中央服务器来管理资源位置。用户在想要发布资源时，需向中央服务器提供资源和自身节点信息。其他用户在请求资源时，需要先向中央服务器请求获取资源发布者的节点信息，再从资源发布者处请求资源。

`Track Server`通常用于`BitTorrent`这种基于`Tracker`的`P2P`协议中。当用户想要下载文件时，它会向`Track Server`发送一个查询请求，以获取当前可用的节点列表。`Track Server`会回复一个包含可用节点信息的响应，然后用户就可以通过这些节点下载所需的文件了。

> 需要注意的是，`Track Server`并不存储文件本身，它只存储节点信息，用于协调`P2P`网络中的数据传输。

另一种早期的`P2P`网络采用了不同的策略，它没有中心服务器。当用户请求资源时，它会请求所有相邻节点，这些相邻节点又会请求它们各自的相邻节点，并使用一些策略来避免重复请求，直到找到拥有资源的节点。换句话说，这是一种`广泛搜索`的方式。

中心化的方式查找效率高，但中央服务器成为整个系统的瓶颈；而去中心化的方式虽然不脆弱，但却比较慢。

去中心化算法 DHT
----------

P2P 网络存在一些不足之处，比如对等方之间的路由效率不高、节点数量有限等问题。分布式哈希表 `DHT` 是为了解决这些问题而出现的一种经典的分布式算法。

`DHT` 是一种分布式算法，它将整个网络中的节点组织成一个哈希表。每个节点维护一部分哈希表，用于存储和查找数据。当一个节点需要查找数据时，它可以通过哈希函数将数据映射到哈希表中的一个位置，并通过网络查找包含该位置数据的节点。

`Chord`算法是`DHT`思想的一种具体实现算法，让我们来看下。

### Chord 地址管理

`Chord` 使用 `m` 位整数作为节点和资源的唯一标识符，这些标识符是范围内的整数。将所有 `ID` 按顺时针方向排列成一个环，每个 `ID` 前面是其逆时针 `ID`，后面是其顺时针 `ID`。每个节点在环中定位自己的位置，对于具有 key 为 `k` 的资源，始终由 `ID` 大于或等于 `k` 的第一个节点负责，称负责 `k` 的节点为 `k` 的后继节点。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a221399ee7b4f5394ed6bb7f74f8d50~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1480&h=925&s=89333&e=png&b=ffffff)

可以看到上图 `m=4` 的圆环，每个资源和节点都可以使用 `4` 位编码，最大是 `15`。`15` 的后继节点是节点 `0`，`1` 的后继节点是 `1`，`6` 的后继节点是 `8`。

### Chord 路由算法

在 `Chord` 算法中，每个节点都保存一个长度为 `m`的路由表，最多存储 `m` 个其他节点的信息，以便于与它们通信。节点 `n` 的 `ID` 为 `n`，其路由表中的第 `i` 个节点表示为 `n+2^(i-1)`。通常，路由表中的第一个节点是 `n` 的顺时针方向的下一个节点，也称为 `n` 的后继节点。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/433aa0230a874852b4c731968f8e7a8c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.png#?w=896&h=463&s=48589&e=png&a=1&b=010101)

通过 `路由表`，我们可以快速寻址节点。当一个节点需要查找一个具有指定`ID`的节点时，它会从自己的 `路由表` 中选择一个最接近指定 `ID` 的节点进行查询。具体来说，节点会从自己的 `路由表` 中找到一个 `ID` 比指定 `ID` 小的最大节点，然后向该节点发送查询请求。如果该节点无法处理该请求，则该节点会将请求转发给它自己的 `路由表` 中，`ID` 最接近指定 `ID` 的节点，直到找到具有指定 `ID` 的节点为止。

在这个过程中，如果节点 `n` 在遍历自己 `路由表` 的过程中找到了一个 `ID` 比指定 `ID` 大的节点 `k`，那么它就会停止遍历并将查询请求发送给节点 `k`。这是因为节点 `n` 知道，如果某个节点的 `ID` 比指定 `ID` 大，那么它一定比节点 `n` 更接近指定 `ID`，因此向节点 `k` 发送请求可以更快地找到具有指定 `ID` 的节点。

假设一个节点 `n` 需要找到 `Key` 为 `k` 的资源所在的节点。首先判断 `k` 是否落在后继节点的区间内；如果是，则该 `Key` 由其继任者负责。否则，`n` 从后向前遍历自己的 `路由表`，直到找到 `ID` 大于 `k` 的节点，然后将 `k` 传递给该节点执行上述搜索，直到找到为止。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07a030eecac749dc8576ae155a98ae4c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.png#?w=449&h=484&s=32888&e=png&a=1&b=fefefe)

上图展示了从节点 4 查找 `Key 1` 的过程。节点 4 的路由表中有节点 8、11 和 14。它首先从后到前查找其路由表中 1 之后的第一个节点为 14，然后请 14 帮忙查找 1。节点 14 在其路由表中有节点 0、4、8；类似地，14 请求节点 0 帮助查找 1。最后，节点 0 找到它的后继者作为节点 1。

可以看到，整个查找过程就是一步步逼近目标节点。 距离目标节点越远，跳跃距离越长；距离目标节点越近，跳跃距离越短、越准确。 如果整个系统有 `N` 个节点，则搜索执行的跳转次数为 `logN`。

### 节点加入和离开

一个节点怎么加入`Chord`环呢？

加入 `Chord` 环的过程相对简单。新节点需要生成自己的 `ID` 并联系 `Chord` 系统中的任何节点请求帮助查找其后继节点。一旦找到后继节点，新节点会构建自己的路由表，然后通知其他节点更新其路由表，以表明自己的存在。最后，新节点只需联系其后继者即可检索它所负责的所有资源。

在 `Chord` 网络中，一个节点的故障会导致其后继节点也发生故障，从而破坏整个 `Chord` 环，导致查找和操作失败。

为了解决这个问题，一个节点通常会维护一个后继列表，长度为 `m`，其中包含多个后继节点。当一个后继节点发生故障时，该节点会在后继列表中搜索下一个可用的替代节点。

此外，一个节点的故障意味着该节点上的资源丢失。为了避免资源丢失，资源除了存储在负责该资源的节点 `n` 上外，还会存储在 `n` 的多个后继节点上。节点离开的处理与节点故障类似，但节点离开时可以执行一些额外的操作，例如通知其周围的节点立即将资源转移给其继任者等。

其实，如果你对一些分布式存储比较了解，你会发现 P2P 中 DHT 寻路的思想和分布式存储里常用的一致性哈希也是类似的，不仅保证查询的效率，还需要保证数据的可靠性。

小结
==

本文比较详细地介绍了查询目的地`IP`的计算机网络，它采用全球范围内的完全分布式思想，并且需要使用`路由器`和各种`网络寻路算法`来实现。

此外，我们还探讨了在`P2P`网络中寻路的方法，包括利用中央服务器发布和查找资源以及`分布式哈希表（DHT）`这种分布式自治查找思路。

这些知识对于理解计算机网络的基本原理和工作方式非常重要。