TCP 连接建立便可以传输数据了，连接的建立给后续数据传输打通了一条平顺的通道。就像一个老司机为厂家运货开车上路一样，对于整个运货过程，厂家和专业的货车司机都会做好统筹部署，关心货物的交付，也关心运货的安全和效率。比如，如果货车路上遇到事故无法继续运货时，我们肯定也要想办法调度，保证这批货能正常交付；另外，一个货车单独运货的效率肯定不如 10 辆货车；如果路上遇到拥堵，效率肯定不如一路畅通。

对应 TCP 数据传输，这里也是几个非常值得我们关注的点，比如`数据重传`、`流量控制`和`拥塞控制`。

让我们从一个视频上传的案例开始来了解 TCP 数据传输吧~

上传一个大视频
-------

首先我们看一个数据上传的例子，假设有 1.5G 的视频要上传，如下图所示，是上传的页面。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cd06fcfff394ca883f36515997dffd1~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=2293&h=569&s=67481&e=png&a=1&b=a6b6e9)

通过上传的界面，我们能宏观了解到视频正在上传以及目前上传的进度，但是整个数据上传却不止如此，1.5G 的视频其实会被拆分为一个一个的`数据包`，从 client 端通过复杂的网络运送到 server 端，不同的网络情况所需要的时间也不相同。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1edbeaaa7856427d97dec120cda1db44~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1071&h=420&s=42463&e=png&a=1&b=6a36d2)

其实，这个视频的上传就像卡车司机运送货物一样。当一个工厂要把自己生产的产品运送到很远的某个仓库去，这些货物就会被装上货车，然后这些货车可能会通过岔路、国道和高速公路，最终将货物运送到目的仓库。而计算机网络也正像运输车辆的交通网络一样，会有高速网络、出口和低速网络。最终到了目的地仓库后，货车卸下这些货物，并且将其和一起装载的同一批货物按要求堆放在一起；这也和视频数据最终被交付给视频应用程序是一样的。

你看，运货涉及的细节和我们上传一个大视频到服务器的场景是一样的。

遇到丢包怎么办？——数据包重传机制
-----------------

首先，让我们考虑第一个问题，如果货车路上遇到事故怎么办？此时货车无法继续运货，但厂家肯定也要想办法保证这批货能正常交付，在得知出现问题之后，就派别的车来继续运送这批货或者直接从厂里重新运送一批同样的货物。这就像数据在网络中传输时难免会`丢包`一样，跟厂家的做法类似，TCP 协议会采用一些`重传机制`。

所以我们就来看一下数据传输的重传机制吧。

和 SYN 包等重传一样，在数据传输过程中如果发生了 ACK 超时，客户端便会将这个包重传。TCP 报文重传采取指数加倍策略，而且因为 TCP 数据传输要保证不丢包，所以一般来说 ，重传次数没有设置上限，会不断重传被丢弃的包，直到正常交付。但有些系统的实现可能不一样，采用容忍度略低的处理方式，多次重传未果后可能会 RESET 重置该 TCP 连接。

另外考虑一个场景，如果网络很顺畅，但是有一个包在传输过程中意外丢失了，而重传的超时时间相对来说又比较长，则这个丢失的包可能会阻塞之后的一批包的交付。客户端可能会收到好多次这个丢失包对应的 ACK，比如如果收到了 10 次相同的ACK，则意味着这个包后续的 10 个包都阻塞在对方的接收窗口。

> 重传超时时间一般使用`RTO`来表示，Retransmission TimeOut，是指如果发送端发送了一个数据包，但没有收到对应的确认消息，那么发送端会认为该数据包丢失了，于是会在一定时间后重新发送该数据包。这个时间就是RTO。RTO的计算通常是基于最近若干个数据包的RTT来计算的，通常会考虑到网络的延迟、波动性等因素。

> RTT（Round-Trip Time）是指数据包从发送端发送出去，到接收端收到并发送回确认消息的时间，再到发送端收到确认消息所经历的时间。简单来说，就是网络中一次数据传输的往返时间。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c935adfbf2374f439f2080494e57ed42~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=548&h=307&s=36466&e=png&b=868e96)

为了增加传输效率，还有一种快速重传机制：**规定当客户端收到三次同样的 ACK 则触发包的快速重传**。快速重传方式不以时间驱动，而是`数据驱动`，能使得在这种场景下的重传更有效率，减少后续数据包在接收端的阻塞。

TCP数据传输的最大重传次数与建立连接的重传次数是不同的。在Linux系统中，你可以通过修改系统内核参数来设置TCP数据传输的最大重传次数，而且这个次数可以被设置得非常大，没有明确的限制。具体来说，你可以通过修改`/proc/sys/net/ipv4/tcp_retries2`参数来设置最大重传次数，这个参数的默认值是15，表示TCP传输最多重传15次。这意味着如果某个数据包一直没有收到，重传通常需要几十分钟才能完成，这保证了数据传输的可靠性。 如果你想修改这个参数，可以使用命令`sysctl -w net.ipv4.tcp_retries2=<value>`，其中`<value>`是你需要设置的最大重传次数。请注意，当你将这个值设置得非常大时，如果没有收到数据包的ACK，读写数据的过程可能会一直卡在那里。

综上，TCP 包的重传机制可总结为如下关系图，你可以点开大图再次 check 一下～

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/994b178189494a8780dec45e0f551209~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1649&h=788&s=232301&e=png&b=3374ca)

传输效率低？ ——并发提升吞吐量
----------------

现在，让我们来考虑第二个问题：对于这个厂来说，有大批的货物需要运送，但是如果只有一个卡车传送，那么效率就很低；针对这个效率低的问题，应该怎么做来提升效率呢？如果有一个车队，比如 10 个卡车`并发`就会快很多。

这对于视频上传也是同理，让我们看一下 TCP 传输是怎么提升效率的。

### 如果只有一个货车？——预估总传输时长

就像只有一个货车的车队一样，如果一个包一个包地发送（一发一收），等收到前面包的 ACK 之后再发出下一个包，会使得吞吐率非常低。如下，你可以试着计算一下 1.5G 的视频上传要多久。

    假设RTT是10ms，一个TCP包是1500B，
    则10000S可以传输1.5G的数据，也就是说这个视频上传需要大约167分钟
    

这个速度实在太慢了，实际上传速度比这快得多，这是因为 TCP 传输的并发量不止 1 个，就像拥有多台货车的车队一样。假设有 10 台货车，也就是说并发量提升到 10，你可以很容易估算出此时需要的时长是多少。

    同样假设RTT是10ms，一个TCP包是1500B，
    因为并发量是10
    则1000S可以传输1.5G的数据，也就是说这个视频上传需要大约16.7分钟
    

可以看到，提高并发便提升了传输吞吐量，但具体应该**怎么设置并发**，交付先后怎么处理，这都是 TCP 协议要考虑完善的。

现在让我们看看 TCP 在提升吞吐量上具体是怎么做的。

### 提升吞吐量

发送端同时发送很多包到网络上，这些还没有收到 ACK 的包需要缓存在发送方内核，另外还没交付给对端应用程序的包也需要先缓存起来。所以，对于这两种需要缓存的场景，内核分别引入了**发送窗口**`swnd`和**接收窗口**`rwnd`的概念，来记录在途数据（inflight packets）的情况。

让我们先看看发送方的窗口。

#### 发送方滑动窗口：在途发送数据

虽然窗口越大越可以提高吞吐率，但是因为`系统资源有限`，发送窗口不能是无限大的。另外在传输过程中，发送窗口也会考虑接收方的接收能力，如果接收方处理不过来更大的吞吐量，发送方就应该减少发送窗口（发送窗口的大小不会超过接收窗口）。

发送缓冲区根据在途数据的发送情况（比如是否已发送到网络和是否收到了 ACK）被划分为几个区域，发送端的 socket 缓冲区示意图如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80f27e5e269e4c789ea872979c2dc5da~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1436&h=883&s=167208&e=png&a=1&b=0d4b92)

发送缓冲区有两个指针将这块区域从右到左分为 `3 个区域`。

*   绿色区域位于 ACK 指针右边，是**已发送并收到 ACK 确认的包**，这里的包（序号 1、2、3）将被内核清除掉。
    
*   红色区域位于 ACK 指针左边，且在发送指针（发送窗口的起点）右边，这是**已发送但未收到 ACK 确认的包**（序号 4、5、6）。
    
*   蓝色区域位于发送指针左边，且是发送窗口内还没发送的包（序号 7、8、9）。蓝色区域是发送方的可用窗口。`可用窗口越大，基本就意味着当前吞吐量越大`。
    
*   红色区域和蓝色区域被绿色虚线框住，是当前的`发送窗口`。
    

ACK 指针示意当前收到 ACK 的包，是发送窗口的起点；发送指针示意当前可以发送的包，但不能超出发送窗口。如果认为发送窗口大小恒定，我们可以这样计算可用窗口的大小：假设红色区域的大小为 notAckedSizenotAckedSize notAckedSize，目前的发送窗口（图中绿色虚线框住的地方）大小为 swndSizeswndSize swndSize，则蓝色可用区域大小为 swndSize−notAckedSizeswndSize-notAckedSize swndSize−notAckedSize。

其他超出接收方处理范围的发送缓冲区的包（最左边），随着 ACK 指针的左移将会滑入发送窗口，便可发送了。

从发送窗口，我们看到了发送方是怎么设置并发大小的和怎么确认发送了数据的。这里留一个问题给你：有没有可能序号 3 的包没 ACK 确认之前，而序号 4 的包 ACK 确认了呢？

#### 接收方接收窗口：在途顺序交付

同样的，接收方也需要利用到接收窗口来保证交付顺序。接收缓冲区根据在途数据的发送情况（比如是否已发送 ACK 和是否已经交付给上层应用程序）被划分为几个区域，接收端的 socket 缓冲区在某个时刻示意图如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/240243d6b79c4e7f920b64d860496132~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1436&h=883&s=116329&e=png&a=1&b=0d4b92)

图上的 ACK 指针将接收缓冲区从右到左分为 `2 个区域`。

*   绿色区域位于 ACK 指针右边，是**收到并发送了 ACK 确认的包**，这个区域的包（序号 1、2、3）在等待上层的应用程序来取。
    
*   红色区域位于 ACK 指针左边，是当前的`接收窗口`。在接收窗口内的序号是当前可以接收的包（序号 4、5、6、7、8、9），比如序号 5 到了，就放到 5 的位置，序号 9 到了，就放到 9 的位置。
    

接收窗口和应用程序获取数据的能力有关，如果应用程序卡顿导致一直不从 socket 缓冲区获取数据，绿色区域会变大，则红色区域变得越来越小；如果相反应用程序取包很快，绿色区域会变小，红色区域变大。

为了保证包到达的顺序，发送方会使用递增的序列号。假设接收端未收到编号为 4 和 5 的包，而后面 6～8 编号的**包都收到了**，那 ACK 指针还是停留在 4（下一个希望收到编号 4 的包），并不会到 9。当发送端**超时重传（或者快速重传）4 和 5 的包**之后，接收端才会将 ACK 指针指向 9。因为接收窗口的这个特性，就能保证数据包被顺序交付给上层的应用程序。

再留一个思考题给你：上面的场景丢包（接收端未收到编号为 4 和 5 的包，而后面 6～8 编号的**包都收到了**）会引起发送窗口怎样的变化？

#### 流量控制：窗口大小反压

到这里，我们也就知道了接收方窗口是怎么影响到并发大小的，以及怎么确认数据的了；也知道如果上层的应用程序处理能力慢，则可能导致**接收窗口大小变为 0**，此时发送方就不能再发送数据了！

TCP 包头的 16bit 的`窗口大小`字段是接收方反馈给发送方的接收窗口大小，发送方根据收到的窗口大小调整自己的发送窗口大小，使得不会超过接收窗口的大小。于是，发送方滑动窗口和接收方滑动窗口一起配合使得发送方的发送速度和接收方的处理速度相匹配，这就是 TCP 协议为应用程序提供的**流量控制机制**：一方面尽可能使得发送方能达到更大的吞吐量，另一方面也消除了接收方缓存溢出的可能性。

总结和思考问题
-------

本文从上传一个大视频的场景出发，引出了一系列问题和解答。

*   首先，如果遇到`丢包`问题怎么办？引出了 TCP 数据的**重传机制**要保证不丢包，这跟连接建立和关闭过程的信号包的一定次数重传是不同的。
*   另外，类似于运货，如果货物量大而只有一个货车的话，那运输效率是很低的，这引出了如何`提升吞吐量`的问题，所以 TCP 为应用程序提供了**流量控制机制**，既能提升吞吐量又能防止数据溢出。

下一节将继续讨论如果网络情况不佳，就像货车在路上遇到拥堵一样的情况时，TCP 协议会使用什么机制来处理呢？

最后再留一个问题给你思考：`接收窗口大小变为0`之后，发送方和接收方后续是否就无法再传送数据了呢？

欢迎你在留言区分享你的答案，我们一起交流和进步！