你现在已经了解到了网络是如何形成的，而且通过各层的协议，包通过物理介质传输到各个目的地。

那么关于这些包，它们长什么样子呢？可能你有所担心——说起它们，你也许会说不就是沉闷的 IP 包么？但是我可以保证你：这其实是很有意思的，IP 包里面封装的是有意思的故事！我们就一起来看看吧~

深入 IP 包格式，并捕获一只包！
-----------------

IP 包头有一个固定的格式，我们可以使用`tcpdump`抓取网络上的数据包。

这里我刚刚通过`tcpdump`抓取了一个 IP 数据包，如下图所示，通过对比来理解 IP 数据包头部的结构和内容。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a98d150ea72240bb8fac724d716ecebf~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=3122&h=1484&s=856892&e=png&a=1&b=232323)

> 图片左侧是 IP 包的提示图，包头部分和数据，右侧是网络数据中传的一个真实的包。

接下来我不是按照字段出现的顺序来讲解，而是将相关的字段放在一起描述。我在图上也已经标记了包格式中的几个对应的字段，协议包的第一个字段就是`IP 版本`，下面来讲讲它的故事！

版本延续，各自精彩！
----------

可以看到上图 IP 报文对应的版本值为`0100`，0100 表示 IP 版本是`IPv4`。IP 数据报开始的地方占有 4 个比特，这 4 个比特用来标记当前使用的 IP 版本。IPv4 目前是网络世界使用最广泛的版本，它之前也经历了多次迭代升级。`IPv4`的发展历史始于 1981年，这个版本在当时是一个重大的技术飞跃，它不仅提高了传输效率，而且更加方便了数据传输，使得数据传输速度更快、性能更强，于是得到了广泛的运用！

但是，由于 `IPv4` 只有 32 位地址，而现在大多数网络都需要更多的地址空间，这就限制了`IPv4`的使用。随着`IPv4`地址空间的不足，官方组织推出了`IPv6`。数值`0110`表示 IPv6，通过解析出版本字段，我们才可以了解报文格式如何解析，因为`IPv6`的报文格式也不一样。

上图中右侧显示`0100`，因此应当按照左侧`IPv4`标准来进行解析。如果是`0110`，则应当按照下图侧`IPv6`标准来进行解析

`IPv6`的报文格式如下：`IPv6`头大小为 40 字节，其中 8 字节用于版本号、流量类型、流标识、TTL 等，16 字节用于源地址，16 字节用于目的地址。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd6a17811f342eb9335c45dab0ada52~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1375&h=1089&s=109301&e=png&a=1&b=fa5252)

`IPv6`的地址由 4 字节扩展到 128 比特，也就是 16 字节，原来 4 亿的地址空间可能不够用，而现在 16 字节的地址可是几乎一个无穷大的数字，再也不担心 IP 的地址空间不够用了。

下图就是抓到的一个 IPv6 的包，图中灰色部分的就是占有 16 个字节的 Source Address。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7db847a188024fb69d127dc18c613d7b~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=2939&h=1872&s=1962492&e=png&a=1&b=242424)

你是否观察到了，无论是`IPv4`还是`IPv6`，`TTL` 字段（在`IPv6`里面叫跳限制）都存在。很多系统 `IPv4` 包默认的值 TTL 都是 64，图上 `IPv6` 的`TTL`值为 255。`TTL` 是 IP 路由中非常重要的一个字段，用于控制 IP 包的生命周期，以防止网络路由的死循环。

> 先给你留一个思考题：为什么很多系统 IPv4 包默认的值 TTL 都是 64？而为何 IPv6 的 TTL 默认更大？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd7082b6edb24289b1721fa161299493~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1580&h=771&s=72190&e=png&a=1&b=fa5252)

如果网络出现了如上图所示的环路，则会一直在 B、C、D 之间路由，出现死循环。但是如果我们 `TTL` 设置了一个值，传输过程则会在到达这个值后结束路由。当 IP 包在网络中路由，跳数达到`TTL`值时，如果还没有到达目的地，所在的路由器或交换机节点会返回一个 `ICMP 协议`（一个辅助 IP 协议的控制协议）的包给发送端来告知这个情况。

谈起 `TTL`，也提及了 `ICMP`，让我们来看看它们是如何一起工作的。首先，我们要学习一个命令：`traceroute`，它是用来检测数据包传输路径的工具，能够帮助我们发现互联网节点间的连接和传输问题。

生命周期`TTL`涅槃重生——Traceroute 的工作原理
-------------------------------

`Traceroute` 使用 `Internet Control Message Protocol（ICMP）`来对各个中间节点执行一序列 **“回声请求”** 。

话不多说，先让我们尝试一下怎么使用 `traceroute` 命令，如下就是一个最简单的例子：

    # traceroute baidu.com
    traceroute to baidu.com (39.156.66.10), 64 hops max, 52 byte packets
     1  192.168.1.1 (192.168.1.1)  3.558 ms  2.876 ms  3.097 ms
     2  100.64.0.1 (100.64.0.1)  128.906 ms  5.004 ms  4.969 ms
     3  14.147.75.5 (14.147.75.5)  4.822 ms  4.598 ms  5.202 ms
     4  14.147.127.29 (14.147.127.29)  6.968 ms
        14.147.127.5 (14.147.127.5)  8.852 ms
        14.147.127.25 (14.147.127.25)  8.702 ms
     5  202.97.55.241 (202.97.55.241)  58.639 ms
        202.97.55.245 (202.97.55.245)  41.448 ms  41.739 ms
     6  202.97.17.78 (202.97.17.78)  73.642 ms
        202.97.17.90 (202.97.17.90)  41.668 ms
        202.97.17.78 (202.97.17.78)  90.743 ms
     7  221.183.86.45 (221.183.86.45)  44.610 ms  74.885 ms
        221.183.128.137 (221.183.128.137)  42.165 ms
     8  221.183.94.21 (221.183.94.21)  62.601 ms  79.148 ms
        221.183.94.25 (221.183.94.25)  79.164 ms
     9  221.183.49.138 (221.183.49.138)  68.653 ms
        221.183.49.142 (221.183.49.142)  95.324 ms *
    10  111.13.0.174 (111.13.0.174)  47.902 ms *
        111.13.188.38 (111.13.188.38)  59.023 ms
    11  39.156.27.1 (39.156.27.1)  47.809 ms
        39.156.27.5 (39.156.27.5)  47.245 ms *
    12  * * *
    

`traceroute` 命令使用非常简单，结果返回了路由的每一跳以及需要的时间。那它是怎么做到的呢？

**traceroute 正是充分利用 IP 包的 TTL 特性来达到记录中间路由的目的**。`traceroute` 工具会发送 `UDP 数据包`到指定的目标地址，但是会将初始 `TTL` 设置为 1，然后将数据包发送出去。可想而知，只要稍远一点的目的地，这个包就无法到达，到达某个中间节点的时候可能会因为 `TTL` 超上限，该中间节点部署的辅助 IP 的 `ICMP` 协议会返回一个错误码到发送方，发送方记录下该中间节点和花费的时间。发送方 `traceroute` 在 `TTL` 没达到目的地之前，会每次给 `TTL` 加 1，并重复上面的步骤。

从 `traceroute` 命令的结果可以看出，我本地到 `baidu.com` 的过程中一共经历了十几跳，第一跳是本地网关 192.168.1.1，到网关的 `RTT`（“Round Trip Time”，是指从发送网络数据包到接收到对应确认数据包所需要的时间） 大约是 2.9ms。我们还可以看到第四跳有三种选择，RTT 也略有不同，这是有多个可选路由的原因造成的。从第四跳到第五跳之间差别很大，需要 30 多 ms，怀疑是第 4 节点到第 5 节点的部署距离有点远。从第五跳以后到最终到目的地也没有花费很多时间，所以怀疑从第五跳就已经到了 `baidu.com` 的数据中心了。再通过 IP 资料库（有很多开源的，比如`https://ip.useragentinfo.com/json?ip=14.147.127.29）`查询到各个 IP 所处的地址，拓扑图如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c19865e436426f8d65c384f99a5038~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1540&h=1460&s=142095&e=png&a=1&b=4c6ef5)

确实如此，第五跳已经到达了西安，这个地方正好有百度的数据中心。据传，百度的数据中心分布在北京亦庄、酒仙桥 M1 和山西、贵州等地。不同于广州到西安所要花费的长时间，西安、贵州和北京相互之间虽然距离远，但是传输速度却很快，这是因为数据中心之间专用线缆使得传输速度非常快。同时，我在本地使用`sudo tcpdump icmp -vv` 抓到了对应的 `ICMP 包`，如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/527934f4a1d546dd8d573b61cf2aed9f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1308&h=804&s=1030410&e=png&b=012b31)

我们点开的这个包对应的 `TTL` 超过上限的响应包，这个包正是路由经过的中间节点返回的包。可以观察到，`ICMP 包`被封装在 IP 包里面。IP 报文的上层协议字段值为 1，表示 `ICMP 协议`；另外上层协议字段值 8 和 4，则分别代表传输层的 TCP 协议和 UDP 协议。

到此为止，我们总算将 `traceroute` 的前因后果讲明白了！`traceroute` 非常巧妙地使用了 IP 协议的 `TTL` 字段，前面的数据包虽然在网络里面消亡，无法正常地到达目的地。但是后面的包却能多走一步，最终达到了让我们知道所有中间路由的目的，这不正像是“凤凰的涅槃重生”么！

你可以点击下面的图再次 check 一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e12f6100e56c48368458d744de98ca95~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1404&h=1447&s=156416&e=png&a=1&b=4c6df4)

总结
--

本文从捕获 IP 包开始，观察了 IP 包的格式和其极好的扩展性。IP 协议以其版本号作为第一个字段，使其能够适应不断变化的网络环境。由于 IPv4 地址空间的不足，IPv6 得以发展，其地址字段长度更长，同时延续了一些必要的控制字段。最后，还着重介绍了 `TTL 生命周期`和 `Traceroute` 工作原理。

IP 报文还蕴含着更多的故事，敬请期待后面相关的故事～