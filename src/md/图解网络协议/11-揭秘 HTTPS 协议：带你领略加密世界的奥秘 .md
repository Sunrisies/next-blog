因为 `HTTP` 协议传输的内容是明文，数据在传输过程中会经过代理服务器、路由器、Wi-Fi 热点等多个中间节点。如果这些节点上的设备或者人员恶意利用这些信息，那么传输的内容将会被完全暴露。

网络被监听了？别被蒙蔽了
------------

我们一直有在练习使用 `tcpdump` 和 `Wireshark` 对经过的流量进行抓包和分析，你可以发现通过这些工具我们就可以拿到通过的所有明文信息了，尤其是纯字符的 HTTP 协议。

我们平时将计算机作为终端，只是监测自己的流量。路由中间节点是可以监听通过它的所有流量的。下面是一种可能的方法使用终端计算机来模拟这样的一个中间节点：在计算机上使用一个软件程序来创建一个恶意的 Wi-Fi 热点。一旦你成功创建了恶意的 Wi-Fi 热点，现在，你可以尝试模拟偷听网络上的信息。你可以使用 `Wireshark`和`tcpdump`，比如`tcpdump -A -i xxx` 来查看任何通过恶意 Wi-Fi 热点传输的数据，包括用户名、密码和其他敏感信息。

需要注意的是，模拟恶意 Wi-Fi 并偷听网络上的信息可能会触犯法律，因此仅在合法测试环境下进行。在现实情况下，进行此类攻击是非常不道德和非法的。

在支付服务和账号信息等领域，我们需要对信息进行加密以保护其安全。这是因为信息可能会被暴露或者遭受中间人攻击，例如篡改传输等信息而不被发现。因此，为了防止这些场景和问题，对信息进行加密是非常必要的。

加密技术：古老而历久弥新
------------

计算机密码学中有两种加密技术，分别是对称加密和非对称加密。

`对称加密`需要一个密钥用于加密和解密信息，并且执行加密和解密的过程都很快，但是无法给庞大互联网的载体 HTTP 服务加密，因为密钥的传递不安全。为了解决这个问题，数学家们和科学家们在 70 年代研究出了非对称加密。`非对称加密`需要两把钥匙，分别是公钥和私钥，**公钥加密的内容必须用私钥才能解开，私钥加密的内容公钥可以解开**。

以下是使用 OpenSSL 命令行工具生成密钥对、加密、解密和签名的示例。

### 生成密钥对

生成私钥：

    # openssl genpkey -algorithm RSA -out private_key.pem
    

生成对应的公钥：

    # openssl rsa -in private_key.pem -pubout -out public_key.pem
    

以上示例中，我们使用 OpenSSL 的 genpkey 命令生成了一个 RSA 私钥，并通过 rsa 命令生成了相应的公钥。

### 加密和解密

加密：

    # echo "Hello World" > plain_text.txt
    # openssl rsautl -encrypt -inkey public_key.pem -pubin -in plain_text.txt -out encrypted_text.txt
    

解密：

    # openssl rsautl -decrypt -inkey private_key.pem -in encrypted_text.txt -out decrypted_text.txt
    

以上示例中，我们使用 rsautl 命令对明文进行加密，并使用相应的私钥进行解密。

### 签名和验证

在加密技术里面，还有一个很有意思的技术：`数字签名`，在现实世界里签名是指在文件、合同等文件上盖章，以示认可、确认或授权的行为。签名通常用于证明文件的真实性、完整性和可靠性，同时也是法律认可的证据。在数字领域中，`数字签名`是利用密码学技术将电子文档与签名者身份相关联的数字代码。

虽然这种说法准确，但还是比较抽象。让我们看一个具体的数字签名的例子。 假设有两个文件：`plain_text.txt`和`plain_text2.txt`。 `plain_text.txt`是一张欠条，内容为“张圆规于2015年4月1日向李圆规借了100元，约定3%的利息，10年后归还”。现在需要欠债人`张圆规`对其进行签名。如果将来出现纠纷需要法律追责，可以通过权威机构验证张圆规的“公章”（使用的是私钥，公钥已公布）来确认这个欠条是张圆规签订的，如果验证成功则欠条具有法律效力，不可抵赖。

此外，`plain_text2.txt`是一本书，也需要作者张圆规进行电子签名。

我们可以使用以下命令对`欠条`进行签名：

    $ cat plain_text.txt
    张圆规于2015年4月1日向李圆规借了100块，约定3%的利息，10年后归还。
    
    # 签名
    $ openssl dgst -sha256 -sign private_key.pem -out signature.txt plain_text.txt
    
    #验证
    $ openssl dgst -sha256 -verify public_key.pem -signature signature.txt plain_text.txt
    Verified OK
    
    
    

签名过程：使用`sha256`算法对文件`plain_text.txt`进行哈希，再用私钥`private_key.pem`加密得到签名，并将签名保存在`signature.txt`文件中。

验证过程：使用公钥`public_key.pem`对`signature.txt`进行解密，然后将解密得到的结果与`plain_text.txt`的`sha256`哈希值进行比较。如果相同，则说明签名是有效的。

我们也可以测试对`plain_text2.txt`这本书进行签名，结果为`signature2.txt`。如下图所示，尽管文件内容差别很大（欠条和书），它们的大小各不相同，但由于使用相同的哈希算法，哈希值的长度是一致的。签名文件的大小也是一样的。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ec531089c74fe39ead2433839718c9~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1552&h=689&s=284342&e=png&b=012b36)

可以看到签名的过程是用到了密码学技术的，可能有人要问，那签名和加密的区别是什么？ 签名和加密的区别在于它们的目的不同。

加密是为了`保护数据的机密性`，以便只有授权的人能够查看和理解数据（解密之后能看到数据）。 签名是为了`验证数据的真实性`，以便接收方能够确定数据是否真实（比如这里的例子里先求出哈希值，再加密，所以仅通过解密的数据不一定能得到原始数据，只是为了验证原始数据的真实性）。

揭秘 HTTPS 协议
-----------

正如之前所分析的，因为互联网络的复杂性，仅依赖对称加密是不足以应用于 HTTPS 协议的。所以，HTTPS 服务器会生成一对公钥和私钥，以确保客户端能够安全地传输信息。

### 公钥和私钥对，解决密码信任问题

如果仅服务器拥有一对密钥，那么服务器发送的消息仍然是未加密的。为了解决这个问题，客户端也可以生成一对密钥，并将公钥发送给服务器。这样，服务器向客户端发送的信息都会使用客户端的公钥进行加密。虽然这样的通信方式确保了安全性，但你会发现交互速度变得非常缓慢。

我们观察到对称加密和非对称加密在效率方面的一些数据：

加密算法

加密与解密速度

AES-128

约为3.6Gbps

AES-256

约为2.1Gbps

RSA-2048

约为11ms

ECC-256

约为1ms

`AES-128`和`AES-256`是对称加密算法，效率非常高；而`RSA-2048`和`ECC-256`是非对称加密算法。非对称加密的效率相对较慢，而对称加密的吞吐量却非常高，两者之间存在明显的数量级差异。

### 通信：兼顾安全性与效率

那么如何改进这个问题呢？

当HTTPS 服务器生成一对公钥和私钥之后，客户端就能够安全地使用公钥加密传输信息给服务器了，那么假设这里传输的是另外一个`用于对称加密的密钥`，那么这个密钥则是别人不知道的，服务器用私钥解密得到这个新的用于对称加密的密钥！这就从`非对称加密`变成了`对称加密`，那数据传输的吞吐量就可以提升上来了，不是吗？

实际上，HTTPS 的交换过程正是通过使用非对称加密算法来约定一个新的对称加密密码，从而确保数据安全传输。这种思路真是非常巧妙～如下图所示，HTTPS 通信过程包括以下步骤：

1.  客户端进行通信请求；
2.  服务器生成一对公钥和私钥；
3.  服务器发送公钥；
4.  客户端使用服务器的公钥加密一个随机数；
5.  客户端将加密后的数字发送给服务器；
6.  服务器使用私钥解密，得到随机数。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b760aa681074f11935149cfd9a92341~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1943&h=1023&s=224325&e=png&a=1&b=228be6)

之后的通信内容将使用这个随机数进行加密，实现安全且高效的通信。然而，你是否考虑过，如果这个协商过程被人监视，仍然存在中间人攻击的风险。接下来，让我们模拟并分析这种情况。

### 中间人攻击：使用 CA 进行防护

当客户端访问 HTTPS 服务时，如果作为位于服务器和客户端之间的某个节点是一个坏人，那么所有传输的数据都会被我截获。攻击过程如下：

1.  我截获了客户端发出的 echo 请求，然后将服务器返回给客户端的公钥偷偷替换成我的公钥，将我的公钥返回给客户端。
2.  当客户端用我的公钥加密一个随机数并将其发送给服务器时，我可以轻松地使用我的私钥解密这个随机数并使用服务器的公钥再次加密。
3.  现在，我也拥有了与服务器相同的密钥，可以开始通信了。
4.  由于我已经拥有了密钥，所以我可以轻松地解密并查看所有通过我的节点传输的数据。

这是非常危险的，真替这个过程担忧。具体的截获过程可以参考下图：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c70d246d0941c486ee363f63768e22~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=3013&h=1020&s=453331&e=png&a=1&b=228be6)

这种方式仍然不够安全，我们不应该信任中间节点发送的公钥，而应该只信任服务器的公钥。因此，HTTPS 引入了 CA（认证中心）这样一个机构来验证服务器公钥的真实性。

通过 CA 认证中心，服务器可以获得一个证书和签名，这个证书签名相当于对该域名的唯一认证。客户端需要使用 CA 的公钥来解开证书签名，以校验服务器公钥的合法性。具体过程如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7c400edad61428ab68c723582eadc09~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=3960&h=1320&s=531438&e=png&a=1&b=238ae5)

你可以尝试描述一下这个过程，并思考在这个过程中是否仍有可能被黑客利用的漏洞。

但我认为，首先，证书是通过 CA 认证中心的私钥加密的。如果证书被篡改，由于攻击者无法获取 CA 的私钥，因此无法成功篡改证书。系统信任的根证书是已知的，并且已经预先安装在系统中，如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccbdb43082df4746b13da9e34952059d~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=5040&h=4882&s=11546518&e=png&a=1&b=202424)

这些系统根证书也包含了它们的公钥等信息，公钥用于给这个 CA 签名的内容去解密的。

然而，如果 CA 本身不可靠，也就是说黑客创建了一个虚假的认证中心，这种情况就需要格外小心。为了避免被黑客利用漏洞，不要安装不受信任的 CA。

关于证书的理论，我们已经讨论了很多。

现在是时候来实际了解一下实际的 HTTPS 部署以及证书的样子。

TLS/SSL 协议
----------

HTTPS 的这种思想实际上是使用 TLS/SSL 协议来实现安全通信的。TLS 和 SSL 类似，只是 TLS 在 SSL 的基础上有更好的效率和安全性。

TLS（Transport Layer Security）是一种加密协议，TLS 连接的建立过程称为握手（handshake）。

在 TLS 握手期间，客户端和服务器之间交换一系列消息以协商加密参数。其中包括密码套件，也就是加密算法的组合，以及其他安全参数，如证书验证方式等。

TLS 握手的流程如下：

1.  客户端发送一个 ClientHello 消息，其中包含支持的 TLS 版本号，随机数，以及一组支持的密码套件。
    
2.  服务器收到 ClientHello 消息后，返回一个 ServerHello 消息，其中包含服务器选择的 TLS 版本号，随机数，以及从客户端支持的密码套件中选择的一种密码套件。
    
3.  服务器还会发送一个数字证书，该证书包含服务器的公钥和其他相关信息。客户端使用该证书验证服务器的身份。
    
4.  客户端发送一个 ClientKeyExchange 消息，其中包含一个用于加密数据的随机值。该值使用服务器发送的公钥进行加密，并发送给服务器。
    
5.  服务器使用私钥解密客户端发送的随机值，并使用该值生成会话密钥。服务器将加密后的 Finished 消息发送给客户端，以验证会话密钥的正确性。
    
6.  客户端也会生成会话密钥，并将加密后的 Finished 消息发送给服务器，以验证会话密钥的正确性。
    
7.  握手过程完成后，客户端和服务器可以开始使用会话密钥加密和解密数据以保护数据传输的安全性和完整性。
    

在这个过程中，密码套件用于协商客户端和服务器使用的加密算法和密钥长度等参数，以确保数据传输的安全性和完整性。客户端和服务器会选择一种双方都支持的密码套件，并使用该密码套件进行加密和解密数据。

### 捕获一个 CA 签名证书

访问一个事先没有安装过证书的 https 网站，并且同时使用 tcpdump 进行抓包。我们可以捕获许多数据包来进行分析，包括 Client Hello、Server Hello 等消息，如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8e173db546046148b5acc8be73906d0~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=2920&h=1150&s=580485&e=png&b=262626)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73bd42c30cca42d781fceccc7d991bdd~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=2884&h=1290&s=477487&e=png&b=212121)

在之后还能捕获到发送证书的数据包，证书消息是 TLS 握手过程中的一个独立消息，包含服务器的公钥、证书链等信息，如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/384031e63a484a539e87f3089d46c9b2~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=3046&h=1194&s=519199&e=png&b=252525)

这个证书里面带了三层证书链信息，我们也可以使用浏览器进行查看，如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14c8766bbd1d4317bd3f030f7fd31b62~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1038&h=826&s=66167&e=png&b=fbfbfb)

我们来使用 js 模拟浏览器写一段验证签名的过程：

    // 获取证书链
    function getCertificateChain(cert) {
      const chain = [cert];
      while (cert.issuerCertificate && !cert.isIssuer(cert)) {
        cert = cert.issuerCertificate;
        chain.push(cert);
      }
      return chain;
    }
    
    // 验证证书链
    function verifyCertificateChain(chain) {
      for (let i = 0; i < chain.length - 1; i++) {
        const cert = chain[i];
        const issuer = chain[i + 1];
    
        // 验证签名
        if (!cert.verify(issuer.publicKey)) {
          return false;
        }
    
        // 验证证书有效期
        if (cert.validity.notBefore > Date.now() || cert.validity.notAfter < Date.now()) {
          return false;
        }
      }
    
      // 验证根证书
      const rootCert = chain[chain.length - 1];
      if (!rootCert.isIssuer(rootCert)) {
        return false;
      }
    
      return true;
    }
    
    // 示例：验证签名的代码
    (async () => {
      const certPEM = '-----BEGIN CERTIFICATE-----\n...'; // 从服务器获取的证书
      const forge = require('node-forge');
      const cert = forge.pki.certificateFromPem(certPEM);
    
      // 获取证书链
      const chain = getCertificateChain(cert);
    
      // 验证证书链
      const isValid = verifyCertificateChain(chain);
    
      console.log('Certificate chain is valid:', isValid);
    })();
    

数字证书验证过程中，客户端会使用 CA 证书来验证服务器证书的合法性，而 CA 证书本身也需要验证。如上面的代码所示：根证书是由受信任的 CA 组织颁发的，用于验证中间证书的合法性。中间证书是由 CA 组织颁发给其他 CA 组织的证书，用于验证服务器证书的合法性。在数字证书验证过程中，客户端会依次验证服务器证书、中间证书和根证书的合法性，以确保服务器证书的身份和信任级别。

CA 信任链就是一条从根证书到服务器证书的数字证书链，客户端通过验证这条链上所有证书的合法性来确定服务器证书的信任级别。只有当证书链上所有证书都是合法的、有效的且由受信任的 CA 颁发时，客户端才会信任服务器证书，建立 SSL/TLS 链接。如果证书是安全的，则浏览器的显示是类似下图这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77ecd6b2c3c1434599adc555dc7b781f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=644&h=476&s=120959&e=png&b=292a2d)

总结
--

本文首先提出在传输过程中，数据可能被中间节点截获。为了保护数据的安全，我们需要对信息进行加密。计算机密码学中有两种加密技术：对称加密和非对称加密。对称加密使用一个密钥进行加密和解密，而非对称加密使用一对公钥和私钥。

在 HTTPS 协议中，服务器和客户端通过非对称加密算法来协商一个新的对称加密密码，从而确保数据安全传输。然而，这个过程仍然可能受到中间人攻击。为了防止这种攻击，HTTPS 引入了`CA`（认证中心）来验证服务器公钥的真实性。通过 CA 认证中心，服务器可以获得一个证书和签名，客户端需要使用 CA 的公钥来解开证书签名，以校验服务器公钥的合法性。以上就是 HTTPS 的基本思想，具体来说，HTTPS 实际上是使用 TLS/SSL 协议来实现安全通信的。

那我们自己能否部署一个HTTPS服务器呢？