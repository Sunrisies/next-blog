估计很多小伙伴都有这同样的经历：在课堂上学习网络课程，尤其是学到网络 7 层或 4 层协议的时候，老师在讲台上侃侃而谈，同学们求知的眼神炯炯有神，偶尔地走神，厚厚的书中的文字却晦涩难懂，让你昏昏欲睡；应付考试或许不难，可以靠死记硬背，但很快你又发现已然忘了这些协议！此后的各种面试又只能疲于应付。哈哈，没错，我也是有这样的经历。

课堂上学习是一回事，求职面试又是一回事，而实际工作中又是另一回事。

特别是在实际工作中，遇到**网络协议尤其是网络传输层的问题是非常常见的**，如果不懂传输层的知识，很多问题都无法解释、无法解决；相反，如果对这些知识能做到融会贯通、举一反三，那遇到的问题往往也都能迎刃而解。

分享几个我曾经在实际生产环境里遇到的 `TCP 协议`相关的问题，不知道你是否遇到过、困惑过，一起来看看这些问题吧。

*   `telnet` 对方服务 的 `80 端口`不通了，可对方在本地查看 `80 端口`是正常的，这是为什么？
*   当创建连接超时了，发现是在 127s左右后发出告警。为什么超时的时间是 `127s`左右？
*   当我们主动创建连接的时候，应该使用`长连接`还是`短连接`？
*   为什么客户端连接池的连接很多处于`CLOSE-WAIT` 状态？这有什么影响？

这些问题你是否能很快给出解答呢？如果你可以全部回答，恭喜你！网络协议相关的知识掌握得非常好了。如果还有些疑问，请带着这些问题读下去吧。

上面的这些问题，需要对`传输层`**的协议**有非常深刻的认识。本文就来深入剖析**网络传输层`TCP 协议`的设计思路**，这可以帮助你从根上理解 TCP！

从传输层开始，开启网络探索！
--------------

计算机网络四层或七层只是划分的标准不同，目前四层的划分已成为主流。按照四层讲解的话，`从上到下`依次是：**应用层、传输层、网络层**和**网络接口层**。

*   `应用层`，即我们平时开发的应用程序，通过调用read/write或者recv/send接口来读取/写入网络数据。
*   `传输层`，**数据传输的机制**（这就是本文接下来要重点讲解的）。
*   `网络层`，负责数据包的路由。
*   `网络接口层`，是最底层的，对应七层划分的链路层和物理层，使用物理介质来传送数据。

网络分层情况如下示意图：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3b77a013edc49dfa1d5beb01ae2887f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=596&h=396&s=45956&e=png&b=b0bae9)

看到这里，估计有小伙伴会有疑问：应用层调用api进行“发”和“收”，网络层负责“送”，这整个路径不就跑通了吗？为什么还要多加个传输层呢？

计算机中的每层都是不同的角色，让我们切换不同角色的视角来看看它们做了什么。

从网络层的视角来看，“我只是一个快递员，穿梭于各个城市各个社区（机器），将货物（数据包）投送到目的地”。现实中的快递可能会因为运输路线不同导致收货的次序与下订顺序不一致，因为磕碰导致物件损毁，甚至因为偶然的疏忽导致丢失，同样，网络层在“投递”数据包时也会出现这些问题，造成数据包的乱序，损坏，甚至丢失。然而，和现实中的快递公司不一样的是，网络层对这些可能的情况不会负任何“法律责任”，在它看来这都是稀松平常的事情。

从应用层的视角来看，“我只需要简单地调用快递公司（网络协议）提供的服务来发送或者接受快递（数据）就好”。假设“网络层”这个快递公司没有和你签订任何保证协议，就意味着你发出去的信件可能损毁了或者中途丢失了，同时你也可能收不到商家给寄来的货物，出现这些意外情况时，你甚至也得不到任何通知。为了安全投递数据，你只能和对方约定好，当收到对方的信件/货物时，务必回信知晓，如果再约定的时间内没有收到回信，要重新发送。

如果任何一个应用程序在发送/接受数据的时候都要自己处理好这些问题，这该是多么困难且痛苦的一件事情啊。为了简化应用程序开发，“传输层”这个中间层就出现了，它提供了多种服务质量的协议给上层的应用，如果应用程序不想因为数据包损坏、丢失这类问题而烦恼，就可以和“传输层”签订一个高质量数据包投递的协议（即TCP），让它替你处理这些繁琐的事情。

总的来说，传输层主要提供两大功能：

*   标识应用层提供的服务；
*   为应用层服务提供不同质量的数据投递服务。

### 标识服务：端口分配

网络层是根据机器的ip地址在机器之间路由数据的，数据送达目的机器之后，网络层的任务就已经完成，至于到底要派发给应用层的哪个程序，它就不清楚。为了解决数据的归属问题，传输层为每个应用程序建立的网络连接都分配 相应的“标识符”（即端口），当收到传输层送来的数据包时，他通过数据包中的端口信息就能确定到底派发给哪个网络连接了。

端口，这个传输层为应用层提供的的“标识符”，是一个 16 位的数字，用来标记应用层的某个服务。因为端口号是一个16位的数字，而每个连接的端口号又必须不一样，所以一个机器所能够分配的连接数就是有上限的。

下面以传输层提供的**UDP** **协议**来展示数据包是如何携带端口信息的。

UDP 协议是传输层提供的一种低质量的数据包“投递服务”，它仅仅是给应用层传递下来的数据加上一个UDP头部信息，然后直接扔给传输层就了事了。UDP报文的格式如下图，源端口和目的端口分别用来标识自己的端口和对方的端口，长度表示整个 UDP 包的总长度，校验和用来做整个数据的校验。（图中的IP数据报则是底层网络层追加上去信息，包含了通信双方的ip地址信息）。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78e68ed418884f289515f2a3db0690dc~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=239&h=196&s=14437&e=png&b=fefefe)

随着数据顺着网络层次结构逐层传递下来，数据包会越来越大，包含的信息也越来越多，用户的数据被包裹在里面，就像一个洋葱一样。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73bdaa83d94141219613159836faeced~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1622&h=957&s=133740&e=png&a=1&b=18266c)

### TCP 协议：一种可靠的数据传输协议

传输层提供了多种传输协议，满足上层应用不同的可靠性和安全性要求，而其中最为常用的协议当属UDP和TCP协议了。前面提到过， UDP 只是对网络层的简单封装，不能保证数据的可靠传输，有丢包和乱序的可能。但是，绝大多数的应用程序对传输的质量有要求，需要保证数据的**准确**到达。而TCP 协议便是这样一种可靠的数据传输协议，能保证数据能够准确地传递给对方。

那么 TCP 协议是怎么做到数据的准确传输的呢？我们一起来分析一下。对于应用程序来说，可以从两个视角来看**传输的质量**：

*   从`发包`的视角，所有发出的数据**都被对方收到**了；
*   从`收包`的视角，所有对端发出的数据自己都**按序收到**了。

我们结合如下示意图来说明一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbf7e31cfc43417ba402e82c92e95070~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=382&h=306&s=33357&e=png&b=ffffff)

图中，C1、C2 分别表示和 app1 有网络交互的两个客户端。TCP 协议要保证 app1 发出的所有数据包都传递到了C2；并且C1发送给 app1 的数据也需要全部接收到，且按照C1发出的顺序一一接收。总之，TCP 协议主要是要达到**不丢包**和**保证数据的有序性**这两个目标。

为了`保证不丢包`，发送方发出消息后，需要知道对端是否收到了。如果对方没收到这个数据包，则采取一定的措施。发送方给每个发出的包都编排一个`序号 seq= X`，若是对端收到了序号为 X 的包，则要告知发送方 seq 为 X 的包收到了，TCP 协议使用 **ACK** **机制**来确认消息，使用 `ack=X+1 的回执`来确认 seq= X 的包已经收到。但是，如果对端没有收到 seq=X 的数据包呢？TCP 协议使用**重传机制**来处理这种异常。发送方在等待一段时间之后，如果一直没有 ack=X+1 的回执，就会重传 seq=X 的数据包。

为了`保证包到达的顺序`，也就是保证应用程序按照发送方发出的顺序一一接收到所有的数据包，TCP 协议使用了**接收窗口累计确认机制**。具体是怎样的呢？如下图所示，数据包通过网络到达接收窗口缓冲区的顺序不一定是有序的，比如 seq=1、2、3、6 的包依次到达接收窗口了，但只有 seq<=3 的数据包可以交付给上层的 TCP 应用程序，应用程序会按序取走接收窗口里可交付的数据包。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/810cd3a5759f4340aa4404eee79b2fd5~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=866&h=483&s=50634&e=png&b=afb9e9)

但 seq=6 的包不能紧挨着放在 seq 为 3 的包后面，而只能放到接收窗口里索引为 6 的位置上，中间留出两个位置，需要等到 seq=4 和 seq=5 的包到来之后，才会将 seq<=6 的包一起交付给上层的应用程序。收到 seq=6 的包之后，内核回复 ack=3+1；如果接下来先收到 seq=5 的包，此时内核还是回复 ack=3+1；最后收到 seq=4 的包，此时内核才回复 ack=6+1。

ack 发生变化意味着应用程序能取走新的有序的一批包了。因为采用了接收窗口累计确认机制，故而保证了应用程序收包是有序的。

到这里为止，我们已经了解到 TCP 协议的设计思想主要是围绕**序号** **Seq、回执** **Ack** **、重传和接收窗口累计确认**等机制来达成的。接下来，我们一起继续它们的具体实现吧！

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b41d23e5a5da48e79107cce3139fee49~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=456&h=278&s=19882&e=png&b=afb9e9)

TCP 协议：连接是怎样建立的？
----------------

为了保证不丢包并保证包到达的顺序，TCP 设计了一系列的工作机制，这些工作机制需要建立在`双方相互了解`的基础上。就像上文分析的那样，TCP 协议的设计主要是围绕**序号 Seq、回执** **Ack** **、重传和接收窗口累计确认**等机制，建立连接就是要获取这些必要的信息。双方相互知晓了各自的信息，连接就建立好了。

假设 A 和 B 之间要建立连接，则 A 要告诉 B 自己的初始序列号 Seq 和接收窗口大小，B 要用 Ack 表明自己能接收到 A 的消息。同理，B 也要告诉 A 自己的初始序列号和接收窗口大小，A 最后也要用 Ack 表明自己能接收到 B 的消息。通过这样的几次交互，各自的 Seq、Ack 和接收窗口的元信息就都确认了，这就为后续的网络数据传输做好了准备。

### 观察：连接建立的前后

TCP 协议是计算机内核实现的，我们可以使用 netstat 命令来监控连接建立前后的具体状态。

    # netstat -alpnt
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
    tcp        0      0 0.0.0.0:11110           0.0.0.0:*               LISTEN      26523/java     
    

上面显示的面板有一条 tcp 连接，处于`LISTEN`状态，端口是 11110。Foreign Address 列是准入限制的策略，IP 地址 **0.0.0.0** 表示可接受网络上所有 IP 的连接。

Linux 内核使用 **listen 系统调用**帮助建立连接，服务器调用 listen 函数、指定并占用某个端口，成功后处于 LISTEN 状态，再调用 **accept 系统调用**等待着客户端来建立连接。内核使用了套接字 **socket 对象**来作为网络连接的对象，调用 listen 后生成的 socket 对象是特殊的，此时并没有建立网络连接。这就是连接建立前，服务器等待建立连接的状态。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d540115051e4eeb9ca35e7d6a12aee5~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1837&h=485&s=58391&e=png&a=1&b=4473c4)

连接建立成功后，双方都会把连接建立的信息保存在内存里面。同样查看网络连接，如下：

    # netstat -alpnt
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
    tcp        0      0 9.13.73.14:38604      9.13.39.104:3306       ESTABLISHED 26100/java          
    tcp        0      0 9.13.73.14:32926      9.21.210.17:8080       ESTABLISHED 26100/java    
    

这里有两条 tcp 连接，处于`ESTABLISHED`状态，表示连接已经建立。本地端口 38604 和远程 IP 端口为 9.13.39.104:3306 的应用程序建立了连接，MySQL 默认使用 3306 端口，所以这个对应的远程应用程序一般是数据库 MySQL；本地端口 32926 和远程 IP 端口为 9.21.210.17:8080 的应用程序建立了连接，8080或80 一般是 Web 服务的默认端口。

### TCP 传输：是怎样的报文格式？

从 TCP 连接建立开始，就使用`自己特殊格式的报文`来交互。TCP 协议使用的报文称为 TCP 报文。TCP 报文遵循严格的格式，格式如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5023e629e08d47b2989592965c402b8c~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=488&h=374&s=35589&e=png&b=fefefe)

在 TCP 报文中，源端口和目的端口字段与 UDP 报文中的是一样的含义。**序列号**、**确认号**和**窗口字段**相对 UDP 是新增的字段，是上文我们分析到的 TCP 机制所需要交换的信息。每次交互都使用序列号 Seq，对上次接收到的信息的确认号都放在 Ack 字段里，Seq 字段和 Ack 字段都使用 32 位的整数。接收窗口代表自己的可用窗口大小，发送方发出的包的序列号不能超出这个窗口。

那么**接收窗口**是什么呢？如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64f44259eace4386b440ecb43dc656f9~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=955&h=662&s=75353&e=png&b=ffffff)

建立了 socket 连接的应用程序都被分配了一个固定大小的接收缓冲区，`接收窗口是缓冲区的一部分`。如果上层应用程序从接收缓冲区取走数据的速度慢，那么缓冲区堆积，留给接收窗口的可用区域会变得越来越小。如果上层应用程序从接收缓冲区取走数据的速度快，那么接收窗口就会留出更多的可用空间。

另外，TCP 报文里还定义了几个**特殊的比特标记位**，前面图中我标出了用得较多的 5 个。其中，SYN 标记位和 ACK 标记位在连接建立的过程中至关重要。

如果 `SYN 标记位`为 1，则说明这个报文是一个 SYN 类型的包，SYN 包的数据部分是空的，只用于连接的建立。连接建立过程里，客户端发送 SYN 包：SYN 标记置为 1，初始序列号 seq=x。然后，服务端收到 SYN 包后，发送 ACK 和自己的 SYN 包：SYN 被置为 1，初始序列号 seq=y；通过 SYN 报文交换了初始序列号之后，客户端和服务端在传输数据的过程中会使用单调递增的序列号。

如果 `ACK 标记位`为 1，则说明这个报文是一个 ACK 类型的包，ACK 用于确认某个数据包收到。在上面的例子里，服务端收到 SYN 包，首先回复 ACK，确认号 ack=x+1，表示 seq=x 的包已经收到，期待下一次收到 seq=x+1 的包。ACK 信息（ACK 比特标记位和 ACK 确认号）一般可携带在其他类型的数据包里一起发送。

另外的 3 个比特标记位依次是：`RST 标记位`，可用于强制断开连接；`PSH 标记位`，告知对方这些数据包收到后应马上交给上层的应用；`FIN 标记位`，用于关闭连接，后续的文章里会详细分析连接关闭的内容。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f0e511d23174a18ba294324337f6a52~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=2800&h=2103&s=447983&e=png&a=1&b=487ad1)

### TCP 连接：状态是怎样变迁的？

TCP 协议连接的状态随着交互的进行而推进。服务器发起 listen 系统调用后，处于`LISTEN`状态，比如监听 80 端口。客户端想要和服务器建立连接，于是发起 connect 系统调用来发起连接。

连接状态随交互的变化而变化的`变迁图`如下，我们一起来看一下吧！

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5249a186915f4e50b13f198b120d275a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=669&h=433&s=93342&e=png&b=ffffff)

第 1 步，客户端发起连接，对应着网络底层`发出 SYN 包`：SYN 标记置为 1，报文字段的 seq=x，这里 x 是系统随机生成的一个数；然后客户端连接被设置为 **Sync-Sent** 状态。状态命名为 Sync-Sent 很形象地解释了客户端刚刚的动作。如下面板中是个 SYN 包，seq 为 2701415924。

    08:31:58.919940 IP 192.168.255.10.60124 > 222.222.222.222.mdbs_daemon: Flags [S], seq 2701415924, win 65535, options [mss 16344,nop,wscale 6,nop,nop,TS val 1059371182 ecr 0,sackOK,eol], length 0
    

第 2 步，服务端收到 SYN 包后，`发送 SYN+ACK 包`：SYN+ACK 标记都置为 1，报文字段 ack=x+1，seq=y，这里 y 是系统随机生成的一个数；然后服务端连接被设置为 **Sync-RCVD** 状态。状态命名为 Sync-RCVD 用词也很精准，是 TCP 连接建立的中间状态。如下面板的 `Flags [S.], seq 41519147, ack 2701415925`：

    08:31:58.920284 IP 222.222.222.222.mdbs_daemon > 192.168.255.10.60124: Flags [S.], seq 41519147, ack 2701415925, win 65535, options [mss 16344,nop,nop,TS val 939846548 ecr 1059371182,nop,wscale 5], length 0
    

第 3 步，客户端收到 SYN+ACK 包，先处理包中携带的 ACK 部分，确认自己最初的 SYN 包是已被收到的。并且，客户端`发送 ACK 包`：ACK 标记置为 1，报文字段的 ack=y+1，客户端连接被设置为 **Established** 状态。这表示客户端认为连接已经建立成功，可以开始传输数据了。

第 4 步，服务端收到 ACK 包，服务端连接也被设置为 **Established** 状态。

在上图中，我们看到，服务端的 ACK 可以携带在 SYN 包里，使得原本需要收发 4 次的交互减少为 3 次，所以连接建立的过程也被称为**三次握手过程**。通过三次握手，网络上的两个应用程序慢慢地相互了解了，连接状态逐渐变化，最终建立了一条 TCP 连接。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0857e22d73e47609963786181ee022d~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.image#?w=1458&h=842&s=158359&e=png&a=1&b=487ad1)

总结
--

网络传输层的 TCP 协议要达到**保证网络传输质量**的目的，主要为`不丢包`和`有序交付`这两个详细的目的服务，设计了一系列的机制：序号 Seq、回执 Ack、重传和接收窗口累积确认。在实现 TCP 协议的过程中，每一步都围绕着这样的目的去实现。

本文后半部分我们详细分析了 TCP 报文是怎样设计的以及 TCP 连接是怎样的状态变迁。由于篇幅限制，在接下来的两篇文章里，会继续详细探讨 TCP 协议**数据传输**和**连接关闭**的实现，它们的实现依然是围绕着本文探讨的目的和机制。

还记得本文开头提出来的一些问题吗？包括`连接不通`、`连接超时`和`连接关闭`等问题，有些问题你心中可能已经有了答案，这些问题的解答也会穿插在接下来的几篇文章里，我们一起去看一下吧～